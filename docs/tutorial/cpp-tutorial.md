### **第一章：C++程序的基石 —— 词法约定**

欢迎来到C++的世界！在我们开始建造宏伟的软件大厦之前，首先需要认识一下构成这座大厦的最基本的“砖块”和“钢筋”。在编程语言中，这些最基本的元素被称为**词法元素**或**标记 (Token)**。本章将带你认识这些基础构件，理解编译器是如何阅读我们编写的代码的。

#### **1.1 万物之始：标记 (Tokens) 与字符集**

想象一下我们正在阅读一篇中文文章。这篇文章由一个个汉字、标点符号、空格和换行符组成。C++程序也是如此，它的源代码由**标记 (Tokens)**和**空格 (Whitespace)**组成。

**标记是编译器能够理解的最小有意义单元**。 就好比是中文里的“词语”。C++中的标记主要有以下几类：

*   **关键字 (Keywords)**：如 `int`, `if`, `for`，是C++语言内定有特殊含义的词。
*   **标识符 (Identifiers)**：如我们给变量、函数取的名字。
*   **字面量 (Literals)**：如数字 `123`、`3.14`，文字 `"Hello"` 等表示固定值的“数据”。
*   **运算符 (Operators)**：如 `+`, `-`, `*`, `/`，用于执行计算。
*   **标点符号 (Punctuators)**：如 `;`, `{`, `}`，用于组织代码结构。

编译器在正式分析你的代码逻辑前，第一步工作就是把你的源代码文本文件“打散”成一个个独立的标记。而像空格、回车、制表符（Tab键）这类空白字符，主要是为了分隔标记，让代码更易读，编译器在分析时通常会忽略它们。

> **你知道吗？—— 字符集**
>
> 我们的代码本质上是一个文本文件，需要用一种编码方式来保存。C++标准规定了一套**基本源字符集**，包含了96个可以在源文件中使用的标准字符，包括26个大小写英文字母、10个数字以及一些常见的符号。 这保证了最基础的C++代码在世界各地的计算机上都能被正确读取。对于像汉字这样的非基本字符，现代C++也通过通用字符名称（如 `\uXXXX`）和Unicode编码（如UTF-8）提供了很好的支持。
>
> **【微软特定】** 微软的MSVC编译器还额外支持 `$` 字符，并且允许在源文件中使用基于特定文件编码（如中文的GBK或国际化的UTF-8）的字符。 但作为初学者，我们强烈建议**优先使用标准的英文字符**来编写代码，以保证最好的兼容性。

#### **1.2 给代码加点“说明书”：注释 (Comments)**

注释是代码中非常重要的一部分，**它是写给程序员自己或同事看的，编译器会完全忽略它们**。 好的注释可以极大地提高代码的可读性，帮助我们在很久之后还能快速理解代码的意图。

C++中有两种注释方式：

1.  **单行注释**：以 `//` 开始，直到这一行的末尾都是注释。
    ```cpp
    // 这是一个单行注释。它通常用于解释下面一行或一小段代码的功能。
    int age = 25; // 也可以用在代码行的末尾，对该行进行补充说明。
    ```

2.  **多行注释**：以 `/*` 开始，以 `*/` 结束，可以跨越多行。 这种语法与C语言相同。
    ```cpp
    /*
      这是一个多行注释。
      所有在这里面的内容，
      无论多少行，都会被编译器忽略。
      常用于函数或文件的整体说明。
    */
    ```

**新手提示**：养成随时写注释的好习惯！对于现在还看不太懂的代码，可以先用注释标记下来你的理解和疑问。

#### **1.3 给万物起个名：标识符 (Identifiers)**

在程序中，我们需要给变量（存放数据）、函数（执行操作）、类（自定义数据类型）等很多东西起名字。这些名字就叫做**标识符 (Identifiers)**。

给一个东西命名，总得有点规矩。C++标识符的命名规则如下：

*   **可以包含**：大小写字母 (`a-z`, `A-Z`)、数字 (`0-9`) 和下划线 (`_`)。
*   **必须以**：字母或下划线开头，**不能以数字开头**。
*   **大小写敏感**：`myVariable` 和 `myvariable` 是两个完全不同的标识符。
*   **不能是关键字**：你不能使用 `int`、`class` 等关键字作为标识符名称。

这里有一些例子：

```cpp
// 合法的标识符
int score;
int user_age;
int level2_boss;
int _private_data; // 通常下划线开头的标识符有特殊用途，初学阶段建议避免使用

// 非法的标识符
// int 2nd_player;   // 不能以数字开头
// int my-score;     // 不能包含连字符'-'
// int double;       // 不能使用关键字
```

**【微软特定】** 微软的编译器允许 `$` 作为有效的标识符字符，并且对标识符的有效长度有2048个字符的限制。 但为了代码的可移植性，我们应该遵循C++标准，避免使用这些特性。

**命名建议**：为了让代码更易读，建议采用有意义的单词来命名，例如使用 `userName` 而不是 `un`。常见的命名风格有：
*   **驼峰命名法 (Camel Case)**：`myVariableName`
*   **帕斯卡命名法 (Pascal Case)**：`MyClassName`
*   **下划线命名法 (Snake Case)**：`my_variable_name`
选择一种并坚持使用，能让你的代码风格更统一。

#### **1.4 语言的内置词汇：关键字 (Keywords)**

**关键字 (Keywords)** 是C++语言预先定义并保留的标识符，它们有特殊的语法含义。 你不能将它们用作变量名或函数名。

你不需要一次性背下所有关键字，随着学习的深入，你会自然而然地熟悉它们。这里列举一些最常见的：

*   表示类型的：`int`, `double`, `char`, `bool`, `void`, `auto`
*   控制流程的：`if`, `else`, `switch`, `for`, `while`, `return`, `break`
*   定义类型的：`class`, `struct`, `enum`
*   访问控制的：`public`, `private`, `protected`
*   其他：`const`, `static`, `new`, `delete`, `true`, `false`

完整的关键字列表可以在文档中查阅，但现阶段你只需要知道它们是“被语言占用了的特殊单词”即可。

#### **1.5 代码中的固定值：字面量 (Literals)**

**字面量 (Literal)** 是指在程序中直接表示一个固定值的元素。 简单来说，就是你写在代码里的“数据”本身。

*   **整数 (Integer) 字面量**:
    *   **十进制**: `100`, `42`, `0` (最常用的形式)。
    *   **十六进制**: 以 `0x` 或 `0X` 开头，如 `0xFF` (等于十进制的255)。
    *   **八进制**: 以 `0` 开头，如 `010` (等于十进制的8)。初学者容易混淆，建议少用。
    *   **二进制** (C++14起): 以 `0b` 或 `0B` 开头，如 `0b1010` (等于十进制的10)。
    *   为了方便阅读，可以在数字间使用单引号 `'` 作为分隔符，编译器会忽略它，如 `3'000'000`。

*   **浮点数 (Floating-point) 字面量**:
    *   带小数点的数字，如 `3.14159`, `0.5`, `18.0`。
    *   也可以使用科学计数法，如 `1.846e1` (表示 1.846 x 10¹，即 18.46)。

*   **布尔 (Boolean) 字面量**:
    *   只有两个：`true` (真) 和 `false` (假)。

*   **指针 (Pointer) 字面量**:
    *   `nullptr` (C++11起)，表示一个不指向任何地方的“空指针”。 这是一个非常重要的概念，我们将在后续章节深入学习。

*   **字符 (Character) 和字符串 (String) 字面量**:
    *   **字符字面量**: 用**单引号**`'`括起来的**单个**字符，如 `'A'`, `'%'`, `'\n'` (表示换行符)。
    *   **字符串字面量**: 用**双引号**`"`括起来的**一串**字符，如 `"Hello, C++!"`, `"你好"`。 字符串的末尾会自动添加一个不可见的“空字符”(`\0`)作为结束标记。
    *   **转义序列**: 在字符和字符串中，反斜杠 `\` 用来表示一些特殊的字符，例如：
        *   `\n`: 换行符
        *   `\t`: 水平制表符 (Tab)
        *   `\\`: 反斜杠本身
        *   `\"`: 双引号
        *   `\'`: 单引号

> **深入一点：字面量类型后缀**
>
> 有时我们希望明确告诉编译器一个数字是什么类型。例如，`123` 默认是 `int` 类型，但 `123L` 就表示它是一个 `long` 类型的整数，`123U` 表示 `unsigned int`，`123ULL` 表示 `unsigned long long`。 浮点数 `3.14` 默认是 `double` 类型，`3.14f` 则表示 `float` 类型。 初学阶段了解即可，暂时不必深究。

#### **1.6 组织与运算的符号：标点与运算符**

除了“词语”，C++也需要“标点符号”来组织语句和代码块。这些符号本身不产生计算值，但对编译器有重要的语法意义。

*   **常用标点**：
    *   `;` (分号): 语句的结束符，如同中文的句号。
    *   `{ }` (花括号/大括号): 用于创建代码块，界定函数体、循环体等。
    *   `( )` (圆括号): 用于函数调用、改变运算优先级等。
    *   `[ ]` (方括号): 用于数组访问。
    *   `< >` (尖括号): 用于模板。
    *   `#` (井号): 预处理器指令的标志。

*   **运算符**：
    *   我们已经见过一些，如 `+`, `-`, `=`, `<`。C++拥有丰富的运算符，我们将在后续章节详细学习它们的功能和用法。

#### **1.7 小试牛刀：你的第一个C++程序**

现在我们已经认识了构成C++程序的所有基本元素，让我们来看一个完整的“Hello, World!”程序，并尝试辨认出其中的各种“标记”。

```cpp
#include <iostream> // #是标点，include是预处理指令，<iostream>是头文件名

// main函数是每个C++程序的入口点
int main() // int是关键字, main是标识符, ()是标点
{ // { 是标点，开启一个新的代码块
    // 使用std::cout将字符串输出到控制台
    std::cout << "Hello, World!" << std::endl; // std, cout, endl是标识符; ::, <<是运算符; "Hello, World!"是字符串字面量; ;是标点

    return 0; // return是关键字; 0是整数字面量; ;是标点
} // } 是标点，结束代码块
```

### **第二章：C++程序的核心骨架 —— 基本概念**

在第一章中，我们认识了构成C++代码的“砖块”——标记。现在，是时候学习如何使用这些砖块来搭建程序的骨架了。本章将介绍C++中一些至关重要的基本概念，它们是理解后续所有编程知识的基础。

#### **2.1 万物皆有类型：C++类型系统**

在C++中，**类型 (Type)** 的概念至关重要。你可以把“类型”想象成一个特定形状和大小的盒子：

*   它规定了需要**多少内存空间**来存放数据。
*   它定义了可以存入**什么样的数据**（比如只能放整数，或者只能放文字）。
*   它决定了你可以对这些数据**执行哪些操作**（比如整数可以做加减乘除，而文字不行）。

C++是一门**静态类型、强类型**的语言。这意味着：

*   **静态类型**：每个变量、函数参数和返回值的类型都必须在**编译时**（即程序运行前）确定下来，并且**永远不会改变**。
*   **强类型**：编译器会严格检查类型。你不能把一个字符串赋值给一个整数变量，除非进行了明确的类型转换。

**声明和初始化变量**

当你想要在程序里存储数据时，就需要**声明 (Declare)** 一个**变量 (Variable)**。声明时，你必须指定它的类型和名称。一个好习惯是，在声明的同时对其进行**初始化 (Initialize)**，也就是给它一个初始值。

```cpp
// 语法: type variable_name = initial_value;

int result = 0;              // 声明并初始化一个名为 result 的整型变量。
double coefficient = 10.8;   // 声明并初始化一个名为 coefficient 的浮点型变量。
auto name = "Lady G.";       // 使用 auto 关键字，让编译器根据初始值 "Lady G." 自动推断 name 的类型。
                             // 在这里，编译器会推断出 name 是一个指向常量字符的指针。

// 错误示例
// auto address;       // 错误! 使用 auto 必须提供初始值，否则编译器无法推断类型。
// age = 12;            // 错误! 变量在使用前必须先声明其类型。
// result = "Kenny G."; // 错误! 不能将一个字符串字面量赋值给一个已经声明为 int 的变量。

int maxValue;          // 不推荐! 只声明不初始化，maxValue 的值是随机的“垃圾值”，
                       // 这可能导致难以预料的程序行为。
```

#### **2.2 C++的内置“积木”：基本（内置）类型**

C++语言内置了一些基础的数据类型，我们称之为**基本类型 (Fundamental Types)** 或**内置类型 (Built-in Types)**。以下是初学者最需要掌握的几种：

| 类型 | 大小 (Microsoft C++) | 描述和用途 |
| :--- | :--- | :--- |
| `int` | 4 字节 | **整数 (integer)** 值的默认选择。用于存储没有小数部分的数字，如年龄、数量、年份等。 |
| `double` | 8 字节 | **双精度浮点数**值的默认选择。用于存储带有小数的数字，如身高、体重、价格、数学计算中的π等。 |
| `bool` | 1 字节 | **布尔值**。只能是 `true` (真) 或 `false` (假) 两个值之一。常用于判断条件。 |
| `char` | 1 字节 | **字符 (character)**。用于存储单个ASCII字符，如 `'A'`, `'?'`, `'5'`。 |
| `wchar_t` | 2 字节 | **宽字符**。用于存储Unicode字符，可以表示比ASCII更多的字符，如汉字。 |

**类型修饰符**

大多数数值类型（如 `int`, `char`）还可以用 `signed` (有符号，默认) 和 `unsigned` (无符号) 来修饰。无符号类型不能表示负数，但其正数表示范围扩大了一倍。

*   `int` 的范围大约是 -21亿 到 +21亿。
*   `unsigned int` 的范围是 0 到 +42亿。

**特殊的 `void` 类型**

`void` 是一个特殊的类型，表示“无类型”或“空”。你不能声明一个`void`类型的变量。它最常见的用途是：

*   当函数**不返回任何值**时，将其返回类型声明为 `void`。

#### **2.3 让值保持不变：`const` 限定符**

有时我们希望某个变量的值在初始化后就不能再被修改。这时可以使用 `const` (constant，常量) 关键字来限定它。

```cpp
const double PI = 3.14159; // 声明一个名为PI的常量
// PI = 3.0; // 错误! 编译器会阻止你修改一个 const 变量。
```

使用 `const` 是一个非常好的编程习惯，它可以防止我们无意中修改了不该被修改的值，让程序更安全、更易于理解。这个概念被称为“常量正确性”。

#### **2.4 处理文本：字符串类型**

严格来说，C++没有内置的字符串类型。传统的C风格字符串是使用 `char` 数组来实现的。

但是，现代C++编程中，我们几乎总是使用标准库提供的 `std::string` 类型。它更安全、更方便。要使用它，你需要包含 `<string>` 头文件。

```cpp
#include <string> // 引入 string 库

std::string greeting = "Hello, C++!"; // 声明并初始化一个字符串变量
```
**强烈建议初学者始终使用 `std::string` 来处理文本，避免使用底层的C风格字符数组。**

#### **2.5 初探内存地址：指针类型**

**指针 (Pointer)** 是C++中一个强大但也颇具挑战性的概念。初学者需要理解其基本思想。

**一个指针变量存储的不是数据本身，而是另一个变量在内存中的地址。**

*   使用 `*` (星号) 来声明一个指针类型。
*   使用 `&` (地址运算符) 来获取一个变量的内存地址。
*   使用 `*` (解引用运算符) 来访问指针所指向地址上的数据。

```cpp
int number = 10;            // 一个普通的整型变量，值为10。

int* pNumber = &number;     // 声明一个整型指针 pNumber。
                            // 它存储的是 number 变量的内存地址。

// 现在, *pNumber 和 number 是等价的
*pNumber = 41;              // 通过指针修改了它所指向的内存。
                            // 这行代码执行后，number 变量的值也变成了 41。
```

**警告：原始指针的危险**
直接使用像 `int*` 这样的**原始指针 (Raw Pointers)** 是危险的，因为程序员必须手动管理内存，很容易忘记释放，导致**内存泄漏**。

**现代C++的解决方案：智能指针**
为了解决这个问题，现代C++推荐使用**智能指针 (Smart Pointers)**，如 `std::unique_ptr`。智能指针是一种特殊的对象，它包装了原始指针，并能在不再需要时**自动释放内存**。

**作为初学者，你现在只需要知道：**
1.  指针是存储内存地址的变量。
2.  直接使用原始指针进行内存管理是危险的，应尽量避免。
3.  现代C++提供了更安全的智能指针作为替代方案。

#### **2.6 名字的有效范围：作用域 (Scope)**

**作用域 (Scope)** 是指一个名称（如变量名、函数名）在程序中可见和可以使用的区域。

*   **局部作用域 (Local Scope)**：在函数或代码块（由 `{}` 包围）内部声明的变量，只在该函数或代码块内部有效。它会在程序执行离开该代码块时被销毁。这通常被称为“局部变量”。

*   **全局作用域 (Global Scope)**：在所有函数、类之外声明的变量，具有全局作用域。它从声明点开始，直到文件末尾都有效。**应尽量避免使用全局变量**，因为它们会使程序难以理解和维护。

**名称隐藏 (Name Hiding)**
如果在一个内部作用域中声明了一个与外部作用域同名的变量，那么在内部作用域中，外部的变量将被“隐藏”。

```cpp
#include <iostream>

int i = 7; // 全局变量 i

int main() {
   int i = 5; // 局部变量 i，隐藏了全局的 i

   std::cout << "局部 i 的值是: " << i << std::endl;     // 输出 5
   std::cout << "全局 i 的值是: " << ::i << std::endl;   // 使用范围解析运算符 :: 来访问被隐藏的全局变量 i, 输出 7
}
```

#### **2.7 程序的起点：`main` 函数**

每个C++可执行程序都必须有一个 `main` 函数。它是操作系统的入口点，即**你的程序从这里开始执行**。

`main` 函数最标准的形式是：
```cpp
int main() {
    // 你的代码从这里开始
    return 0;
}
```

*   `int main()`: 这被称为函数签名。它告诉编译器 `main` 函数会返回一个整数 (`int`)。
*   `return 0;`: 这是 `main` 函数的返回语句。按照惯例，**返回 `0` 表示程序成功执行完毕**。返回非零值通常表示程序遇到了错误。

`main` 函数还可以接收命令行传入的参数，但这是更高级的用法，我们暂时不必关心。

#### **2.8 灵活应变：类型转换**

有时，我们需要在不同类型的值之间进行转换。类型转换分为两种：

1.  **隐式转换 (Implicit Conversion)**：由编译器自动执行。
    *   **提升/扩大转换 (Widening Conversion)**：从小类型转为大类型，通常是安全的，不会丢失数据。例如，`int` 转换为 `double`。
        ```cpp
        int myInt = 10;
        double myDouble = myInt; // 隐式转换，myDouble 的值是 10.0
        ```
    *   **收缩转换 (Narrowing Conversion)**：从大类型转为小类型，**可能丢失数据**，编译器通常会对此发出警告。
        ```cpp
        double d = 1.9;
        int j = d; // 隐式转换，小数部分被丢弃，j 的值是 1。
                   // 编译器会警告：可能丢失数据。
        ```

2.  **显式转换 (Explicit Conversion / Casting)**：由程序员在代码中明确要求的转换。

在现代C++中，我们推荐使用命名的强制转换运算符，而不是老式的C风格转换。对初学者来说，最常用的是 `static_cast`。

`static_cast` 可以在编译时进行类型检查，比C风格转换更安全、更明确。当你确定收缩转换不会导致问题时，可以使用它来消除编译器的警告。

```cpp
double d = 1.9;
// int j = d; // 会产生警告

// 使用 static_cast 明确告诉编译器：我知道会发生什么，请执行转换。
int j = static_cast<int>(d); // j 的值是 1，没有警告。
```

**养成好习惯**：认真对待编译器的每一个警告。当你看到关于类型转换的警告时，要么修改你的逻辑，要么使用 `static_cast` 来表明你的意图。

### **第三章：C++的数据“盒子” —— 内置类型**

在上一章我们知道，C++中每个变量都必须有一个类型。本章将详细介绍由C++语言标准规定、内嵌在编译器中的**内置类型 (Built-in Types)**，它们也被称为**基本类型 (Fundamental Types)**。你不需要包含任何头文件就可以直接使用它们。

内置类型主要分为三大类：**整型**、**浮点型**和**void**。

#### **3.1 空类型：`void`**

`void` 类型是一个特殊的类型，它描述了一个空的值集合。你不能创建一个 `void` 类型的变量，它主要用于：
*   声明一个**不返回任何值**的函数。
*   声明一个**不接受任何参数**的函数（这是C的风格，在C++中函数 `()` 留空即可）。
*   声明一个“通用指针” `void*`，它可以指向任何类型的数据，但在使用前必须强制转换为具体的类型。

```cpp
void printMessage() // 这个函数不返回任何值
{
    // ...
}
```

#### **3.2 逻辑判断：布尔类型 (`bool`)**

`bool` 类型用于表示逻辑值，它只有两个可能的常量值：`true` (真) 和 `false` (假)。 `bool` 类型的大小是编译器实现特定的，在Microsoft C++中通常是1个字节。 它是进行逻辑判断和流程控制的基础。

```cpp
bool isGameOver = false;
isGameOver = true;

if (isGameOver)
{
    // ...
}
```
当 `bool` 类型被转换成整数时，`true` 变为 `1`，`false` 变为 `0`。

#### **3.3 存储整数：整型家族**

整型用来表示没有小数部分的整数。 `int` 是默认的基础整数类型。

**1. 基本整型**

| 类型名称 | Microsoft C++ 大小 | 其他名称 | 值的范围 |
| :--- | :--- | :--- | :--- |
| `short` | 2 字节 | `short int` | -32,768 到 32,767 |
| `int` | 4 字节 | `signed` | -2,147,483,648 到 2,147,483,647 |
| `long` | 4 字节 | `long int` | -2,147,483,648 到 2,147,483,647 |
| `long long` | 8 字节 | `__int64` | 大约 -9.2 x 10¹⁸ 到 9.2 x 10¹⁸ |

**新手建议**：在不确定时，**优先使用 `int`**。如果需要存储非常大的数字，再考虑使用 `long long`。

**2. 符号修饰符：`signed` 与 `unsigned`**

*   `signed`: 表示该类型可以存储正数、负数和零（这是默认的）。
*   `unsigned`: 表示该类型只能存储非负数（零和正数）。

使用 `unsigned` 的好处是，它放弃了负数范围，使得正数的最大值扩大了约一倍。

| 类型名称 | Microsoft C++ 大小 | 值的范围 |
| :--- | :--- | :--- |
| `unsigned short` | 2 字节 | 0 到 65,535 |
| `unsigned int` | 4 字节 | 0 到 4,294,967,295 |
| `unsigned long` | 4 字节 | 0 到 4,294,967,295 |
| `unsigned long long` | 8 字节 | 0 到 大约 1.8 x 10¹⁹ |

**注意**：在 `unsigned` 类型和 `signed` 类型之间进行运算时要格外小心，可能会因为类型转换导致非预期的结果。

#### **3.4 存储小数：浮点类型家族**

浮点类型用于表示带有小数部分的数值。 它们采用 IEEE-754 标准来表示，这意味着它们是近似值，在进行高精度计算时可能会有微小的误差。

| 类型 | Microsoft C++ 大小 | 描述 |
| :--- | :--- | :--- |
| `float` | 4 字节 | 单精度浮点数。精度较低，占用空间小。 |
| `double` | 8 字节 | 双精度浮点数。是**浮点值的默认选择**，具有更好的精度。 |
| `long double` | 8 字节 | 扩展精度浮点数。（在Microsoft C++中，它与 `double` 相同）。 |

**新手建议**：**优先使用 `double`** 来处理所有带小数的计算，以获得足够的精度。

#### **3.5 存储字符：字符类型家族**

字符类型用于表示字母、数字、标点等单个字符。

| 类型 | Microsoft C++ 大小 | 描述 |
| :--- | :--- | :--- |
| `char` | 1 字节 | 基础字符类型。足以存储本地的ASCII字符。 它本质上也是一个小的整数。 |
| `wchar_t` | 2 字节 | 宽字符类型。用于存储像汉字这样的Unicode字符。 使用宽字符字面量时需在前面加 `L`，如 `L'你'`。 |

C++11 和 C++20 还引入了 `char8_t`, `char16_t`, `char32_t` 用于支持不同编码的Unicode字符（UTF-8, UTF-16, UTF-32），但对于初学者而言，了解 `char` 和 `wchar_t` 就足够了。

#### **3.6 空指针常量：`nullptr`**

`nullptr` 是 C++11 引入的一个关键字，它是一个特殊的常量，表示“空指针”。 它的类型是 `std::nullptr_t`。

当你需要一个不指向任何有效内存地址的指针时，**应该总是使用 `nullptr`**，而不是 `0` 或 `NULL`。 `nullptr` 是类型安全的，可以避免一些潜在的编程错误。

```cpp
int* p1 = nullptr;    // 正确且推荐的方式
// int* p2 = NULL;    // 老式风格，不推荐
// int* p3 = 0;       // 老式风格，不推荐
```

#### **3.7 实践：查看类型的大小和值**

让我们通过一段代码来直观地感受一下这些数据类型：

```cpp
#include <iostream>
#include <string>

int main()
{
    // 整型
    int age = 30;
    unsigned long long worldPopulation = 7'800'000'000; // 使用单引号方便阅读

    // 浮点型
    double pi_approx = 3.1415926535;

    // 字符型
    char initial = 'J';

    // 布尔型
    bool isLearning = true;
    
    // 使用 sizeof 运算符查看类型占用的字节数
    std::cout << "Size of int: " << sizeof(int) << " bytes" << std::endl;
    std::cout << "Size of double: " << sizeof(double) << " bytes" << std::endl;
    std::cout << "Size of char: " << sizeof(char) << " byte" << std::endl;
    std::cout << "Size of bool: " << sizeof(bool) << " byte" << std::endl;

    std::cout << "\n--- Values ---" << std::endl;
    std::cout << "Age: " << age << std::endl;
    std::cout << "Initial: " << initial << std::endl;
    std::cout << "Is learning C++? (1 for true, 0 for false): " << isLearning << std::endl;

    return 0;
}
```
当你编译并运行这段代码时，`sizeof` 会告诉你每种类型在你的系统上占用的内存大小，这有助于你更好地理解它们。

### **第四章：赋予代码生命 —— 声明、定义与初始化**

我们已经认识了C++的各种基本类型，现在是时候学习如何创建这些类型的实体（如变量和函数），并赋予它们生命了。本章将深入探讨两个在C++中既相似又有着本质区别的核心概念：**声明**与**定义**，以及如何正确地为变量赋予初始值。

#### **4.1 蓝图与建筑：声明 (Declaration) vs. 定义 (Definition)**

在日常生活中，建筑师先画出“蓝图”（设计），然后施工队才根据蓝图建造出“实体建筑”。在C++中，声明和定义的关系与此类似。

*   **声明 (Declaration)**：就像是“蓝图”。它向编译器**介绍**一个名称，并告诉编译器这个名称是什么类型的（一个整数？一个函数？）。声明让编译器知道“哦，这个东西存在”，但并不为它分配内存。
*   **定义 (Definition)**：就像是“建造”。它不仅完成了声明的工作，还会为这个实体**分配实际的内存空间**。对于函数来说，定义就是提供函数的具体实现代码。

**一个实体可以被声明多次，但只能被定义一次。** 这被称为“单一定义规则 (One Definition Rule, ODR)”。

让我们看一些例子：

```cpp
// --- 声明 (Declarations) ---

extern int i;       // 声明一个名为 i 的整数。extern 关键字告诉编译器，
                    // 这个变量的“定义”和内存分配在别处。

int func(int x);    // 声明一个函数 func，它接受一个整数并返回一个整数。
                    // 这被称为“前向声明 (Forward Declaration)”。

class MyClass;      // 前向声明一个名为 MyClass 的类。


// --- 定义 (Definitions) ---

int i = 10;         // 定义一个名为 i 的整数，并为它分配内存，初始化为 10。
                    // 这同时也是一个声明。

int func(int x)     // 定义之前声明的函数 func。
{
    return x + 1;   // 提供具体的实现代码。
}

class MyClass       // 定义之前声明的类 MyClass。
{
    // ... 类的成员 ...
};
```

**对于初学者来说，最重要的准则是：**
当你创建一个变量并给它赋值时，你通常同时完成了声明和定义。

```cpp
int score = 100; // 这是一个定义，因为它为 score 分配了内存。
                 // 它自然也充当了声明的角色。
```

#### **4.2 创建你的变量：定义与初始化**

在C++中，创建一个变量就是定义它。一个至关重要的好习惯是，在定义变量时**立即对其进行初始化**（赋予初始值）。否则，变量将包含一个随机的“垃圾值”，这会是程序错误的常见来源。

**初始化的常用方法**

1.  **复制初始化 (Copy Initialization)**
    这是最传统的形式，使用等号 `=`。
    ```cpp

    int a = 5;
    std::string name = "Alice";
    ```

2.  **直接初始化 (Direct Initialization)**
    使用圆括号 `()`。
    ```cpp
    int b(5);
    std::string name("Bob");
    ```

3.  **列表初始化 (List Initialization) / 统一初始化 (Uniform Initialization)**
    这是C++11引入的**现代化、更推荐**的方式，使用花括号 `{}`。
    ```cpp
    int c{5};
    std::string name{"Carol"};
    
    // 也可以使用等号
    int d = {5};
    
    // 初始化为空值（零初始化）
    int e{}; // e 的值被初始化为 0
    ```

**为什么推荐使用列表初始化 `{}`？**
它更安全！它不允许“收缩转换”，即从一个大范围的类型转换为一个小范围的类型，从而避免潜在的数据丢失。

```cpp
double pi = 3.14;
// int x = pi;    // 复制初始化，编译通过但有警告，x 的值变为 3，小数部分丢失。
// int y(pi);    // 直接初始化，同样有警告，y 的值也是 3。
// int z{pi};    // 列表初始化，编译器会直接报错！因为它阻止了可能导致数据丢失的转换。
```
**新手建议**：养成使用 `{}` 进行初始化的习惯，它可以帮助你在编译阶段就发现潜在的错误。

#### **4.3 让编译器做推断：`auto` 关键字**

有时，一个变量的类型名称可能非常长且复杂。现代C++提供了 `auto` 关键字，让你不必显式写出类型，而是让编译器根据初始化表达式**自动推断**出正确的类型。

```cpp
// 传统方式
int x = 1;
std::string message = "Some long text";

// 使用 auto
auto y = 1;          // 编译器推断 y 是 int 类型
auto z = 3.14;       // 编译器推断 z 是 double 类型
auto msg = "Some long text"; // 编译器推断 msg 是 const char* 类型

// auto 必须在声明时初始化，否则编译器无法推断
// auto myVar; // 错误！
```使用 `auto` 可以让代码更简洁，并且在类型改变时更易于维护。

#### **4.4 创建常量：`const` 关键字**

我们在前面已经接触过 `const`。它用于声明一个常量，其值在初始化之后就不能再被修改。

**`const` 变量必须在定义时进行初始化。**

```cpp
const int screenWidth = 1920;
const double PI = 3.14159;

// screenWidth = 1024; // 错误！不能修改 const 变量```
使用 `const` 是一种向编译器和代码阅读者传达“这个值不应被改变”意图的有效方式，能够极大地增强代码的健壮性和可读性。

#### **4.5 控制“生命周期”与“可见性”：`static` 与 `extern`**

`static` 和 `extern` 是存储类说明符，它们会改变变量的默认行为。

**`static`**
当 `static` 用于函数内部的局部变量时，它会改变该变量的“生命周期”。

*   **普通局部变量**：每次函数调用时创建，函数结束时销毁。
*   **`static` 局部变量**：在程序第一次执行到其定义时被创建和初始化，并且**在函数调用结束后不会被销毁**。它的值会一直保留到下一次函数调用。它的生命周期与整个程序一样长。

```cpp
#include <iostream>

void counter() {
   static int count = 0; // 只在第一次调用时初始化为 0
   count++;
   std::cout << "This function has been called " << count << " times." << std::endl;
}

int main() {
   counter(); // 输出: ... 1 times.
   counter(); // 输出: ... 2 times.
   counter(); // 输出: ... 3 times.
   return 0;
}
```

**`extern`**
`extern` 关键字用于处理多文件项目。当你在一个 `.cpp` 文件中想使用另一个 `.cpp` 文件中定义的全局变量时，就需要使用 `extern` 来**声明**它。

`extern` 就像一个承诺：“编译器，请相信我，这个名为 `global_var` 的变量在别的文件里已经被**定义**了，你先通过编译，链接器会找到它的。”

```cpp
// --- FileA.cpp ---
#include <iostream>
int global_var = 42; // 定义

// --- FileB.cpp ---
#include <iostream>
extern int global_var; // 声明 FileA 中定义的全局变量

void useGlobal() {
    std::cout << global_var << std::endl; // 可以正常使用，输出 42
}
```

#### **4.6 给类型起个别名：`using` 关键字**

当类型名称很长或很复杂时，我们可以使用 `using` 关键字为它创建一个更简单、更有意义的**别名**。

```cpp
#include <string>
#include <vector>

// 为一个复杂类型创建一个别名
using NamesList = std::vector<std::string>;

void processNames(NamesList names) { // 使用别名，代码更清晰
    // ...
}

int main() {
    NamesList myNames = {"Alice", "Bob"};
    processNames(myNames);
}
```
**注意**：在老式C++代码中，你可能会看到 `typedef` 关键字做同样的事情。`using` 是C++11引入的更现代化、更灵活的替代方案。

### **第五章：让数据动起来 —— 运算符与表达式**

我们已经创建了各种类型的“数据盒子”（变量），现在是时候学习如何操作这些盒子里面的东西了。**运算符 (Operator)** 就是C++中用于对数据（也称为**操作数 (Operand)**）执行计算、比较或赋值等操作的特殊符号。

当运算符、字面量和变量组合在一起时，就构成了**表达式 (Expression)**。例如，`x + 5` 就是一个表达式，它的计算结果是一个值。

#### **5.1 基础数学：算术运算符 (Arithmetic Operators)**

这些是你最熟悉的运算符，就像计算器上的按钮一样。

| 运算符 | 名称 | 示例 | 结果 |
| :--- | :--- | :--- | :--- |
| `+` | 加法 | `10 + 5` | `15` |
| `-` | 减法 | `10 - 5` | `5` |
| `*` | 乘法 | `10 * 5` | `50` |
| `/` | 除法 | `10 / 5` | `2` |
| `%` | 取模 (取余) | `10 % 3` | `1` |

```cpp
#include <iostream>

int main() {
    int a = 10;
    int b = 3;

    std::cout << "a + b = " << (a + b) << std::endl; // 输出 13
    std::cout << "a - b = " << (a - b) << std::endl; // 输出 7
    std::cout << "a * b = " << (a * b) << std::endl; // 输出 30
    std::cout << "a / b = " << (a / b) << std::endl; // 输出 3 (整数除法，小数部分被舍弃)
    std::cout << "a % b = " << (a % b) << std::endl; // 输出 1 (10除以3的余数是1)
}
```**特别注意**：
*   **整数除法**：当两个整数相除时，结果仍然是整数，小数部分会被直接舍弃，而不是四舍五入。例如，`5 / 2` 的结果是 `2`。
*   **取模运算符 `%`**：它计算的是整数除法的余数。这个运算符在很多场景下都非常有用，比如判断一个数是奇数还是偶数 (`number % 2`)。

#### **5.2 最常用的操作：赋值运算符 (Assignment Operators)**

赋值运算符用于将一个值赋给一个变量。

*   **基本赋值 (`=`)**:
    ```cpp
    int score = 100; // 将 100 赋值给 score
    ```

*   **复合赋值运算符**:
    它们是“操作和赋值”的简写形式，让代码更简洁。

| 运算符 | 示例 | 等价于 |
| :--- | :--- | :--- |
| `+=` | `x += 5` | `x = x + 5` |
| `-=` | `x -= 5` | `x = x - 5` |
| `*=` | `x *= 5` | `x = x * 5` |
| `/=` | `x /= 5` | `x = x / 5` |
| `%=` | `x %= 3` | `x = x % 3` |

```cpp
int bullets = 10;
bullets -= 3; // bullets 现在是 7
```

#### **5.3 方便的加一减一：自增与自减运算符 (`++`, `--`)**

在编程中，“加一”和“减一”是非常频繁的操作。C++为此提供了专门的运算符。

*   **自增 (`++`)**：将变量的值加 1。
*   **自减 (`--`)**：将变量的值减 1。

它们都有两种形式：**前缀**和**后缀**，这两种形式在单独使用时效果相同，但在表达式中使用时有细微但重要的区别。

*   **前缀 (Prefix)**: `++i` 或 `--i`。**先**改变变量的值，**然后**使用这个新值参与表达式的计算。
*   **后缀 (Postfix)**: `i++` 或 `i--`。**先**使用变量的当前值参与表达式的计算，**然后**再改变变量的值。

```cpp
#include <iostream>

int main() {
    int x = 5;
    int y = 5;

    // 前缀：先自增，再赋值
    int result_x = ++x; // x 变成 6, 然后将 6 赋给 result_x
    std::cout << "x: " << x << ", result_x: " << result_x << std::endl; // 输出 x: 6, result_x: 6

    // 后缀：先赋值，再自增
    int result_y = y++; // 先将 5 赋给 result_y, 然后 y 变成 6
    std::cout << "y: " << y << ", result_y: " << result_y << std::endl; // 输出 y: 6, result_y: 5

    // 单独使用时，效果一样
    x++;
    ++y;
}
```

**新手建议**：为避免混淆，初期尽量将自增/自减操作单独写成一行 (`x++;`)，而不是在复杂的表达式中使用。

#### **5.4 判断真假：关系与比较运算符 (Relational and Comparison Operators)**

这些运算符用于比较两个值，它们的**结果永远是一个布尔值** (`true` 或 `false`)。

| 运算符 | 描述 | 示例 |
| :--- | :--- | :--- |
| `==` | 等于 | `a == b` |
| `!=` | 不等于 | `a != b` |
| `<` | 小于 | `a < b` |
| `>` | 大于 | `a > b` |
| `<=` | 小于或等于 | `a <= b` |
| `>=` | 大于或等于 | `a >= b` |

**新手最易犯的错误**：在需要判断“等于”时，误将 `==` 写成了 `=`。

*   `if (score = 100)`: 这是一个赋值操作，它将100赋给score，并且整个表达式的值是100（在if中被转换为true）。这几乎肯定是一个逻辑错误。
*   `if (score == 100)`: 这才是正确的比较操作，判断score的值是否等于100。

#### **5.5 组合判断：逻辑运算符 (Logical Operators)**

逻辑运算符用于组合多个布尔表达式，形成更复杂的判断条件。

| 运算符 | 名称 | 描述 |
| :--- | :--- | :--- |
| `&&` | 逻辑与 (AND) | 只有当**两边**的表达式都为 `true` 时，整个结果才为 `true`。 |
| `||` | 逻辑或 (OR) | 只要**任意一边**的表达式为 `true`，整个结果就为 `true`。 |
| `!` | 逻辑非 (NOT) | 将一个布尔值取反，`true` 变 `false`，`false` 变 `true`。 |

```cpp
int age = 25;
bool hasLicense = true;

// 检查是否既年满18岁又有驾照
if (age >= 18 && hasLicense) {
    std::cout << "可以开车" << std::endl;
}

bool isTired = false;
// 检查是否没有累
if (!isTired) {
    std::cout << "精力充沛！" << std::endl;
}
```

#### **5.6 运算的顺序：优先级与结合性**

当一个表达式中包含多个运算符时，谁先计算，谁后计算？这就由**优先级 (Precedence)** 和**结合性 (Associativity)** 决定。

*   **优先级**：不同运算符之间的计算顺序。就像数学中先算乘除后算加减一样。例如，`2 + 3 * 4` 的结果是 `14` 而不是 `20`，因为 `*` 的优先级高于 `+`。

*   **结合性**：当多个具有**相同优先级**的运算符在一起时，它们的计算顺序。
    *   **从左到右**：大部分运算符都是如此，如 `a - b + c` 等价于 `(a - b) + c`。
    *   **从右到左**：主要是赋值运算符，如 `a = b = c` 等价于 `a = (b = c)`。

**最重要的规则**：你**不需要**去死记硬背整个优先级表！当你不确定运算顺序时，或者想让代码的意图更清晰时，**请毫不犹豫地使用圆括号 `()`** 来强制指定运算顺序。

```cpp
// 意图不明的代码
int result = a + b * c / d - e;

// 清晰的代码
int result = a + ((b * c) / d) - e;
```

#### **5.7 其他运算符一览**

C++还有很多其他运算符，我们将在后续学习中遇到它们时再详细介绍：

*   **成员访问运算符** (`.` , `->`)：用于访问类或结构体的成员。
*   **范围解析运算符** (`::`)：我们已经在 `std::cout` 中见过了，用于指定命名空间。
*   **条件运算符** (`? :`)：`if-else` 的紧凑形式。
*   **位运算符** (`&`, `|`, `^`, `~`, `<<`, `>>`)：用于对数据的二进制位进行底层操作。
*   **`sizeof` 运算符**：用于获取一个类型或变量占用的内存大小。
*   **类型转换运算符**：如 `static_cast`。

### **第六章：构建程序逻辑 —— 语句 (Statements)**

如果说变量和运算符是程序的“名词”和“动词”，那么**语句 (Statements)** 就是将它们组织起来的“句子”。程序默认是**顺序执行**的，就像阅读一本书，从第一行读到最后一行。但语句可以让我们打破这个顺序，实现更复杂的逻辑，就像书中的“如果……就翻到第X页”或“重复阅读本段3次”。

C++中的语句种类繁多，但它们的核心目标都是**控制程序的执行流程**。

#### **6.1 最常见的语句：表达式语句、空语句与声明语句**

你其实已经写了很多语句了！

*   **表达式语句 (Expression Statement)**：任何一个有效的表达式，只要在末尾加上一个分号 `;`，就构成了一个表达式语句。这是C++中最常见的语句类型。
    ```cpp
    x = 5;              // 赋值是一个表达式语句
    balance += 10.0;    // 复合赋值是一个表达式语句
    std::cout << "Hi";  // 函数调用是一个表达式语句
    x++;                // 自增操作是一个表达式语句
    ```

*   **空语句 (Null Statement)**：它只由一个分号 `;` 组成，表示“什么也不做”。虽然不常用，但在某些语法结构需要一个语句但我们又无事可做时，它就能派上用场。
    ```cpp
    ; // 一个合法的C++语句，它什么都不做
    ```

*   **声明语句 (Declaration Statement)**：我们上一章学习的变量声明和定义本身就是一种语句。它将一个新名称引入到程序中。
    ```cpp
    int score = 0;
    std::string playerName;
    const double PI = 3.14;
    ```

#### **6.2 组织代码：复合语句 (Compound Statements / Blocks)**

**复合语句**，也常被称为**代码块 (Block)**，是由一对花括号 `{}` 包围起来的零个或多个语句的集合。

```cpp
{
    // 这是一个代码块
    int local_var = 1;
    local_var++;
    std::cout << "Inside the block." << std::endl;
}
```

代码块有一个非常重要的特性：**在C++语法中，任何可以使用单个语句的地方，都可以使用一个代码块来代替。** 这意味着我们可以将一组逻辑上相关的操作“打包”在一起，让它们成为一个整体。这是后续学习 `if`, `for`, `while` 等控制语句的基础。

#### **6.3 做出选择：选择语句 (Selection Statements)**

选择语句让你的程序能够根据不同的条件执行不同的代码路径，就像走到了一个岔路口。

**1. `if` 语句**

`if` 语句用于执行一个测试。如果条件为 `true`，就执行紧随其后的语句或代码块。

```cpp
int score = 95;

if (score > 90)
{
    std::cout << "优秀！" << std::endl;
}
```

**2. `if-else` 语句**

`if-else` 提供了一个二选一的路径。如果条件为 `true`，执行 `if` 部分的代码；如果为 `false`，则执行 `else` 部分的代码。

```cpp
int temperature = 15;

if (temperature > 25)
{
    std::cout << "天气炎热，穿T恤吧。" << std::endl;
}
else
{
    std::cout << "天气凉爽，最好穿件外套。" << std::endl;
}
```

**3. `if-else if-else` 结构**

当有多个互斥的条件需要判断时，可以使用 `if-else if-else` 链。

```cpp
int score = 75;

if (score >= 90) {
    std::cout << "A" << std::endl;
} else if (score >= 80) {
    std::cout << "B" << std::endl;
} else if (score >= 70) {
    std::cout << "C" << std::endl;
} else if (score >= 60) {
    std::cout << "D" << std::endl;
} else {
    std::cout << "F" << std::endl;
}
```
程序会从上到下依次检查条件，一旦找到一个为 `true` 的，就执行对应的代码块，然后跳过整个 `if-else` 结构。

**4. `switch` 语句**

当你需要根据一个**整数或字符类型**变量的**多个不同的常量值**来执行不同操作时，`switch` 语句是比 `if-else if` 链更清晰的选择。

```cpp
#include <iostream>

int main() {
    int choice = 2;

    switch (choice)
    {
        case 1:
            std::cout << "你选择了选项 1。" << std::endl;
            break; // 非常重要！
        case 2:
            std::cout << "你选择了选项 2。" << std::endl;
            break; // 阻止“穿透”到下一个 case
        case 3:
            std::cout << "你选择了选项 3。" << std::endl;
            break;
        default: // 如果没有任何 case 匹配
            std::cout << "无效的选择。" << std::endl;
            break;
    }
    return 0;
}
```
**`switch` 的关键点：**
*   `case` 后面必须跟一个**常量值**。
*   **`break` 语句至关重要！** 如果省略了 `break`，程序在执行完匹配的 `case` 后，会继续执行**下面所有**的 `case`，直到遇到 `break` 或 `switch` 结束。这种行为称为“穿透 (fallthrough)”。
*   `default` 是可选的，用于处理所有 `case` 都不匹配的情况。

#### **6.4 重复执行：迭代语句 (Iteration Statements / Loops)**

迭代语句，也就是循环，让程序可以重复执行一段代码，直到满足某个终止条件。

**1. `while` 循环**

`while` 循环在每次迭代**之前**检查条件。只要条件为 `true`，就不断执行循环体内的代码块。

```cpp
int countdown = 5;

while (countdown > 0)
{
    std::cout << countdown << "..." << std::endl;
    countdown--; // 必须在循环体内改变条件，否则会造成无限循环！
}
std::cout << "发射！" << std::endl;
```

**2. `for` 循环**

`for` 循环是C++中最常用的循环结构，它将循环的三个关键部分（**初始化**、**条件判断**、**更新**）集中写在一起，结构更清晰，特别适合于已知循环次数的场景。

```cpp
// for (初始化; 条件; 更新)
for (int i = 1; i <= 5; i++)
{
    std::cout << "这是第 " << i << " 次循环。" << std::endl;
}
```
这个 `for` 循环的执行流程是：
1.  **初始化**: `int i = 1;` (只在循环开始前执行一次)
2.  **条件判断**: `i <= 5` (如果为 `true`，执行循环体)
3.  **执行循环体**: `std::cout << ...`
4.  **更新**: `i++`
5.  回到第2步，重复此过程，直到条件为 `false`。

**3. `do-while` 循环**

`do-while` 循环与 `while` 类似，但它在每次迭代**之后**检查条件。这意味着**循环体至少会被执行一次**。

```cpp
#include <iostream>

int main() {
    char input;
    do {
        std::cout << "\n菜单:\n";
        std::cout << "1. 开始游戏\n";
        std::cout << "2. 加载游戏\n";
        std::cout << "Q. 退出\n";
        std::cout << "请输入你的选择: ";
        std::cin >> input;

        // ... 处理输入 ...

    } while (input != 'Q' && input != 'q');

    std::cout << "感谢使用！" << std::endl;
    return 0;
}
```

#### **6.5 改变路径：跳转语句 (Jump Statements)**

跳转语句可以立即将程序的控制权转移到另一个地方。

*   **`return`**: 立即**终止当前函数的执行**，并将控制权交还给调用者。如果函数有返回类型，`return` 语句后面需要跟一个返回值。
    ```cpp
    int add(int a, int b) {
        return a + b; // 返回计算结果并结束函数
    }
    ```

*   **`break`**: 我们在 `switch` 中已经见过它。在循环中使用时，`break` 会立即**跳出并终止当前所在的循环**。
    ```cpp
    for (int i = 0; i < 100; i++) {
        if (i == 10) {
            std::cout << "找到目标，停止搜索！" << std::endl;
            break; // 结束 for 循环
        }
    }
    ```

*   **`continue`**: 用于循环中，它会**跳过当前这一次迭代的剩余部分**，直接开始下一次迭代。
    ```cpp
    for (int i = 1; i <= 10; i++) {
        if (i % 2 != 0) { // 如果 i 是奇数
            continue; // 跳过本次循环的 cout
        }
        std::cout << i << " 是一个偶数。" << std::endl;
    }
    ```

### **第七章：代码的组织者 —— 函数 (Functions)**

到目前为止，我们所有的代码都写在了 `main` 函数里。对于小程序来说这没问题，但随着程序变大，`main` 函数会变得越来越臃肿，难以阅读和维护。**函数 (Function)** 就是解决这个问题的核心工具。

你可以把函数想象成一个有特定功能的“小机器”或一道菜的“食谱”。你给它一些“原料”（**参数**），它会按照内部的“步骤”（**函数体**）进行处理，最后可能会给你一个“成品”（**返回值**）。

**使用函数的好处：**
*   **重用性 (Reusability)**：一次编写，多次调用。
*   **模块化 (Modularity)**：将复杂问题分解成一个个简单的小任务，让代码结构更清晰。
*   **可维护性 (Maintainability)**：修改一个功能时，只需要在对应的函数内部修改，而不用在整个程序里到处寻找。

#### **7.1 函数的构成**

一个函数主要由**声明 (Declaration)**和**定义 (Definition)**两部分组成。

*   **函数声明 (Function Declaration)**，也叫**函数原型 (Function Prototype)**：
    它向编译器介绍函数的基本信息：返回什么类型的值、叫什么名字、需要哪些参数。声明以分号结尾。
    ```cpp
    // 声明一个名为 sum 的函数
    int sum(int a, int b);
    ```

*   **函数定义 (Function Definition)**：
    它提供了函数的具体实现，即函数体 `{}` 中的代码。一个函数只能被定义一次。
    ```cpp
    // 定义 sum 函数
    int sum(int a, int b)  // 函数头 (Header)
    {                      // 函数体 (Body) 开始
        return a + b;      // 函数体内容
    }                      // 函数体 (Body) 结束
    ```

让我们来解剖一下这个 `sum` 函数：

1.  **返回类型 (Return Type)** - `int`：
    这个函数在执行完毕后，会返回一个 `int` 类型的值。如果函数不返回任何值，返回类型应为 `void`。

2.  **函数名 (Function Name)** - `sum`：
    我们用来调用这个函数的名字。命名规则与变量相同。

3.  **参数列表 (Parameter List)** - `(int a, int b)`：
    函数需要的“输入原料”。这里需要两个 `int` 类型的参数，它们在函数内部的名字分别是 `a` 和 `b`。如果函数不需要参数，括号里可以是空的 `()` 或 `(void)`。

4.  **函数体 (Function Body)** - `{ return a + b; }`：
    函数的具体执行步骤，被花括号 `{}` 包围。`return` 语句用于结束函数并返回一个值。

#### **7.2 声明、定义与调用**

在C++中，一个函数在使用（调用）它之前，必须至少被**声明**过。编译器需要通过声明来检查你的调用是否正确（函数名、参数数量和类型是否匹配）。

```cpp
#include <iostream>

// 1. 函数声明 (原型)
// 告诉 main 函数，后面会有一个叫 greet 的函数
void greet(std::string name);

int main()
{
    // 2. 函数调用
    greet("Alice"); // 调用 greet 函数，并传入 "Alice" 作为参数
    return 0;
}

// 3. 函数定义 (实现)
void greet(std::string name)
{
    std::cout << "Hello, " << name << "!" << std::endl;
}
```
**当然，你也可以在使用之前直接定义函数，这样就不需要单独的声明了：**
```cpp
#include <iostream>

// 直接定义函数
void greet(std::string name)
{
    std::cout << "Hello, " << name << "!" << std::endl;
}

int main()
{
    greet("Bob");
    return 0;
}
```

#### **7.3 传递数据：参数与实参**

*   **形参 (Parameter)**：在**函数定义**时写的变量，如 `int a`，它们是函数内部的局部变量。
*   **实参 (Argument)**：在**函数调用**时传递的真实值，如 `sum(10, 5)` 中的 `10` 和 `5`。

C++中主要的参数传递方式有两种：

**1. 按值传递 (Pass-by-Value)**
这是**默认**的传递方式。函数得到的是实参的一个**副本 (copy)**。在函数内部对形参的任何修改，都**不会影响**到函数外部的原始实参。

```cpp
void tryToChange(int x)
{
    x = 100; // 修改的是 x 的副本
}

int main()
{
    int myValue = 5;
    tryToChange(myValue);
    std::cout << myValue << std::endl; // 输出仍然是 5
    return 0;
}
```

**2. 按引用传递 (Pass-by-Reference)**
通过在参数类型后加上 `&` 符号，可以实现按引用传递。此时，函数得到的是原始实参的**别名**，而不是副本。在函数内部对形参的修改，将**直接影响**到原始实参。

```cpp
void reallyChange(int& x) // 注意这里的 &
{
    x = 100; // 直接修改原始变量
}

int main()
{
    int myValue = 5;
    reallyChange(myValue);
    std::cout << myValue << std::endl; // 输出变成了 100
    return 0;
}
```

**何时使用按引用传递？**
1.  当你**需要**在函数内修改原始变量时。
2.  当你传递的参数是大型对象（如一个很长的字符串或一个复杂的类对象）时。按引用传递可以避免昂贵的复制操作，提高程序效率。

**安全的引用传递：`const` 引用**
如果你只是为了避免复制大型对象，但又**不希望**函数修改它，可以使用 `const` 引用。

```cpp
// 既高效又安全，函数只能读取，不能修改
void printLargeString(const std::string& str)
{
    // str = "new value"; // 错误！不能修改 const 引用
    std::cout << str << std::endl;
}
```

#### **7.4 返回数据：`return` 语句**

`return` 语句有两个作用：
1.  立即终止当前函数的执行。
2.  向函数调用者返回一个值。

```cpp
int add(int a, int b)
{
    return a + b; // 返回 a 和 b 的和
}

void checkAge(int age)
{
    if (age < 18) {
        std::cout << "未成年" << std::endl;
        return; // 条件满足，直接结束函数，后面的代码不执行
    }
    std::cout << "已成年" << std::endl;
}
```
**返回值优化 (RVO)**：当函数返回一个在函数内部创建的局部变量时，现代C++编译器非常智能，通常能优化掉不必要的复制过程，所以不必担心性能问题。

#### **7.5 函数重载 (Function Overloading)**

C++允许你定义多个**同名**的函数，只要它们的**参数列表不同**（参数的数量或类型不同）。这称为**函数重载**。编译器会根据你调用时提供的实参类型，自动选择匹配的函数版本。

```cpp
#include <iostream>
#include <string>

// 重载的 print 函数
void print(int value) {
    std::cout << "Integer: " << value << std::endl;
}

void print(double value) {
    std::cout << "Double: " << value << std::endl;
}

void print(const std::string& value) {
    std::cout << "String: " << value << std::endl;
}

int main()
{
    print(10);        // 调用 print(int)
    print(3.14);      // 调用 print(double)
    print("Hello");   // 调用 print(const std::string&)
    return 0;
}
```
函数重载是一个非常方便的特性，它让我们可以为逻辑上相似但处理数据类型不同的操作使用同一个函数名。

### **第八章：创建你自己的类型 —— 类与结构 (Classes and Structs)**

到目前为止，我们使用的所有类型，如 `int`, `double`, `std::string`，都是C++语言或其标准库为我们预先定义好的。它们很棒，但只能表示单一的数据。如果我们想表示一个更复杂的概念，比如一个游戏中的“玩家”，该怎么办？

一个玩家可能拥有名字（字符串）、生命值（整数）、分数（整数）、位置坐标（浮点数）等等。我们当然可以定义一堆零散的变量来表示：

```cpp
std::string player1_name = "Aragon";
int player1_health = 100;
int player1_score = 0;

std::string player2_name = "Legolas";
int player2_health = 80;
int player2_score = 50;
```
这样做非常混乱！如果游戏里有100个玩家呢？管理这些变量将是一场噩梦。我们需要一种方法，将所有与“玩家”相关的数据**打包**成一个独立的、完整的单元。这就是**类 (Class)** 和**结构体 (Struct)** 发挥作用的地方。

#### **8.1 数据“打包盒”：`struct` 结构体**

我们先从更简单的 `struct` 开始。你可以把它想象成一个自定义的“数据打包盒”或一张信息登记表。

`struct` 允许我们将多个不同类型的变量组合在一起，形成一个新的、自定义的类型。

```cpp
#include <iostream>
#include <string>

// 1. 定义一个名为 Player 的新类型
struct Player
{
    // 这些是 Player 类型的 "数据成员 (Data Members)"
    std::string name;
    int health;
    int score;
}; // 注意：结构体定义末尾必须有分号 ;

int main()
{
    // 2. 使用我们新定义的类型来创建变量
    // player1 就是一个 Player 类型的 "对象 (Object)" 或 "实例 (Instance)"
    Player player1;

    // 3. 使用点(.)运算符来访问对象的成员
    player1.name = "Hero";
    player1.health = 100;
    player1.score = 0;

    // 也可以在创建时直接初始化
    Player player2 = {"Villain", 120, 50};

    // 打印玩家信息
    std::cout << "Player 1 Name: " << player1.name << std::endl;
    std::cout << "Player 2 Health: " << player2.health << std::endl;

    return 0;
}
```
通过 `struct Player`，我们成功地创建了一个全新的类型！现在，`Player` 就像 `int` 一样，可以用来创建变量。我们把通过一个类型创建出来的具体变量称为该类型的**对象 (Object)** 或**实例 (Instance)**。`player1` 和 `player2` 就是 `Player` 类型的两个独立对象。

#### **8.2 更强大的“智能盒子”：`class` 类**

`class` 是C++中实现面向对象编程的核心。它不仅能像 `struct` 一样打包数据，更重要的是，它还能将**操作这些数据的函数**也一并打包进去。

**`class` 与 `struct` 的唯一区别**

在C++中，`class` 和 `struct` 在功能上几乎完全相同，唯一的区别在于**默认的成员访问权限**：
*   `struct` 的成员默认是 **`public` (公开的)**，意味着在外部可以直接访问。
*   `class` 的成员默认是 **`private` (私有的)**，意味着在外部**不能**直接访问。

这个看似微小的区别，背后是面向对象编程的一个核心思想：**封装 (Encapsulation)**。

**封装：保护你的数据**

封装就像是把数据锁在一个保险箱里，然后提供一套公开、安全的按钮（函数）来操作这些数据。这样做的好处是：
*   **数据安全**：防止外部代码随意、错误地修改内部数据。例如，我们不希望玩家的生命值被直接设置为负数。
*   **接口清晰**：外部代码只需要知道按哪个“按钮”，而不需要关心内部的复杂实现。

让我们用 `class` 来重写 `Player`，并加入“行为”：

```cpp
#include <iostream>
#include <string>

class Player
{
// 访问说明符 (Access Specifier)
public: // 公开部分：外部可以访问的“按钮”
    
    // 构造函数：一个特殊的成员函数，在创建对象时自动调用，用于初始化
    Player(std::string n, int h)
    {
        name = n;
        health = h;
        score = 0; // 初始分数为0
        std::cout << name << " 已创建!" << std::endl;
    }

    // 成员函数 (Member Function): 定义对象的行为
    void takeDamage(int amount)
    {
        if (amount > 0) {
            health -= amount;
            if (health < 0) {
                health = 0;
            }
        }
    }

    void displayStatus()
    {
        std::cout << "Name: " << name 
                  << ", Health: " << health 
                  << ", Score: " << score << std::endl;
    }

private: // 私有部分：被保护的内部数据
    std::string name;
    int health;
    int score;
};

int main()
{
    // 创建对象时，会自动调用构造函数
    Player hero("Hero", 100);
    Player villain("Villain", 120);

    // hero.health = 9999; // 错误！health 是 private 的，不能在外部直接访问

    // 必须通过公开的成员函数来与对象交互
    villain.takeDamage(25);

    hero.displayStatus();
    villain.displayStatus();

    return 0;
}
```
在这个例子中：
*   数据成员 `name`, `health`, `score` 被放在 `private:` 区域，它们被保护起来了。
*   我们提供了一系列 `public:` 的**成员函数 (Member Functions)**，如 `takeDamage` 和 `displayStatus`，作为与外界交互的唯一接口。
*   我们还定义了一个特殊的**构造函数 (Constructor)** `Player(...)`，它确保了每个 `Player` 对象在被创建时都能被正确地初始化。

#### **8.3 `struct` vs `class`：如何选择？**

既然它们功能相似，我们该如何选择呢？遵循一个普遍的编程约定：

*   当你只是想把一些数据打包在一起，并且这些数据不需要复杂的规则来保护时，使用 **`struct`**。它通常用于表示**纯数据**的集合，比如一个点的坐标 `struct Point { double x; double y; };`。

*   当你创建一个更复杂的“对象”，它既有数据又有行为，并且你需要通过封装来保护其内部状态时，使用 **`class`**。这是实现**面向对象设计**的标准方式。

### **第八章：创建你自己的类型 —— 类与结构 (续)**

在上半部分，我们学习了 `class` 和 `struct` 的基本概念，知道了它们是用来封装数据和行为的“蓝图”。现在，让我们打开这个“蓝图”的盒子，看看里面到底都能放些什么东西。

#### **8.4 类的构成：成员详解**

一个类或结构体由其**成员 (Members)** 组成。这些成员定义了类的**状态 (State)** 和**行为 (Behavior)**。

类的成员主要可以分为以下几类：

1.  **数据成员 (Data Members)**：
    就是我们在类中定义的变量，用于存储对象的状态。例如，`Player` 类中的 `name`, `health`, `score`。它们可以是内置类型，也可以是其他用户定义的类型。

2.  **成员函数 (Member Functions)**：
    在类中定义的函数，用于描述对象的行为或操作其数据成员。例如，`Player` 类中的 `takeDamage`, `displayStatus`。

3.  **嵌套类型 (Nested Types)**：
    可以在一个类内部定义另一个类、结构体或枚举。例如，`TestRun::State`。

4.  **以及更多**：
    类还可以包含别名(`using`/`typedef`)、联合(`union`)、位域(`bit field`)等更高级的成员，我们将在后续学习中接触。

让我们来看一个更完整的类声明示例，并逐一分析它的组成部分：

```cpp
// TestRun.h (头文件)

#include <string>

class TestRun
{
// --- 成员列表开始 ---

// 公开接口 (Public Interface): 任何外部代码都可以访问
public:
    // 1. 特殊成员函数 (Special Member Functions)
    TestRun(std::string name); // 构造函数
    virtual ~TestRun();        // 析构函数

    // 2. 普通成员函数 (Regular Member Functions)
    void DoSomething();
    int Calculate(int a, double d);
    
    // 3. 嵌套类型 (Nested Types)
    enum class State { Active, Suspended };

// 受保护部分 (Protected Section): 只能被这个类和它的子类访问
protected:
    // ...

// 私有部分 (Private Section): 只能被这个类自己访问
private:
    // 4. 数据成员 (Data Members) 与成员初始化
    State _state{ State::Suspended }; // C++11 起，可以在声明时直接初始化
    std::string _testName{ "" };
    int _index{ 0 };

    // 5. 静态数据成员 (Static Data Member)
    static int _instances;

// --- 成员列表结束 ---
};
```

#### **8.5 对象的“出生”与“消亡”：构造函数与析构函数**

在众多成员函数中，有几个是编译器会特别对待的，它们被称为**特殊成员函数**。其中最重要、最基础的两个是**构造函数**和**析构函数**。

**1. 构造函数 (Constructor)**

*   **作用**：在创建对象时**自动被调用**，用于**初始化**对象的数据成员，确保对象一“出生”就处于一个有效的、可预期的状态。
*   **特点**：
    *   函数名**与类名完全相同**。
    *   **没有返回类型**（连 `void` 都不写）。
    *   可以被**重载**（即可以有多个不同参数列表的构造函数）。

```cpp
class Player
{
public:
    // 构造函数
    Player(std::string n, int h)
    {
        name = n;
        health = h;
        score = 0; // 总是从0分开始
    }

private:
    std::string name;
    int health;
    int score;
};

int main()
{
    // 当这行代码执行时，Player的构造函数会被自动调用
    // "Hero" 对应参数 n, 100 对应参数 h
    Player hero("Hero", 100); 
}
```

*   **默认构造函数 (Default Constructor)**：
    一个**不带任何参数**的构造函数被称为默认构造函数。如果你**没有定义任何构造函数**，编译器会自动为你生成一个看不见的、空的默认构造函数。但只要你定义了**任何一个**构造函数，编译器就**不再**自动生成默认构造函数了。

    ```cpp
    // Player p1; // 错误！因为我们已经定义了带参数的构造函数，
                 // 所以编译器不再提供默认的 Player() 构造函数。
    ```
    如果你既需要自定义的构造函数，又需要一个无参数的构造函数，可以显式地声明它：
    `Player() { /* ... 初始化代码 ... */ }`

**2. 析构函数 (Destructor)**

*   **作用**：在对象**被销毁时**（例如，函数结束时局部对象超出作用域）**自动被调用**，用于执行清理工作，如释放动态分配的内存、关闭文件等。
*   **特点**：
    *   函数名是**波浪号 `~` 加上类名**。
    *   **没有返回类型**，也**没有任何参数**。
    *   一个类**最多只能有一个**析构函数。

```cpp
#include <iostream>
#include <string>

class Player
{
public:
    Player(std::string n) : name(n) { // 使用成员初始化列表，更高效
        std::cout << name << " created." << std::endl;
    }

    // 析构函数
    ~Player() {
        std::cout << name << " destroyed." << std::endl;
    }
private:
    std::string name;
};

int main()
{
    std::cout << "Entering main function." << std::endl;
    {
        Player local_player("In-Scope"); // 对象在代码块内创建
        std::cout << "Inside scope." << std::endl;
    } // 当代码块结束时，local_player 超出作用域，其析构函数被调用
    std::cout << "Exited scope." << std::endl;
    
    return 0;
}
```
运行上述代码，你会看到如下输出，清晰地展示了构造和析构的顺序：```
Entering main function.
In-Scope created.
Inside scope.
In-Scope destroyed.
Exited scope.
```

#### **8.6 现代C++的推荐：成员初始化**

在C++11及以后的版本中，我们可以在声明数据成员时直接为其提供一个默认的初始值。这是一种非常好的做法，可以防止忘记在构造函数中初始化某个成员。

```cpp
class Player
{
private:
    // 直接在声明时进行成员初始化
    std::string name{ "DefaultPlayer" };
    int health{ 100 };
    int score{ 0 };
};
```
如果在构造函数中为某个成员提供了不同的初始值，那么构造函数中的值会**覆盖**声明时的默认值。

#### **8.7 共享的数据：静态成员 (Static Members)**

通常情况下，每个对象都有自己的一份独立的数据成员。`player1` 的 `health` 和 `player2` 的 `health` 是存储在不同内存位置的两个变量。

但有时，我们希望某个数据成员被**类的所有对象共享**。这时就可以使用 `static` 关键字。

*   **静态数据成员 (Static Data Member)**：
    *   它不属于任何单个对象，而是属于整个类。
    *   所有对象访问的都是**同一个**静态成员的副本。
    *   它必须在**类的外部**进行定义和初始化。

```cpp
#include <iostream>

class Player
{
public:
    // 静态成员函数
    static int getPlayerCount() {
        return playerCount;
    }

    Player() {
        playerCount++; // 每创建一个新对象，计数器加一
    }

private:
    // 静态数据成员声明
    static int playerCount; 
};

// 静态数据成员的定义和初始化 (必须在类外部)
int Player::playerCount = 0;

int main()
{
    std::cout << "Initial players: " << Player::getPlayerCount() << std::endl; // 输出 0

    Player p1;
    Player p2;

    // 可以通过类名直接访问静态成员
    std::cout << "Current players: " << Player::getPlayerCount() << std::endl; // 输出 2
    // 也可以通过对象访问，但访问的是同一个共享变量
    std::cout << "Current players (via p1): " << p1.getPlayerCount() << std::endl; // 输出 2
    
    return 0;
}
```
*   **静态成员函数 (Static Member Function)**：
    *   同样使用 `static` 关键字声明。
    *   它也属于整个类，不与任何特定对象关联。
    *   因此，它**不能访问非静态的成员**（因为非静态成员必须依赖于具体对象存在），但可以访问静态成员。
    *   可以直接通过类名调用 (`ClassName::staticFunctionName()`)。

### **第九章：让类型更好用 —— 运算符重载 (Operator Overloading)**

我们已经知道如何创建一个 `Complex` (复数) 类来表示 `a + bi` 这样的数学概念。现在，如果我们想计算两个复数的和，我们可能会这样做：

```cpp
class Complex {
public:
    // ... 构造函数等 ...
    Complex add(const Complex& other) {
        return Complex(re + other.re, im + other.im);
    }
    // ...
private:
    double re, im; // 实部和虚部
};

// --- 在 main 函数中 ---
Complex a(1.2, 3.4);
Complex b(5.6, 7.8);
Complex c = a.add(b); // 调用一个名为 add 的成员函数
```

这完全可行，但总感觉有点“笨拙”。在数学中，我们很自然地会写 `c = a + b`。**运算符重载**就允许我们重新定义 `+` 运算符，让它能够直接用于我们自己创建的 `Complex` 对象，从而实现这种更自然、更符合直觉的语法。

#### **9.1 什么是运算符重载？**

运算符重载，本质上就是编写一个特殊的**函数**，这个函数的**名字**是 `operator` 关键字后跟你想重载的运算符符号。

例如，重载 `+` 运算符的函数名就是 `operator+`。

当编译器看到一个表达式，比如 `a + b`，并且发现 `a` 或 `b` 是我们自定义的类类型时，它就会去查找我们是否为这个类定义了 `operator+` 函数。如果找到了，编译器就会把 `a + b` 这个表达式**自动转换**为对 `operator+` 函数的调用。

#### **9.2 如何实现运算符重载**

重载运算符的函数可以作为**类的成员函数**，也可以作为**全局函数**（通常是类的友元函数）。我们先从成员函数开始。

**作为成员函数重载**

让我们来重载 `Complex` 类的 `+` 运算符。

```cpp
#include <iostream>

class Complex {
public:
    Complex(double r, double i) : re(r), im(i) {}

    // 重载 + 运算符作为成员函数
    // a + b;  'a' 是调用该函数的对象, 'b' 是传入的参数 'other'
    Complex operator+(const Complex& other) {
        // 返回一个新的 Complex 对象，其值为两者之和
        return Complex(re + other.re, im + other.im);
    }

    void display() {
        std::cout << re << " + " << im << "i" << std::endl;
    }

private:
    double re, im;
};

int main() {
    Complex a(1.2, 3.4);
    Complex b(5.6, 7.8);
    Complex c(0.0, 0.0);

    // 这里看起来是简单的加法...
    c = a + b; 
    // ...但编译器在后台把它翻译成了: c = a.operator+(b);

    std::cout << "a = "; a.display();
    std::cout << "b = "; b.display();
    std::cout << "c = a + b = "; c.display(); // 输出: 6.8 + 11.2i

    return 0;
}
```
**分析 `Complex Complex::operator+(const Complex& other)`:**
*   **返回类型 `Complex`**：两个复数相加的结果仍然是一个复数，所以我们返回一个新的 `Complex` 对象。
*   **函数名 `operator+`**：明确告诉编译器我们正在定义 `+` 的行为。
*   **参数 `const Complex& other`**：
    *   当运算符作为**二元**（有两个操作数）成员函数时，它只接受**一个**参数，代表运算符**右边**的操作数。
    *   运算符**左边**的操作数，就是调用这个函数的对象本身（可以通过 `this` 指针访问，`re` 实际上就是 `this->re`）。
    *   我们使用 `const` 引用来接收参数，既高效又安全，表示我们不会修改右操作数 `other`。

#### **9.3 重载规则与限制**

运算符重载非常强大，但也有一些规则需要遵守：

1.  **不能创建新运算符**：你不能发明一个 `@` 或者 `**` 运算符。只能重载C++中已有的运算符。
2.  **不能改变内置类型的行为**：你不能重载 `int` 类型的 `+` 运算符，让 `1 + 1` 等于 `3`。重载只对自定义类型（类或枚举）有效。
3.  **不能改变运算符的本质属性**：
    *   **优先级**：重载 `+` 和 `*` 后，`*` 的优先级仍然高于 `+`。
    *   **结合性**：`a + b + c` 仍然被解释为 `(a + b) + c`。
    *   **操作数数量**：不能把二元运算符 `+` 重载成只接受一个操作数。
4.  **一些运算符不能被重载**：
    *   成员访问: `.`
    *   范围解析: `::`
    *   条件运算符: `?:`
    *   `sizeof`

**最佳实践**：
重载运算符时，应尽量**遵循其原始的数学或逻辑含义**。例如，`+` 应该表示某种形式的“相加”或“合并”，`==` 应该表示“相等”的判断。如果你的重载行为与常识相去甚远，会让代码变得极其混乱和难以理解。

#### **9.4 一个更常见的例子：重载 `<<` 用于输出**

`std::cout` 是一个 `ostream` 类的对象。我们之所以能写 `std::cout << "Hello";` 是因为 `ostream` 类已经为字符串、整数等内置类型重载了 `<<` 运算符。现在，我们希望也能直接输出我们自己的 `Complex` 对象：

`std::cout << a;`  // 我们希望这能行！

`<<` 是一个二元运算符。如果我们想把它写成 `a.operator<<(std::cout)`，会感觉很奇怪。自然的顺序是 `cout` 在左边。因此，这类运算符通常被重载为**全局函数**（通常是友元 `friend` 函数，以便访问私有成员）。

```cpp
#include <iostream>

class Complex {
public:
    Complex(double r, double i) : re(r), im(i) {}

    // 将全局的 operator<< 声明为本类的友元
    // 这样它就可以访问 private 成员 re 和 im
    friend std::ostream& operator<<(std::ostream& os, const Complex& c);

private:
    double re, im;
};

// 重载 << 作为全局函数
// 第一个参数 ostream& os: 代表 cout 对象
// 第二个参数 const Complex& c: 代表要输出的 Complex 对象
// 返回 ostream& 是为了支持链式调用，如 cout << a << b;
std::ostream& operator<<(std::ostream& os, const Complex& c)
{
    os << c.re << " + " << c.im << "i";
    return os;
}

int main() {
    Complex a(1.2, 3.4);
    Complex b(5.6, 7.8);
    
    // 现在可以直接输出了！
    std::cout << "a = " << a << std::endl; // 编译器翻译成 operator<<(std::cout, a);
    std::cout << "b = " << b << std::endl;

    return 0;
}
```
通过重载 `<<`，我们的 `Complex` 类变得更加完整和易用了。

### **第十章：数据的集合 —— C风格数组 (C-Style Arrays)**

到目前为止，我们创建的变量一次只能存储一个值。但如果我们需要存储一个班级所有学生的50个考试成绩，或者一个月的每日最高气温呢？为每个数据点都创建一个独立的变量显然是不现实的。这时，我们就需要一种能够存储一系列相同类型数据的结构——**数组 (Array)**。

**重要提示：关于现代C++**

本章我们学习的是从C语言继承而来的**C风格数组**。它是C++语言的基础部分，理解它对于理解内存和指针至关重要。

然而，C风格数组存在一些固有的缺陷（如大小固定、无边界检查），容易导致bug。因此，在**现代C++编程**中，我们**强烈推荐**使用标准库提供的更安全、更强大的容器，如 **`std::vector`** (用于动态大小的数组) 和 **`std::array`** (用于固定大小的数组)。

你可以将本章内容视为学习这些现代容器前的必要基础。

#### **10.1 什么是数组？**

数组是一个由**相同类型**的元素组成的**序列**，这些元素在内存中占据一块**连续的空间**。

你可以把它想象成一排连号的储物柜，每个柜子里存放的东西类型都一样（比如都放整数），并且你可以通过柜子的编号（**索引**）来快速找到任何一个柜子。

#### **10.2 声明和初始化数组**

在C++中，声明一个数组需要指定三样东西：元素的**类型**、数组的**名称**和数组的**大小**（元素数量）。

```cpp
// 语法: element_type array_name[array_size];

// 声明一个可以存放 5 个整数的数组
int scores[5]; ```
**关键点：**
*   数组的大小必须是一个在**编译时**就能确定的**常量表达式**。
*   数组的**索引 (index)** 从 **0** 开始。对于一个大小为 5 的数组，有效的索引是 0, 1, 2, 3, 4。最后一个元素的索引永远是 `size - 1`。

**初始化数组**

在定义数组时，最好立即对其进行初始化。最常用的方法是使用**初始化列表 (`{}`)**。

```cpp
// 1. 完全初始化
int scores[5] = {95, 88, 76, 100, 92};
// 或者使用更现代的列表初始化
int scores[5]{95, 88, 76, 100, 92};

// 2. 部分初始化
// 只提供了前3个元素的值，其余元素会被自动初始化为 0
int results[10] = {1, 1, 2}; // results 将是 {1, 1, 2, 0, 0, 0, 0, 0, 0, 0}

// 3. 全部初始化为0
int all_zeros[100] = {0}; // 一个方便的技巧，将所有元素初始化为0

// 4. 根据初始值推断大小
// 编译器会自动计算出数组大小为 4
int data[] = {10, 20, 30, 40};
```

#### **10.3 访问数组元素**

我们使用**下标运算符 (`[]`)** 和索引来访问或修改数组中的特定元素。

```cpp
#include <iostream>

int main() {
    int scores[5]{95, 88, 76, 100, 92};

    // 访问第 0 个元素 (第一个元素)
    std::cout << "First score: " << scores[0] << std::endl; // 输出 95

    // 修改第 2 个元素 (第三个元素)
    scores[2] = 80;

    // 使用 for 循环遍历并打印所有元素
    for (int i = 0; i < 5; ++i) {
        std::cout << "Score at index " << i << ": " << scores[i] << std::endl;
    }

    return 0;
}
```

**⚠️ 严重警告：数组越界！**

C++的C风格数组**不会**自动检查你的索引是否在有效范围内。如果你尝试访问一个不存在的索引，比如 `scores[5]` 或 `scores[-1]`，程序不会在编译时报错。这会导致**未定义行为 (Undefined Behavior)**，可能会读取到随机的内存数据，或者更糟——破坏其他变量的值，导致程序崩溃。这是C风格数组最危险的地方之一，也是新手最常犯的错误。

#### **10.4 数组与函数：指针衰变 (Pointer Decay)**

当你将一个数组作为参数传递给一个函数时，一个非常重要的事情发生了：数组会**“衰变” (decay)**成一个指向其**第一个元素**的**指针**。

这意味着在函数内部：
1.  **丢失了大小信息**：函数不知道原始数组有多大。
2.  **不再是数组**：你不能在函数内部使用 `sizeof` 来获取数组的总大小。

因此，当你向函数传递一个C风格数组时，**必须**额外传递一个参数来告诉函数数组的大小。

```cpp
#include <iostream>

// 正确的函数声明方式
// const double arr[]: 告诉阅读者这是一个数组，但本质上还是一个指针
// const size_t size: 必须传入数组的大小
void printArray(const double arr[], size_t size)
{
    std::cout << "Printing array elements: ";
    for (size_t i = 0; i < size; ++i) {
        std::cout << arr[i] << " ";
    }
    std::cout << std::endl;
}

int main() {
    double temperatures[] = {25.5, 28.3, 22.1};
    // 计算数组大小
    size_t count = sizeof(temperatures) / sizeof(double); // (8 * 3) / 8 = 3

    printArray(temperatures, count);
    return 0;
}
```
*   `const double arr[]` 和 `const double* arr` 在函数参数中是完全等价的。使用 `[]` 更能清晰地表达“我期望传入一个数组”的意图。
*   使用 `const` 是一个好习惯，它表明这个函数只会读取数组，而不会修改它。

#### **10.5 多维数组**

数组的元素本身也可以是数组，这就构成了**多维数组**。最常见的是二维数组，你可以把它想象成一个表格或矩阵。

```cpp
// 声明一个 2 行 3 列的二维数组
int matrix[2][3] = {
    {1, 2, 3}, // 第 0 行
    {4, 5, 6}  // 第 1 行
};

// 访问第 1 行，第 2 列的元素 (值为 6)
int element = matrix[1][2];

// 使用嵌套循环遍历二维数组
for (int row = 0; row < 2; ++row) {
    for (int col = 0; col < 3; ++col) {
        std::cout << matrix[row][col] << " ";
    }
    std::cout << std::endl;
}
```

### **第十一章：深入内存的强大工具 —— 指针 (Pointers)**

欢迎来到C++中最强大、最灵活，同时也最具挑战性的主题之一：**指针**。理解指针，意味着你开始真正理解计算机程序是如何与内存进行交互的。虽然现代C++提供了更安全的工具来替代指针的某些用法，但掌握指针的核心思想，对于成为一名优秀的C++程序员至关重要。

#### **11.1 什么是指针？**

回想一下，每个变量都被存储在内存中的某个位置，每个位置都有一个独一无二的**地址**，就像每个房子都有一个门牌号一样。

**指针 (Pointer)** 就是一种特殊的变量，它的值不是普通的数据（如 `10` 或 `"Hello"`），而是另一个变量的**内存地址**。

所以，指针就像一张写着别人家门牌号的纸条。通过这张纸条，你就能找到对应的房子。

#### **11.2 指针的核心操作**

操作指针主要涉及三个特殊运算符：

1.  **地址运算符 (`&`)**:
    把它放在一个变量前面，就能获取这个变量的内存地址。可以读作“address of”。

2.  **声明指针 (`*`)**:
    在声明变量时，在类型后面加上 `*`，表示你正在声明一个指针变量。
    ```cpp
    int* ptr; // 声明一个名为 ptr 的变量，它是一个“指向 int 类型的指针”
    ```

3.  **解引用运算符 (`*`)**:
    把它放在一个**已经初始化**的指针变量前面，就能获取或修改**指针所指向地址上的那个值**。可以读作“value pointed to by”。

让我们通过一个完整的例子来看看它们如何协同工作：

```cpp
#include <iostream>

int main() {
    int number = 42; // 一个普通的整数变量

    // 1. 声明一个整型指针
    int* pNumber;

    // 2. 使用 '&' 获取 number 的地址，并将其存入指针 pNumber
    pNumber = &number;

    // 打印信息
    std::cout << "Value of number: " << number << std::endl;             // 输出 42
    std::cout << "Address of number: " << &number << std::endl;           // 输出 number 的内存地址，如 0x7ffc...
    std::cout << "Value of pNumber (the address it holds): " << pNumber << std::endl; // 输出 pNumber 存储的地址，与上面相同
    
    // 3. 使用 '*' 解引用指针，访问它所指向的数据
    std::cout << "Value pointed to by pNumber: " << *pNumber << std::endl; // 输出 42

    // 通过指针修改原始变量的值
    *pNumber = 100;
    std::cout << "New value of number: " << number << std::endl;           // 输出 100

    return 0;
}
```
**`*` 的双重含义**：
初学者要特别注意，`*` 在C++中有两种含义，取决于上下文：
*   在**声明**时 (`int* p;`)，它表示这是一个指针类型。
*   在**表达式**中 (`*p = 10;`)，它是一个解引用运算符。

#### **11.3 空指针 `nullptr` 与未初始化指针的危险**

*   **空指针 (`nullptr`)**:
    一个指针如果不指向任何有效的内存地址，我们就称之为空指针。在现代C++中，我们使用 `nullptr` 关键字来表示它。在解引用一个指针之前，检查它是否为 `nullptr` 是一个非常好的习惯，可以避免程序崩溃。

    ```cpp
    int* ptr = nullptr;
    if (ptr != nullptr) {
        // 只有在 ptr 不为空时，才进行解引用
        *ptr = 5; 
    }
    ```

*   **未初始化指针 (野指针)**：
    这是**极其危险**的。一个只被声明但未被初始化的指针，它里面的地址是随机的。如果你试图解引用一个野指针，就像闯入一个随机门牌号的房子一样，可能会导致程序立即崩溃，或者更糟——悄无声息地破坏了程序中其他部分的数据。

    ```cpp
    int* wild_ptr; // 未初始化，指向一个随机地址
    // *wild_ptr = 10; // 绝对禁止！这将导致未定义行为！
    ```
    **规则：永远不要解引用一个未初始化的指针。要么用 `nullptr` 初始化它，要么让它指向一个有效的变量地址。**

#### **11.4 指针与数组的“亲密关系”**

我们在上一章学到，数组名在很多情况下会“衰变”成一个指向其首元素的指针。这揭示了指针与数组之间深刻的联系。

```cpp
int scores[5] = {10, 20, 30, 40, 50};

int* pScores = scores; // 数组名 scores 衰变成指向第一个元素的指针

// 下面两行代码是等价的
std::cout << scores[2] << std::endl;     // 使用数组下标访问第3个元素 (30)
std::cout << *(pScores + 2) << std::endl; // 使用指针算术访问第3个元素 (30)
```
**指针算术 (Pointer Arithmetic)**：
当你对一个指针进行加减运算时，它移动的单位不是字节，而是它所指向的**数据类型的大小**。
*   `pScores + 1` 会让指针向前移动 `sizeof(int)` 个字节，从而指向数组的下一个元素。

这种关系解释了为什么C风格数组传递给函数时会丢失大小信息——因为传递的仅仅是一个指向开头的指针。

#### **11.5 堆内存与 `new`/`delete`**

到目前为止，我们创建的变量大多位于**栈 (Stack)**上。栈内存由编译器自动管理，当变量超出作用域时会自动释放。但栈的空间是有限的。

如果我们想创建一个生命周期不受作用域限制的大对象，或者在程序运行时才确定大小的数组，就需要使用**堆 (Heap)**内存。堆是一块更大的、更自由的内存区域，但需要我们**手动管理**。

*   **`new` 运算符**: 用于在堆上分配内存，并返回一个指向该内存的指针。
*   **`delete` 运算符**: 用于释放由 `new` 分配的内存。
*   **`delete[]` 运算符**: 用于释放由 `new[]` 分配的**数组**内存。

```cpp
// 在堆上创建一个整数
int* pHeapInt = new int(42);

// 在堆上创建一个大小为 100 的数组
double* pHeapArray = new double[100];

// ... 使用这些指针 ...

// 必须手动释放内存，否则会造成内存泄漏！
delete pHeapInt;
delete[] pHeapArray;

// 释放后，将指针设为 nullptr 是一个好习惯，防止成为“悬垂指针”
pHeapInt = nullptr;
pHeapArray = nullptr;
```
**手动内存管理的陷阱**:
*   **忘记 `delete`**：导致**内存泄漏 (Memory Leak)**。程序占用的内存越来越多，最终可能耗尽系统资源。
*   **`delete` 两次**：导致未定义行为，通常会使程序崩溃。
*   **使用 `delete` 释放 `new[]` 的内存** (反之亦然)：导致未定义行为。

正是因为手动管理原始指针如此困难且容易出错，现代C++才大力推崇使用**智能指针**。

#### **11.6 现代C++的救星：智能指针 (Smart Pointers)**

智能指针是**行为像指针的类对象**。它们封装了一个原始指针，最关键的特性是利用了**RAII (Resource Acquisition Is Initialization)** 原则：**在对象的生命周期内管理资源**。

当一个智能指针对象被创建时，它获得资源的控制权；当它被销毁时（例如超出作用域），它的析构函数会自动释放资源（调用 `delete`）。

这让我们几乎可以完全避免手动调用 `delete`！

1.  **`std::unique_ptr` (唯一指针)**
    *   表示对所管理资源的**独占所有权**。
    *   **不能被复制**，只能被**移动 (move)**。这保证了在任何时候，只有一个 `unique_ptr` 指向同一个资源。
    *   是管理动态内存的**首选**智能指针。

    ```cpp
    #include <memory>
    
    void processWidget(std::unique_ptr<Widget> w) {
        // ... 使用 w ...
    } // 当函数结束时，w 会自动被销毁，并释放它所管理的 Widget 内存

    int main() {
        auto u_ptr = std::make_unique<Widget>(); // 推荐的创建方式
        processWidget(std::move(u_ptr)); // 将所有权“移动”给函数
        // 此时 u_ptr 已经是空的了
        return 0;
    }
    ```

2.  **`std::shared_ptr` (共享指针)**
    *   表示对资源的**共享所有权**。
    *   内部有一个**引用计数器**。每次有新的 `shared_ptr` 指向该资源时，计数器加一；每次有 `shared_ptr` 被销毁时，计数器减一。
    *   当引用计数器**变为 0** 时，资源被自动释放。
    *   当你需要多个指针共同管理同一个对象的生命周期时使用。

**新手建议：**
**尽可能使用 `std::unique_ptr`**。只有在你确实需要共享所有权时，才考虑使用 `std::shared_ptr`。**告别手动的 `new` 和 `delete`**，让智能指针来为你管理内存。

### **第十二章：处理程序中的意外 —— 异常处理 (Exception Handling)**

到目前为止，我们编写的代码都假设一切会顺利进行。但现实世界中，程序运行时可能会遇到各种预料之外的“意外”情况：用户输入了无效的数据、要读取的文件不存在、网络连接突然中断等等。这些情况被称为**错误 (Errors)** 或**异常 (Exceptions)**。

**异常处理 (Exception Handling)** 是一种机制，它允许我们以一种结构化的、可控的方式来应对这些运行时错误，从而避免程序突然崩溃。

#### **12.1 为什么需要异常处理？**

想象一下，你写了一个函数 `calculate()`，它内部又调用了 `processData()`，`processData()` 又调用了 `readFile()`。如果最深层的 `readFile()` 函数发现文件打不开，它该怎么办？

*   **传统C风格的方法**：`readFile()` 返回一个特殊的错误码（比如 `-1`）。然后 `processData()` 必须检查这个返回值，如果发现是错误码，就停止自己的工作，再返回一个错误码给 `calculate()`。`calculate()` 也必须做同样的事情。

这种错误码传递的方式会让代码变得非常臃肿，到处都是 `if (errorCode != SUCCESS)` 这样的检查，很容易遗漏，导致错误被忽略。

**异常处理的优势**：
*   **分离错误处理与正常逻辑**：处理错误的代码可以与正常的业务逻辑代码分离开来，使代码更清晰。
*   **强制处理**：一个未被处理的异常会自动终止程序，这比带着错误数据继续运行要安全得多。
*   **跨函数栈传递**：异常可以轻松地“跳过”中间函数，直接被上层能够处理它的代码捕获，无需每个函数都手动传递错误码。

#### **12.2 异常处理的三大关键字：`try`, `throw`, `catch`**

C++的异常处理机制围绕这三个核心关键字构建：

1.  **`try` (尝试)**：
    `try` 关键字后面跟着一个代码块 `{}`。你把**可能引发异常**的代码放在这个代码块里。

2.  **`throw` (抛出)**：
    当在 `try` 块中检测到一个错误时，使用 `throw` 关键字来“抛出”一个异常。你可以抛出任何类型的对象（如整数、字符串），但**强烈推荐**抛出一个派生自标准库 `std::exception` 类的对象。

3.  **`catch` (捕获)**：
    `catch` 关键字也跟着一个代码块 `{}`，紧跟在 `try` 块之后。这个代码块用于**处理**被抛出的异常。你可以有多个 `catch` 块来处理不同类型的异常。

让我们来看一个完整的例子：

```cpp
#include <iostream>
#include <string>
#include <stdexcept> // 标准异常类的头文件

// 一个可能抛出异常的函数
void processValue(int value)
{
    if (value < 0) {
        // 如果值是负数，这是一个无效参数，抛出异常
        throw std::invalid_argument("Value cannot be negative.");
    }
    if (value == 0) {
        // 假设0是一个运行时错误
        throw std::runtime_error("Value cannot be zero.");
    }
    
    std::cout << "Value processed successfully: " << 100 / value << std::endl;
}

int main()
{
    int inputValue = 0;

    std::cout << "Please enter a positive integer: ";
    std::cin >> inputValue;

    // --- 尝试执行可能出错的代码 ---
    try 
    {
        std::cout << "Trying to process value..." << std::endl;
        processValue(inputValue);
        std::cout << "Processing finished without errors." << std::endl;
    }
    // --- 捕获特定类型的异常 ---
    catch (const std::invalid_argument& e) // 按 const 引用捕获
    {
        std::cerr << "Caught an invalid argument error: " << e.what() << std::endl;
    }
    catch (const std::runtime_error& e) // 捕获另一种类型的异常
    {
        std::cerr << "Caught a runtime error: " << e.what() << std::endl;
    }
    // --- 捕获所有其他类型的异常 ---
    catch (...) // ... (三个点) 是一个万能捕获块
    {
        std::cerr << "Caught an unknown exception!" << std::endl;
    }

    std::cout << "Program continues after the try-catch block." << std::endl;

    return 0;
}
```
**执行流程分析**：
*   如果用户输入 `10`：`processValue(10)` 正常执行，`try` 块顺利完成，所有 `catch` 块被跳过。
*   如果用户输入 `-5`：`processValue(-5)` 执行到 `throw std::invalid_argument(...)`。程序立即中断当前执行流程，开始在调用栈中向上寻找匹配的 `catch` 块。它找到了 `catch (const std::invalid_argument& e)`，于是执行该 `catch` 块内的代码。
*   如果用户输入 `0`：`processValue(0)` 抛出 `std::runtime_error`，被第二个 `catch` 块捕获。
*   无论是否发生异常，只要异常被捕获，程序都会在 `try-catch` 结构结束后继续执行。

#### **12.3 异常处理的最佳实践**

1.  **为“异常”情况使用异常**：
    不要用异常来处理普通的、可预期的程序逻辑（比如用异常来跳出循环）。异常应该用于处理真正的、意外的错误。对于那些在编程时就应该避免的逻辑错误（如数组越界），应该使用**断言 (assertions)** 来在开发阶段就发现它们。

2.  **通过值抛出，通过 const 引用捕获 (Throw by value, catch by const reference)**：
    *   `throw std::runtime_error("Error!");` (通过值创建并抛出一个临时对象)
    *   `catch (const std::exception& e)` (通过 const 引用捕获，这避免了不必要的对象复制，并且可以捕获所有派生自 `std::exception` 的异常)

3.  **使用标准库异常**：
    `<stdexcept>` 头文件为我们提供了一系列标准的异常类，如：
    *   `std::invalid_argument`: 无效参数
    *   `std::out_of_range`: 索引越界
    *   `std::runtime_error`: 其他运行时错误
    优先使用它们。如果需要，可以创建自己的异常类，但应该让它继承自 `std::exception`。

4.  **异常安全 (Exception Safety) 与 RAII**：
    如果在 `throw` 异常和 `catch` 捕获之间，有资源（如动态分配的内存、打开的文件）被分配，会发生什么？
    
    C++有一个非常强大的机制叫**栈展开 (Stack Unwinding)**。当异常被抛出时，从 `try` 块开始到异常被抛出的地方，所有在栈上创建的**局部对象**都会被**自动、正确地销毁**（它们的析构函数会被调用）。

    这就是为什么**智能指针 (`std::unique_ptr`, `std::shared_ptr`)** 如此重要！如果你使用智能指针来管理内存，即使发生异常，智能指针对象在栈展开过程中也会被销毁，其析构函数会自动释放它所管理的内存，从而**杜绝了内存泄漏**。这个原则被称为 **RAII (Resource Acquisition Is Initialization)**，是编写异常安全代码的基石。

    ```cpp
    void might_throw() {
        auto ptr = std::make_unique<MyResource>(); // 使用智能指针管理资源
        // ...
        if (some_error_condition) {
            throw std::runtime_error("Oops!");
        }
        // ...
    } // 如果抛出异常，ptr 会在栈展开时被销毁，从而自动释放 MyResource
    ```

5.  **不要从析构函数中抛出异常**：
    这是一个严格的规则。如果在一个对象进行栈展开（因为另一个异常）的过程中，它的析构函数又抛出了一个新的异常，程序会立即调用 `std::terminate` 终止，因为C++无法同时处理两个未决的异常。

### **第十三章：构建类的层次结构 —— 继承 (Inheritance)**

想象一下在现实世界中，“狗”是一个宽泛的概念，而“贵宾犬”、“哈士奇”、“金毛寻回犬”都是“狗”的具体类型。它们都共享“狗”的基本特征（有四条腿、会叫），但各自又有独特的属性（贵宾犬不掉毛，哈士奇精力旺盛）。

在面向对象编程中，继承就是用来表达这种**“is-a” (是一种)** 关系的机制。我们可以先定义一个通用的“基类”（比如 `Dog`），然后再创建更具体的“派生类”（比如 `Poodle`, `Husky`），这些派生类会自动拥有基类的所有通用特性，并且可以添加自己独有的功能。

#### **13.1 核心概念：基类与派生类**

*   **基类 (Base Class)**：被其他类继承的类。它代表了更**通用**的概念（也常被称为父类或超类）。
*   **派生类 (Derived Class)**：从其他类继承而来的类。它代表了更**具体**的概念（也常被称为子类）。

**继承的好处：**
1.  **代码重用 (Code Reuse)**：基类中定义的代码（数据和函数）可以被所有派生类直接使用，无需重复编写。
2.  **建立层次关系 (Establishing Hierarchy)**：它清晰地表达了类型之间的逻辑关系，使得程序结构更符合现实世界的模型。这是实现多态（我们下一章的主题）的基础。

#### **13.2 如何实现继承**

在C++中，我们使用冒号 `:` 来表示继承关系。

**语法：**
`class DerivedClassName : access-specifier BaseClassName { ... };`

*   `access-specifier` (访问说明符)：通常是 `public`。它决定了基类的成员在派生类中的访问级别。

**对于初学者，请始终使用 `public` 继承。** `public` 继承意味着：“基类中的 `public` 成员在派生类中仍然是 `public` 的”。这最符合我们直观的“is-a”关系。

让我们通过一个游戏设计的例子来具体看看：

```cpp
#include <iostream>
#include <string>

// 1. 定义一个通用的“基类”：Enemy
class Enemy
{
public:
    int health;
    int attackPower;

    void attack() {
        std::cout << "Enemy attacks with power: " << attackPower << std::endl;
    }
};

// 2. 定义一个“派生类”：Goblin，它 "is-a" Enemy
// Goblin 公开继承自 Enemy
class Goblin : public Enemy
{
public:
    // Goblin 添加了自己独有的数据成员
    std::string clubType; 
};

int main()
{
    Goblin g;

    // 访问从 Enemy 继承来的成员
    g.health = 50;
    g.attackPower = 10;

    // 访问 Goblin 自己独有的成员
    g.clubType = "Spiked Club";

    std::cout << "Goblin's weapon: " << g.clubType << std::endl;

    // 调用从 Enemy 继承来的函数
    g.attack(); // 输出: Enemy attacks with power: 10

    return 0;
}
```
在这个例子中，`Goblin` 类虽然只定义了一个 `clubType` 成员，但它自动地、无偿地获得了 `Enemy` 类的 `health`、`attackPower` 数据成员和 `attack()` 成员函数。

#### **13.3 继承中的访问控制：`public`, `protected`, `private`**

继承如何与我们之前学过的访问说明符 `public` 和 `private` 相互作用呢？这里我们需要引入一个新的访问说明符：**`protected`**。

*   **`public`**: 成员可以被任何人访问（类内部、派生类、外部代码）。
*   **`protected`**: 成员可以被**类本身**以及**它的所有派生类**访问，但不能被外部代码直接访问。它就像是“传家宝”，只在家族内部流传。
*   **`private`**: 成员**只能**被**定义它的那个类**自己访问。**即使是派生类也无法直接访问基类的 `private` 成员。**

当一个类 `Derived` **公开继承 (`public`)** 自 `Base` 时，访问权限的变化如下：

| Base 类的成员 | 在 Derived 类中变成... |
| :--- | :--- |
| `public` | `public` |
| `protected` | `protected` |
| `private` | **不可访问 (Inaccessible)** |

让我们用一个更完善的例子来说明：

```cpp
class Parent {
public:
    int public_var;
protected:
    int protected_var;
private:
    int private_var;
};

class Child : public Parent {
public:
    void accessMembers() {
        public_var = 1;      // OK! public 成员在派生类中仍然是 public
        protected_var = 2;   // OK! protected 成员在派生类中是 protected
        // private_var = 3;  // 错误! 派生类不能访问基类的 private 成员
    }
};

int main() {
    Child c;
    c.public_var = 10;   // OK! 因为它在 Child 中是 public 的
    // c.protected_var = 20; // 错误! protected 成员不能被外部代码访问
    // c.private_var = 30; // 错误!
}
```

#### **13.4 构造函数与继承**

一个很重要的规则是：**构造函数和析构函数是不会被继承的。**

当创建一个派生类对象时，程序必须先创建它内部包含的那个“基类部分”。这意味着**基类的构造函数必须先被调用**。

那么，如果基类的构造函数需要参数，派生类该如何传递呢？答案是使用**构造函数的成员初始化列表**。

```cpp
#include <iostream>
#include <string>

class Enemy
{
public:
    // Enemy 的构造函数需要 health 和 power
    Enemy(int h, int p) : health(h), attackPower(p) {
        std::cout << "An Enemy was created." << std::endl;
    }
    // ...
protected:
    int health;
    int attackPower;
};

class Goblin : public Enemy
{
public:
    // Goblin 的构造函数
    // 它使用初始化列表来调用基类 Enemy 的构造函数
    Goblin(int h, int p, std::string ct) : Enemy(h, p), clubType(ct) {
        std::cout << "A Goblin was created." << std::endl;
    }
    // ...
private:
    std::string clubType;
};

int main()
{
    // 创建 Goblin 对象时...
    Goblin g(50, 10, "Spiked Club"); 
    // ...程序会先调用 Enemy(50, 10) 构造函数，然后再执行 Goblin 构造函数的函数体
    return 0;
}
```
**销毁顺序**：对象的销毁顺序与构造顺序**完全相反**。当 `g` 对象被销毁时，会先调用 `Goblin` 的析构函数，然后再调用 `Enemy` 的析构函数。

