# Python 入门

> [!NOTE]
> 由 <Icon icon="simple-icons:googlegemini" href="https://gemini.google.com/"/>Gemini 2.5 Pro 生成，请对内容进行甄别。

> [!NOTE] 推荐阅读
> [Python官方中文文档](https://docs.python.org/zh-cn/)

欢迎来到Python的世界！Python是一门非常适合初学者的编程语言，它的语法简洁优美，容易上手，同时功能强大，应用广泛。本教程将带你一步步走进Python的奇妙世界。

## 第一节：课前甜点

在正式开始学习之前，我们先来感受一下Python的魅力。想象一下，你想要计算从1到100所有整数的和，如果用手算，会非常繁琐。但在Python中，只需要几行代码就能轻松搞定：

```python
# 计算1到100的和
total = 0
for i in range(1, 101):
  total += i
print(total)
```

是不是非常简洁？这只是Python强大功能的冰山一角。接下来，我们将正式开始学习Python。

## 第二节：使用Python的解释器

### 2.1. 唤出解释器

要开始编写Python代码，我们首先需要一个Python解释器。解释器是一个能够读取并执行Python代码的程序。

#### 2.1.1. 传入参数

你可以通过命令行向Python解释器传入参数，来运行一个Python脚本文件。首先，你需要创建一个以 `.py` 为后缀的文件，例如 `hello.py`，然后在其中写入以下代码：

```python
print("Hello, Python!")
```

接着，在命令行中输入以下命令：

```bash
python hello.py
```

你将会在屏幕上看到输出：

```
Hello, Python!
```

恭喜你，你已经成功运行了你的第一个Python程序！

#### 2.1.2. 交互模式

除了运行脚本文件，你还可以直接在解释器的交互模式下编写和执行代码。在命令行中输入 `python` 并回车，你就会看到类似下面的提示符 `>>>`，这表示你已经进入了Python的交互模式。

现在，你可以在 `>>>` 后面直接输入Python代码，解释器会立即执行并返回结果。例如：

```python
>>> 2 + 2
4
>>> print("Hello, Python!")
Hello, Python!
```

交互模式非常适合用来进行一些简单的代码测试和实验。

### 2.2. 解释器的运行环境

#### 2.2.1. 源文件的字符编码

为了在代码中正确地显示各种语言的字符（例如中文），你需要在Python源文件的开头指定文件的编码格式。推荐使用UTF-8编码，它能够支持几乎所有的字符。

在Python 3中，默认的源文件编码就是UTF-8。但为了保证代码在不同环境下的兼容性，建议在文件开头加上一行编码声明：

```python
# -*- coding: utf-8 -*-
```

## 第三节：Python 速览

### 3.1. Python 用作计算器

在交互模式下，你可以把Python当作一个强大的计算器来使用。

#### 3.1.1. 数字

Python支持整数和浮点数（即小数）的四则运算，以及更复杂的数学运算：

```python
>>> 2 + 2
4
>>> 50 - 5*6
20
>>> (50 - 5*6) / 4
5.0
>>> 8 / 5  # 除法运算总是返回浮点数
1.6
>>> 17 // 3  # 地板除，结果向下取整
5
>>> 17 % 3  # 取余数
2
>>> 5 * 3 + 2  # 乘法和加法
17
>>> 5 ** 2  # 乘方
25
```

#### 3.1.2. 文本

除了数字，Python还能处理文本，也就是字符串。你可以用单引号或双引号来创建字符串：

```python
>>> 'Hello, world!'
'Hello, world!'
>>> "Hello, world!"
'Hello, world!'
```

字符串可以用 `+` 号进行拼接，也可以用 `*` 号进行重复：

```python
>>> 'Py' + 'thon'
'Python'
>>> 3 * 'un' + 'ium'
'unununium'
```

#### 3.1.3. 列表

列表是Python中一种非常重要的数据结构，它可以用来存储一系列有序的元素。列表中的元素可以是任意类型，并且可以随时添加、删除或修改。

你可以用方括号 `[]` 来创建一个列表，并用逗号分隔其中的元素：

```python
>>> squares = [1, 4, 9, 16, 25]
>>> squares
[1, 4, 9, 16, 25]
```

### 3.2. 走向编程的第一步

在了解了Python的基本数据类型之后，我们就可以开始编写一些简单的程序了。例如，我们可以用一个 `while` 循环来生成著名的斐波那契数列：

```python
# 斐波那契数列
a, b = 0, 1
while a < 10:
  print(a)
  a, b = b, a+b
```

这段代码的输出将会是：

```
0
1
1
2
3
5
8
```

至此，你已经掌握了Python最基础的知识。在接下来的学习中，你将会接触到更多有趣和强大的功能。祝你学习愉快！

## 第四节：更多控制流工具

上一节我们学习了 `while` 循环，现在我们来探索更多控制程序执行流程的工具，让你的代码更加灵活和强大。

### 4.1. `if` 语句

`if` 语句用于根据条件来执行代码。如果条件为真 (True)，则执行 `if` 下方的代码块。

```python
x = 10
if x > 0:
  print("x 是一个正数")
```

我们可以使用 `else` 来处理条件为假 (False) 的情况：

```python
x = -5
if x > 0:
  print("x 是一个正数")
else:
  print("x 不是一个正数")
```

如果你有多个条件需要判断，可以使用 `elif` (else if 的缩写)：

```python
score = 85
if score >= 90:
  print("优秀")
elif score >= 80:
  print("良好")
elif score >= 60:
  print("及格")
else:
  print("不及格")
```

### 4.2. `for` 语句

`for` 语句用于遍历任何序列（例如列表或字符串）中的元素。

```python
# 遍历一个列表
fruits = ["苹果", "香蕉", "樱桃"]
for fruit in fruits:
  print(f"我喜欢吃 {fruit}")

# 遍历一个字符串
for letter in "Python":
  print(letter)
```

### 4.3. `range()` 函数

如果你需要循环一个指定的次数，`range()` 函数非常有用。它能生成一个数字序列。

```python
# 打印 0 到 4
for i in range(5):
  print(i)  # 输出会是 0, 1, 2, 3, 4

# 打印 5 到 9
for i in range(5, 10):
  print(i) # 输出会是 5, 6, 7, 8, 9
```

### 4.4. `break` 和 `continue` 语句

- `break`：用于完全跳出当前循环。
- `continue`：用于跳过当前这次循环，直接开始下一次循环。

```python
# break 示例：找到第一个偶数就停止
for num in [1, 3, 5, 6, 7, 9]:
  if num % 2 == 0:
    print(f"找到了第一个偶数: {num}")
    break # 结束循环

# continue 示例：只打印奇数
for num in range(1, 10):
  if num % 2 == 0:
    continue # 如果是偶数，跳过本次循环
  print(num)
```

### 4.8. 定义函数

函数是一段可以重复使用的代码块。使用 `def` 关键字来定义一个函数。

```python
# 定义一个打招呼的函数
def greet(name):
  """这个函数会向传入的名字打招呼。"""
  print(f"你好, {name}!")

# 调用函数
greet("小明")
greet("小红")
```

函数可以有一个返回值，使用 `return` 关键字。

```python
# 定义一个计算平方的函数
def square(number):
  return number * number

result = square(5)
print(result) # 输出 25
```

### 4.9. 函数定义详解

#### 4.9.1. 默认值参数

你可以在定义函数时为参数指定一个默认值。这样，在调用函数时，如果没有提供该参数的值，就会使用默认值。

```python
def ask_ok(prompt, retries=4, reminder='请重试!'):
    # ... 函数体 ...
    pass # pass 语句表示什么都不做，只是一个占位符

# 可以这样调用：
# ask_ok("你真的想退出吗？")
# ask_ok("你想覆盖这个文件吗？", 2)
```

#### 4.9.6. Lambda 表达式

`lambda` 关键字可以创建一个小型的匿名函数。它适用于需要一个简单函数但又不想为其专门命名的情况。

```python
# 使用 def 定义
def add(x, y):
  return x + y

# 使用 lambda 定义
add_lambda = lambda x, y: x + y

print(add(2, 3))        # 输出 5
print(add_lambda(2, 3)) # 输出 5
```

---

## 第五节：数据结构

本节将深入探讨Python中用于组织和存储数据的主要结构，这些是构建复杂程序的基础。

### 5.1. 列表详解

列表是Python中最常用的数据结构之一。它是一个可变的、有序的元素集合。

**列表常用方法：**

- `append(x)`: 在列表末尾添加一个元素。
- `insert(i, x)`: 在指定位置 `i` 插入一个元素 `x`。
- `remove(x)`: 删除列表中第一个值为 `x` 的元素。
- `pop(i)`: 删除并返回指定位置 `i` 的元素（如果未指定 `i`，则删除并返回最后一个元素）。
- `sort()`: 对列表进行原地排序。
- `reverse()`: 翻转列表中的元素。

```python
my_list = [3, 1, 4]
my_list.append(2)     # my_list 现在是 [3, 1, 4, 2]
my_list.sort()        # my_list 现在是 [1, 2, 3, 4]
my_list.pop()         # 返回 4, my_list 现在是 [1, 2, 3]
print(my_list)
```

#### 5.1.3. 列表推导式

列表推导式提供了一种简洁优雅的方式来创建列表。

```python
# 传统方法创建一个平方数列表
squares = []
for x in range(10):
  squares.append(x**2)

# 使用列表推导式
squares_comp = [x**2 for x in range(10)]

print(squares)
print(squares_comp)
```

### 5.2. `del` 语句

`del` 语句可以根据索引而不是值来从列表中删除一个元素。

```python
a = [-1, 1, 66.25, 333, 333, 1234.5]
del a[0]     # a 变为 [1, 66.25, 333, 333, 1234.5]
del a[2:4]   # a 变为 [1, 66.25, 1234.5]
```

### 5.3. 元组和序列

元组 (tuple) 与列表类似，也是一个有序的元素序列。但关键区别在于：**元组是不可变的**。一旦创建，就不能修改。

元组使用圆括号 `()` 创建。

```python
t = (12345, 54321, 'hello!')
print(t[0]) # 输出 12345

# t[0] = 88888  # 这行代码会报错 TypeError
```

**何时使用元组？** 当你有一组数据不希望被修改时，使用元组比列表更安全。

### 5.4. 集合

集合 (set) 是一个无序且不包含重复元素的集。主要用于成员测试和消除重复元素。

集合使用大括号 `{}` 创建。

```python
basket = {'苹果', '橙子', '苹果', '梨', '橙子', '香蕉'}
print(basket)  # 输出会是 {'橙子', '梨', '香蕉', '苹果'}，重复的元素被去掉了

# 成员测试
print('橙子' in basket) # True
print('螃蟹' in basket) # False
```

### 5.5. 字典

字典 (dictionary) 是另一种非常有用的数据结构，它存储的是 **键-值 (key-value)** 对。每个键都是唯一的，并与一个值相关联。

字典也使用大括号 `{}` 创建，但包含键和值。

```python
# 创建一个字典
tel = {'jack': 4098, 'sape': 4139}

# 添加一个键值对
tel['guido'] = 4127

# 访问值
print(tel['jack']) # 输出 4098

# 删除一个键值对
del tel['sape']

# 查看所有的键
print(list(tel.keys()))
```

### 5.6. 循环的技巧

在处理数据结构时，有一些技巧可以让循环更高效：

1.  **遍历字典**: 使用 `.items()` 方法可以同时获取键和值。
    ```python
    knights = {'gallahad': 'the pure', 'robin': 'the brave'}
    for k, v in knights.items():
        print(k, v)
    ```

2.  **遍历序列**: 使用 `enumerate()` 函数可以同时获取索引和对应的值。
    ```python
    for i, v in enumerate(['tic', 'tac', 'toe']):
        print(i, v)
    ```

3.  **同时遍历多个序列**: 使用 `zip()` 函数可以将多个序列打包在一起遍历。
    ```python
    questions = ['name', 'quest', 'favorite color']
    answers = ['lancelot', 'the holy grail', 'blue']
    for q, a in zip(questions, answers):
        print(f'What is your {q}? It is {a}.')
    ```

至此，你已经学习了Python中最重要的控制流工具和核心数据结构。掌握它们，你就可以开始构建更加复杂和有用的程序了。继续努力！

## 第六节：模块

随着你写的程序越来越长，你可能会想把它拆分成几个文件，以便于维护。在Python中，你可以把相关的代码（例如函数、变量）放在一个单独的文件里，这个文件就称为一个 **模块 (Module)**。当需要使用这些代码时，只需导入这个模块即可。

### 6.1. 模块详解

一个模块就是一个包含了Python定义和语句的文件。文件名就是模块名加上扩展名 `.py`。

**为什么使用模块？**
*   **代码复用**: 你可以在不同的程序中导入并使用同一个模块。
*   **代码组织**: 将代码按功能划分到不同的模块中，可以让项目结构更清晰。
*   **避免命名冲突**: 每个模块都有自己的命名空间，不同模块中的同名函数或变量不会互相干扰。

**如何使用模块？**

假设我们有一个名为 `fibo.py` 的文件，内容如下：

```python
# fibo.py
def fib(n):    # 输出小于n的斐波那契数列
    a, b = 0, 1
    while a < n:
        print(a, end=' ')
        a, b = b, a+b
    print()

def fib2(n):   # 返回小于n的斐波那契数列
    result = []
    a, b = 0, 1
    while a < n:
        result.append(a)
        a, b = b, a+b
    return result
```

现在，我们可以在另一个Python文件或交互式解释器中导入并使用它。

1.  **`import` 语句**

    这是最常见的导入方式。它会导入整个模块。

    ```python
    import fibo

    fibo.fib(1000)
    # 输出: 0 1 1 2 3 5 8 ...
    print(fibo.fib2(100))
    # 输出: [0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89]
    ```
    注意，在使用模块中的函数时，需要使用 `模块名.函数名` 的形式。

2.  **`from ... import ...` 语句**

    如果你只想使用模块中的某几个函数或变量，可以使用这种方式。

    ```python
    from fibo import fib, fib2

    fib(1000) # 注意：这里直接使用函数名，不需要加模块名前缀
    print(fib2(100))
    ```

3.  **`import ... as ...` 语句 (别名)**

    有时模块名很长，或者你想用一个更方便的名字，可以给它起一个别名。

    ```python
    import fibo as fb

    fb.fib(1000)
    ```

### 6.2. 标准模块

Python自带了一个庞大的 **标准库 (Standard Library)**，里面包含了大量现成的、非常有用的模块，无需额外安装。例如，`math` 模块提供了各种数学运算功能。

```python
import math

print(math.pi)      # 输出圆周率 pi
print(math.sqrt(16)) # 输出 16 的平方根，即 4.0
```

### 6.4. 包

当一个项目变得非常大时，可能会有很多模块。为了更好地组织它们，我们可以使用 **包 (Package)**。包其实就是一个包含了多个模块的文件夹，这个文件夹里必须有一个特殊的 `__init__.py` 文件（即使是空文件也行），用来告诉Python这个目录是一个包。

---

## 第七节：输入与输出

程序需要与用户进行交互。你需要从用户那里获取输入，并将结果展示给用户看。

### 7.1. 更复杂的输出格式

我们已经使用了 `print()` 函数，但还有更灵活的方式来格式化输出。

#### 7.1.1. 格式化字符串字面值 (F-strings)

这是目前最推荐的格式化字符串的方法。它非常直观和方便。只需在字符串的第一个引号前加上一个 `f` 或 `F`，然后在字符串中用 `{}` 包含变量名或表达式即可。

```python
name = "小明"
age = 19
print(f"大家好，我叫{name}，我今年{age}岁了。")
# 输出: 大家好，我叫小明，我今年19岁了。

# 甚至可以在 {} 中进行计算
print(f"明年我就 {age + 1} 岁了。")
# 输出: 明年我就 20 岁了。
```

### 7.2. 读写文件

程序经常需要从文件中读取数据，或将数据保存到文件中。

**写入文件**

使用 `open()` 函数来打开一个文件。第一个参数是文件名，第二个参数是模式（'w' 表示写入，'a' 表示追加）。

推荐使用 `with` 语句来操作文件，因为它能确保文件在操作完成后被自动关闭，即使发生错误也不例外。

```python
# 'w' 模式会覆盖文件的原有内容（如果文件不存在则会创建）
with open("my_story.txt", "w", encoding="utf-8") as f:
    f.write("从前有座山，\n")
    f.write("山里有座庙。\n")

# 'a' 模式会在文件末尾追加内容
with open("my_story.txt", "a", encoding="utf-8") as f:
    f.write("庙里有个老和尚在讲故事。\n")
```
*`encoding="utf-8"` 参数很重要，它能确保中文字符被正确地读写。*

**读取文件**

同样使用 `open()` 函数，但模式为 'r' (读取，这是默认模式)。

```python
with open("my_story.txt", "r", encoding="utf-8") as f:
    # 1. 一次性读取所有内容
    # content = f.read()
    # print(content)

    # 2. 逐行读取（推荐方式）
    for line in f:
        print(line, end='') # print函数默认会加一个换行符，所以用end=''来去掉
```

---

## 第八节：错误和异常

在编程过程中，没有人能保证一次性写出完美无缺的代码。错误是学习过程的一部分。Python会通过“错误”和“异常”来帮助我们定位和解决问题。

### 8.1. 语法错误

**语法错误 (Syntax Errors)** 是最常见的一种错误，通常是因为你的代码不符合Python的语法规则，比如拼写错误、漏掉了冒号等。Python解释器在运行代码之前就会发现这类错误，并指出错误的位置。

```python
# 缺少了 if 语句末尾的冒号 :
x = 10
if x > 5
    print("x is greater than 5")

# 输出:
#   File "<stdin>", line 2
#     if x > 5
#              ^
# SyntaxError: invalid syntax
```

### 8.2. 异常

即使代码的语法完全正确，在运行时也可能发生错误，这些错误被称为 **异常 (Exceptions)**。

常见的异常类型：
*   `ZeroDivisionError`: 尝试除以零。
*   `NameError`: 使用了一个未定义的变量。
*   `TypeError`: 对类型不兼容的对象执行了操作（例如，`'2' + 2`）。
*   `ValueError`: 传入的参数类型正确但值不合适（例如，`int('abc')`）。
*   `FileNotFoundError`: 尝试打开一个不存在的文件。

```python
# ZeroDivisionError
10 / 0

# NameError
print(my_variable)
```

### 8.3. 异常的处理

如果异常发生而没有被处理，程序就会崩溃并停止运行。为了让程序更健壮，我们可以使用 `try...except` 语句来 **捕获并处理** 异常。

基本语法：

```python
try:
    # 尝试执行的代码块，这里可能会产生异常
    ...
except ExceptionType:
    # 如果在 try 代码块中发生了指定类型的异常，就执行这里的代码
    ...
```

**示例：** 编写一个安全的除法程序。

```python
try:
    numerator = int(input("请输入被除数: "))
    denominator = int(input("请输入除数: "))
    result = numerator / denominator
    print(f"结果是: {result}")
except ValueError:
    print("输入错误！请输入一个有效的数字。")
except ZeroDivisionError:
    print("错误！除数不能为零。")
```
在这个例子中：
*   如果用户输入的不是数字，`int()` 会引发 `ValueError`，程序会跳转到第一个 `except` 块。
*   如果用户输入的除数是0，会引发 `ZeroDivisionError`，程序会跳转到第二个 `except` 块。
*   如果一切正常，`except` 块的代码就不会被执行。

## 第九节：类 (Classes)

到目前为止，我们已经接触了像数字、字符串、列表这样的数据“类型”。但是，如果我们要描述一个更复杂的事物，比如一个“学生”，他有姓名、学号、成绩等属性，还有“学习”、“做作业”等行为，要怎么办呢？这时候，就需要我们自己来创造一种新的数据类型，这就是“类”。

“类”是 **面向对象编程 (Object-Oriented Programming, OOP)** 的核心概念。你可以把它想象成一张**蓝图**或者一个**模具**。例如，我们可以设计一张“汽车”的蓝图，上面规定了汽车应该有轮子、发动机、颜色等属性，还应该有“启动”、“刹车”、“鸣笛”等功能。

而根据这张蓝图制造出来的每一辆具体的汽车（比如一辆红色的、车牌号为ABC-123的特斯拉），就是一个**对象 (Object)**，也叫**实例 (Instance)**。

### 9.1 名称和对象

在Python中，我们接触到的一切几乎都是“对象”。一个数字、一段文字、一个列表，都是对象。而我们用来称呼它们的变量名，更像是一个贴在对象上的**标签**。

```python
x = 100 # 100是一个整数对象，x是贴在这个对象上的标签
y = x   # y是另一个标签，也贴在了100这个对象上
```
理解这一点对于理解“类”和“对象”至关重要。

### 9.2 Python 作用域和命名空间

这是一个稍微有些理论性的概念，但非常重要。你可以把**命名空间 (Namespace)** 想象成一个电话本，里面记录着“名字”和“名字对应的东西（对象）”。Python中有很多不同的电话本，比如：

*   **内置命名空间**：包含了Python自带的函数，比如 `print()`、`len()` 等。
*   **全局命名空间**：你在一个`.py`文件中直接定义的变量，都在这里。
*   **局部命名空间**：你在一个函数内部定义的变量，就在这个函数自己的电话本里。

**作用域 (Scope)** 指的就是代码在运行时，会按照什么样的顺序去查找这些电话本。顺序通常是：**局部 -> 全局 -> 内置**。如果在当前的电话本里没找到某个名字，就会去更大范围的电话本里找。

### 9.3 初探类

#### 9.3.1 类定义语法

我们用 `class` 关键字来定义一个类，也就是设计一张蓝图。

```python
class Student:
    # pass 是一个占位符，表示这里暂时什么都不做
    pass
```
这样，我们就定义好了一个最简单的 `Student` 类。

#### 9.3.2 & 9.3.3 类对象和实例对象

类本身是一个“类对象”，我们可以用它来创建“实例对象”。

```python
# 创建两个学生实例（两个具体的学生对象）
student_A = Student()
student_B = Student()
```
`student_A` 和 `student_B` 就是根据 `Student` 这张蓝图创建出来的两个独立的学生实例。

#### 9.3.4 方法对象

“方法”就是定义在类里面，供该类所有实例使用的函数。它代表了这类对象的“行为”。比如，学生可以“做自我介绍”。

```python
class Student:
    # 定义一个“构造方法”，在创建实例时自动运行
    def __init__(self, name, student_id):
        # self.name 和 self.student_id 是“实例变量”，每个实例独有
        self.name = name
        self.student_id = student_id
        print(f"创建了一个新学生，姓名：{self.name}")

    # 定义一个普通方法
    def introduce_self(self):
        # 注意这里的 self
        print(f"大家好，我叫 {self.name}，我的学号是 {self.student_id}。")

# 创建实例时，会自动调用 __init__ 方法
student_A = Student("张三", "20250101")
student_B = Student("李四", "20250102")

# 调用实例的方法
student_A.introduce_self()
student_B.introduce_self()
```
**输出:**
```
创建了一个新学生，姓名：张三
创建了一个新学生，姓名：李四
大家好，我叫 张三，我的学号是 20250101。
大家好，我叫 李四，我的学号是 20250102。
```
**关键点：`self`**
你会发现每个方法的第一个参数都是 `self`。它代表**实例对象本身**。当 `student_A.introduce_self()` 这行代码执行时，Python会自动把 `student_A` 这个实例传给 `self` 参数。这样，方法内部就能通过 `self` 来访问这个实例自己的属性（比如 `self.name`）。

#### 9.3.5 类和实例变量

*   **实例变量 (Instance Variable)**：每个实例独有的变量，就像上面例子中的 `name` 和 `student_id`。每个学生的姓名和学号都不同。它在 `__init__` 方法中通过 `self.变量名 = 值` 的方式定义。
*   **类变量 (Class Variable)**：这个类的所有实例共享的变量。比如，所有的学生都在同一个学校上学。

```python
class Student:
    # 这是类变量，所有Student实例共享
    school = "北京大学"

    def __init__(self, name):
        # 这是实例变量
        self.name = name

s1 = Student("王五")
s2 = Student("赵六")

print(f"{s1.name} 在 {s1.school} 上学。")
print(f"{s2.name} 也在 {s2.school} 上学。")
```
**输出:**
```
王五 在 北京大学 上学。
赵六 也在 北京大学 上学。
```

### 9.5 继承 (Inheritance)

继承是面向对象的另一大特性。它允许我们创建一个新类，这个新类可以“继承”一个已存在类的所有属性和方法，并且可以添加自己独有的新功能。

比如，我们可以定义一个更具体的“研究生”类，它首先是一个“学生”，所以拥有学生的所有属性和方法，但它还有自己独特的属性，比如“导师”。

```python
# Student类是“父类”或“基类”
class Student:
    school = "北京大学"
    def __init__(self, name):
        self.name = name
    def introduce(self):
        print(f"我是 {self.school} 的学生，我叫 {self.name}。")

# GraduateStudent类是“子类”，它继承了Student类
class GraduateStudent(Student):
    def __init__(self, name, advisor):
        # super().__init__(name) 用来调用父类(Student)的__init__方法，完成name的初始化
        super().__init__(name)
        self.advisor = advisor # 添加自己的新属性
    
    # 也可以“重写”父类的方法
    def introduce(self):
        print(f"我是 {self.school} 的研究生，我叫 {self.name}，我的导师是 {self.advisor} 教授。")

# 创建一个普通学生实例
stu = Student("小明")
stu.introduce()

# 创建一个研究生实例
grad_stu = GraduateStudent("小华", "王")
grad_stu.introduce()
```
**输出:**
```
我是 北京大学 的学生，我叫 小明。
我是 北京大学 的研究生，我叫 小华，我的导师是 王 教授。
```

`GraduateStudent` 继承了 `Student`，所以它天生就知道了 `school` 和 `name` 是什么，并且可以直接使用 `introduce` 方法，也可以根据需要进行修改（这叫**重写 Override**）。

---

## 第十节 & 第十一节：标准库简介 (Brief Tour of the Standard Library)

Python之所以强大，不仅仅是因为它语法简单，更是因为它拥有一个极其丰富的**“标准库”**。

你可以把标准库想象成一个**巨大的工具箱**，这个工具箱是买Python“送”的。当你需要完成某个特定任务时，比如处理时间、进行数学计算、访问网站等，你不需要从零开始自己造轮子，大概率可以直接从这个工具箱里找到现成的工具来使用。

这些工具被分门别类地放在不同的**“模块 (Module)”**中。使用时，我们只需要用 `import` 关键字把需要的模块“导入”到我们的代码里。

下面我们来认识几个常用模块：

### 10.1 `os` 模块：与操作系统交互

`os` 模块让你能用Python代码来执行一些原本需要在电脑命令行里做的操作，比如管理文件和目录。

```python
import os

# 获取当前的工作目录
current_path = os.getcwd()
print(f"我当前在哪个文件夹里？ -> {current_path}")

# 列出当前目录下的所有文件和文件夹
print("这个文件夹里有什么？ ->", os.listdir(current_path))
```

### 10.6 `math` 模块：数学计算

提供了各种复杂的数学运算功能。

```python
import math

# 计算9的平方根
print("9的平方根是:", math.sqrt(9))

# 获取圆周率 Pi
print("圆周率 Pi 约等于:", math.pi)

# 计算 sin(90度)，注意math库使用弧度，所以需要转换
print("sin(90度)的值是:", math.sin(math.pi / 2))
```

### 10.7 `urllib` 模块：访问互联网

可以用它来编写简单的网络爬虫，从网站上获取数据。

```python
from urllib import request

# 尝试获取一个网站的HTML内容
try:
    with request.urlopen('https://www.python.org') as response:
        html = response.read()
        print("成功获取python.org网站内容的前100个字节：")
        print(html[:100])
except Exception as e:
    print("访问网站失败:", e)
```

### 10.8 `datetime` 模块：处理日期和时间

这是一个非常实用的模块，用于处理各种与日期、时间相关的操作。

```python
from datetime import date, datetime

# 获取今天的日期
today = date.today()
print("今天的日期是:", today)
print(f"年份: {today.year}, 月份: {today.month}, 日: {today.day}")

# 获取当前的精确时间
now = datetime.now()
print("现在的时间是:", now)
print("格式化输出:", now.strftime("%Y-%m-%d %H:%M:%S"))
```

### 11.5 `logging` 模块：记录程序日志

当你的程序变得复杂时，用 `print()` 来调试和追踪信息会变得很乱。`logging` 模块提供了一套专业得多的日志记录系统，你可以控制日志的级别（比如调试信息、普通信息、警告、错误），并将日志输出到屏幕或文件。

```python
import logging

logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')

logging.debug("这是一条调试信息，默认可能不显示。")
logging.info("程序正常运行...")
logging.warning("注意！内存占用可能过高！")
logging.error("发生了一个错误！文件未找到。")
```

### 11.8 `decimal` 模块：高精度小数运算

你可能遇到过一个奇怪的现象，在计算机里 `0.1 + 0.2` 并不精确等于 `0.3`，这是因为计算机内部用二进制表示小数时有误差。

```python
# 普通浮点数计算
print(f"0.1 + 0.2 = {0.1 + 0.2}") # 结果可能出乎意料
```
输出: `0.1 + 0.2 = 0.30000000000000004`

在进行金融计算等需要高精度的场景下，这会是致命的。`decimal` 模块就是为了解决这个问题而生的。

```python
from decimal import Decimal

# 使用Decimal进行高精度计算
a = Decimal('0.1')
b = Decimal('0.2')
print(f"Decimal('0.1') + Decimal('0.2') = {a + b}")
```
输出: `Decimal('0.1') + Decimal('0.2') = 0.3`

标准库里还有成百上千个有用的模块，这里只是冰山一角。学习使用标准库的关键在于，当你要实现某个功能时，先**养成查阅官方文档的习惯**，看看是否已经有现成的工具可以使用。这会极大地提高你的开发效率。

---

## 第十二节：虚拟环境和包

恭喜你，学到这里，你已经掌握了Python的核心语法和常用数据结构！现在，我们要学习一些能让你在未来进行大型项目开发时，保持代码和环境清晰、可控的重要工具：**包**和**虚拟环境**。

### 12.1 概述：为什么需要这些新东西？

想象一下，你学会了做饭。一开始，你可能只会在厨房里做一些家常菜，比如西红柿炒蛋，厨房里只有油、盐、酱、醋就够了。

但随着你厨艺的增长，你开始挑战更复杂的菜系：
*   **做意大利面**：你需要购买意大利面、罗勒、芝士粉、橄榄油。
*   **做日式寿司**：你需要购买寿司米、海苔、芥末、专门的寿司醋。

这些“额外”的食材和调料，就类似于Python中的**包 (Package)**。

而 **虚拟环境 (Virtual Environment)** 又是什么呢？

想象一下，你不想把做意大利面的芝士粉和做寿司的芥末混在一起，因为它们属于不同的“项目”，可能会串味儿。于是，你准备了两个独立的储物箱，一个专门放做意面的所有材料，另一个专门放做寿司的所有材料。每次做饭前，你只拿出对应菜系的储物箱。这样，你的厨房就永远井井有条。

这个“独立的储物箱”，就是**虚拟环境**。

---

### 深入理解“包” (Package)

**1. 什么是包？**

在Python中，**包**（也常被称为库或模块）是别人已经编写好的一套代码，用来解决特定的问题。你不需要自己从零开始写，只需要“拿来主义”，直接使用即可。

*   **比喻**：包就像一个**工具箱**。你想拧螺丝，不需要自己去炼钢、打磨来制造一个螺丝刀，你只需要买一个“五金工具箱”，直接拿出里面的螺丝刀来用就行。
*   **例子**：
    *   想做数据分析？有 `pandas` 这个包。
    *   想做科学计算？有 `numpy` 这个包。
    *   想开发网站？有 `Django` 或 `Flask` 包。
    *   想从网站上爬取信息？有 `requests` 和 `BeautifulSoup` 包。

**2. 如何管理这些“包”？—— `pip` 工具**

`pip` 是Python的**包管理器**。它的作用就是帮你安装、更新和卸载这些外部的“工具箱”。

*   **比喻**：`pip` 就像你手机上的“应用商店”。你想用某个App，就在应用商店里搜索、下载、安装。
*   **常用命令**：
    *   `pip install 包名`：安装一个包 (例如: `pip install requests`)。
    *   `pip uninstall 包名`：卸载一个包。
    *   `pip list`：查看当前已经安装了哪些包。

---

### 12.2 & 12.3 深入理解“虚拟环境”

**1. 为什么要用虚拟环境？**

这个问题至关重要。假设你同时在开发两个项目：

*   **项目A**：一个很老的网站，它依赖一个叫做 `SomePackage` 的 `1.0` 版本。
*   **项目B**：一个全新的数据分析程序，它需要 `SomePackage` 的最新 `2.0` 版本，因为新版本才有你需要的功能。

如果你把所有包都安装在系统里（我们称之为“全局环境”），问题就来了：你的电脑里 `SomePackage` 究竟应该是 `1.0` 版本还是 `2.0` 版本？它只能有一个版本。如果你为了项目B升级到了 `2.0`，那么项目A可能就无法运行了。这就是所谓的**“依赖冲突”**。

虚拟环境就是为了解决这个问题而生的。它会为你的每个项目创建一个**隔离的、干净的Python环境**。

*   **比喻重申**：就是我们前面说的，为“意大利面”和“寿司”分别准备两个独立的储物箱。在“意面储物箱”里，你放芝士粉；在“寿司储物箱”里，你放芥末。它们互不干扰。

**2. 如何创建和使用虚拟环境？**

下面是标准的“三步走”流程：

**第一步：创建一个虚拟环境（准备一个新储物箱）**

在你的项目文件夹下，打开命令行，运行以下命令：

```bash
# venv 是Python自带的工具，myenv是虚拟环境的名字，你可以任取
python -m venv myenv
```

执行后，你会发现项目文件夹里多了一个名为 `myenv` 的新文件夹。这里面存放了一个独立的Python解释器和未来要安装的各种包。

**第二步：激活虚拟环境（打开并使用这个储物箱）**

*   **在 Windows 上:**
    ```bash
    myenv\Scripts\activate
    ```
*   **在 macOS 或 Linux 上:**
    ```bash
    source myenv/bin/activate
    ```

激活后，你会发现你的命令行提示符前面多了一个 `(myenv)` 的字样。这表示你当前正处于 `myenv` 这个虚拟环境中。**在此环境下，你用 `pip` 安装的所有包，都只会安装到 `myenv` 文件夹里**，而不会污染你的全局Python环境。

**第三步：在虚拟环境中工作**

现在你可以像往常一样工作了。例如，为你的项目安装它所需要的包：

```bash
# 这个requests包只会安装在myenv中
pip install requests
```

**第四步：退出虚拟环境（盖上储物箱的盖子）**

当你完成了今天的工作，想退出这个环境时，只需在命令行输入：

```bash
deactivate
```

前面的 `(myenv)` 提示符就会消失，你就回到了系统的全局环境。

**总结一下工作流程**：
> 开始一个新项目 -> 创建虚拟环境 -> 激活它 -> 安装依赖包 -> 编写代码 -> 工作完成 -> 退出虚拟环境。

这绝对是每一位专业Python开发者都会遵循的最佳实践！

---

## 第十三节：接下来？

你已经完成了Python入门教程的核心部分，就像是完成了新手村的所有任务。那么，接下来该去哪里冒险呢？

1.  **深入探索官方文档**
    *   你刚刚学习的教程，只是Python官方文档的冰山一角。官方文档是最权威、最准确的参考资料。遇到任何问题，首先应该想到查阅它。
    *   特别推荐浏览一下 **“标准库参考”**。你会发现Python自带了大量功能强大的“工具箱”（模块），例如用于处理文件路径的 `os` 模块，处理日期和时间的 `datetime` 模块等。很多功能你根本不需要用`pip`安装外部包就能实现。

2.  **寻找你的兴趣方向，并动手实践**
    *   **编程是一门手艺，熟能生巧**。只看教程是学不会的。你需要动手写代码，去解决一个你感兴趣的实际问题。
    *   **不知道做什么？这里有一些建议**：
        *   **Web开发**：学习 `Django` 或 `Flask` 框架，尝试做一个个人博客、一个留言板。
        *   **数据科学/人工智能**：学习 `Numpy`, `Pandas`, `Matplotlib` 这些库，去分析一些公开的数据集（比如电影评分、城市天气等），或者尝试训练一个简单的图像识别模型。
        *   **自动化脚本**：编写一个能自动整理你下载文件夹的脚本，或者一个能每天定时发邮件提醒你天气的小程序。
        *   **游戏开发**：使用 `Pygame` 库，尝试复刻一个像“贪吃蛇”、“俄罗斯方块”这样的小游戏。

3.  **加入社区，与人交流**
    *   学习编程不是一个人的孤岛。当你遇到问题时，很可能已经有成千上万的人遇到过并解决了。
    *   可以访问 **Stack Overflow** 这样的问答网站，搜索你的问题。
    *   可以加入一些国内外的技术论坛、QQ群、微信群，与其他学习者和开发者交流心得。

**最后，也是最重要的一点：保持好奇心，持续学习。** 编程的世界日新月异，永远有新的知识和技术等待你去探索。你已经迈出了最坚实的第一步，未来的路由你自己决定。祝你编程愉快！

---

## 第十四节：交互式编辑和编辑历史

在前面的章节中，我们已经接触了Python的交互式解释器（就是那个带有 `>>>` 提示符的界面）。你可能觉得，每次输错一个字母，或者想再次运行上一条命令，都得全部重新输入一遍，非常麻烦。

这一节，我们就来学习一些能让你在交互式解释器里“偷懒”和提升效率的超级技巧。

### 14.1 Tab 补全和编辑历史

想象一下你在使用手机发短信。当你输入“早上好”，输入法会自动提示完整的词语，你只需要选择一下就行了。或者，你想找到刚才发过的一条信息，你会去翻看历史聊天记录。

Python解释器的“Tab补全”和“历史编辑”功能，就和这两个例子非常相似。

**1. Tab 补全 (Tab Completion)**

*   **这是什么？** 它是一个**智能的自动补全工具**。当你输入一个变量、函数或模块名字的一部分时，按下键盘上的 `Tab` 键，解释器会自动帮你补全剩下的部分。

*   **怎么用？**
    1.  打开Python解释器。
    2.  我们先导入一个叫 `os` 的模块（你可以把它想象成一个处理操作系统相关任务的工具箱）：
        ```python
        >>> import os
        ```
    3.  现在，你想用 `os` 模块里的一个功能，但你只记得它好像是 `lis` 开头的。你只需要输入：
        ```python
        >>> os.lis
        ```    
    4.  然后，**按下 `Tab` 键**！神奇的事情发生了，解释器会自动帮你补全成：
        ```python
        >>> os.listdir
        ```
    5.  如果有很多个可能的补全选项，按两次 `Tab` 键，它会把所有选项都列出来给你看。

*   **为什么它很重要？**
    *   **节省时间**：你再也不用输入那些长长的函数名了。
    *   **避免拼写错误**：电脑自动补全的，总比你手动输入的要准确得多！

**2. 编辑历史 (History Editing)**

*   **这是什么？** 解释器会**记住你输入过的所有命令**。你可以像翻电视遥控器的频道一样，轻松地找回它们。

*   **怎么用？**
    *   **按 `上箭头 ↑`**：显示你输入的上一条命令。再按一次，显示上上条，以此类推。
    *   **按 `下箭头 ↓`**：在你翻阅历史命令时，可以按 `↓` 来向后移动。
    *   **编辑命令**：当你找到一条历史命令后，它会显示在你的输入行上。你可以像编辑普通文本一样，用 `左箭头 ←` 和 `右箭头 →` 移动光标，删除或添加字符，然后按 `Enter` 重新执行修改后的命令。

*   **为什么它很重要？**
    当你调试代码，需要反复执行和微调同一条命令时，这个功能简直是救星。你只需要按一下 `↑`，修改一下，再按 `Enter`，而不需要把整行代码重新敲一遍。

### 14.2 默认交互式解释器的替代品

Python自带的那个黑乎乎的窗口虽然好用，但功能相对基础。这就像你电脑自带的记事本，能用，但不够强大。

有很多第三方的工具提供了“超级加强版”的Python解释器，其中最著名、最流行的就是 **IPython**。

*   **IPython 是什么？**
    你可以把它理解为一个**豪华版的Python解释器**。它包含了所有标准解释器的功能，并增加了大量令人惊艳的新特性，例如：
    *   **语法高亮**：代码会显示成彩色的，变量、函数、关键字一目了然，非常美观且易于阅读。
    *   **更强大的自动补全**：IPython的Tab补全功能比默认的更智能。
    *   **更好的错误提示**：错误信息经过格式化，阅读起来更清晰，能帮你更快地定位问题。
    *   **与Jupyter Notebook集成**：这是数据科学领域最核心的工具之一。Jupyter Notebook允许你创建一个像笔记本一样的文件，里面可以混合写入代码、运行结果、文字说明、图表，非常适合学习、展示和分享你的工作。

对于初学者来说，我强烈建议你在熟悉了基本操作后，尝试安装和使用IPython，它会让你的编程体验提升一个档次。

---

## 第十五节：浮点算术：争议和限制

这一节讨论的是一个非常有趣，但对初学者来说可能有点毁三观的问题。请先打开你的Python解释器，然后输入下面这行代码：

```python
>>> 0.1 + 0.2
```

你觉得结果会是什么？`0.3` 对吗？

让我们看看Python的答案：

```
0.30000000000000004
```

这是什么鬼？！Python连这么简单的数学都算错了吗？

别慌，这不是Python的bug，而是**所有现代计算机在处理小数（专业术语叫“浮点数”）时一个固有的、无法避免的特性**。

### 15.1 表示性错误 (Representation Error)

**1. 问题的根源：人类用十进制，电脑用二进制**

*   我们人类从小学习的数学是**十进制**（0-9）。在十进制中，有些分数是无法精确表示的，比如 `1/3`，它会变成一个无限循环小数 `0.333333...`。我们只能取一个近似值。

*   而计算机的底层硬件，只认识**二进制**（0和1）。在二进制的世界里，它同样会遇到无法精确表示的分数。**非常不幸的是，我们十进制里的一个很简单的小数，比如 `0.1`，转换成二进制后，竟然也是一个无限循环小数！**（它在二进制里看起来像 `0.0001100110011...`）

**2. 一个比喻：用一把只有特定刻度的尺子量东西**

*   想象一下，你的电脑内存就像一把尺子，但是这把尺子的空间是有限的。
*   当你要存储 `0.1` 这个无限循环的二进制小数时，尺子的长度不够了，你必须在某个地方把它截断，然后取一个**最接近**的能被尺子精确表示的刻度值。
*   这个“存储在尺子上的值”和“真实的 `0.1`”之间，就产生了一个极其微小的、几乎可以忽略不计的差距。这个差距，就叫做**“表示性错误”**。

所以，你看到的 `0.30000000000000004`，实际上是那个被截断近似后的`0.1` 和那个被截断近似后的`0.2` 相加得到的真实结果。

**3. 这意味着什么？以及我们该怎么办？**

*   **核心原则：永远不要用 `==` 来直接比较两个浮点数是否相等！**

    因为表示性错误的存在，你以为会相等的两个数，其在计算机内部的表示可能存在微小的差异。

    ```python
    # 错误的做法
    >>> 0.1 + 0.2 == 0.3
    False  # 因为左边的结果是 0.30000000000000004
    ```

*   **正确的比较方法：检查两个数是否“足够接近”**

    我们不要求两个浮点数完全相等，而是检查它们之间的差的绝对值是否在一个我们可以接受的极小范围（称为“容差”）之内。

    ```python
    # 正确的做法
    >>> abs((0.1 + 0.2) - 0.3) < 0.000001
    True
    ```

    幸运的是，Python的 `math` 模块提供了一个专门的函数来做这件事：

    ```python
    >>> import math
    >>> math.isclose(0.1 + 0.2, 0.3)
    True
    ```

*   **如果我需要绝对精确的计算（比如处理金钱），怎么办？**

    对于金融、会计等绝对不能有任何误差的场景，Python提供了一个专门的“法宝”：`decimal` 模块。它提供了一种 `Decimal` 对象，可以像我们用纸笔做数学题一样，进行精确的十进制小数运算，但代价是计算速度会比普通的浮点数慢一些。

    ```python
    >>> from decimal import Decimal
    >>> Decimal('0.1') + Decimal('0.2') == Decimal('0.3')
    True
    ```

**本节总结：**
对于绝大多数科学计算和日常编程，浮点数的这点微小误差完全不影响结果，你只需要记住用 `math.isclose()` 来比较它们。对于和钱相关的精确计算，请使用 `decimal` 模块。