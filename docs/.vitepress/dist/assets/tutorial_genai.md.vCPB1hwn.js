import{_ as o,c as t,o as e,a5 as a}from"./chunks/framework.BqMGeqrT.js";const r=JSON.parse('{"title":"开始使用生成式人工智能","description":"","frontmatter":{},"headers":[],"relativePath":"tutorial/genai.md","filePath":"tutorial/genai.md","lastUpdated":1757579921000}'),s={name:"tutorial/genai.md"};function n(u,i,d,l,c,h){return e(),t("div",null,[...i[0]||(i[0]=[a('<h1 id="开始使用生成式人工智能" tabindex="-1">开始使用生成式人工智能 <a class="header-anchor" href="#开始使用生成式人工智能" aria-label="Permalink to &quot;开始使用生成式人工智能&quot;">​</a></h1><p>作为一名大学生，能够熟练操作各种工具来辅助学习和生活是非常重要的技能。</p><div class="tip custom-block github-alert"><p class="custom-block-title">用户</p><p></p><p>为我解释这行C语言代码的原理：</p><p>main() { printf(&amp;unix[&quot;\\021%six\\012\\0&quot;],(unix)[&quot;have&quot;]+&quot;fun&quot;-0x60);}</p></div><div class="info custom-block github-alert"><p class="custom-block-title">GPT-5</p><p></p><p>好，这行代码属于典型的 <strong>C语言“恶搞代码”</strong>，它利用了数组和字符串字面量在 C 里的实现方式来写出看似晦涩难懂的代码。我们逐步拆解：</p><div class="language-c vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">main</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() { </span></span>\n<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    printf</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&amp;</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">unix</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">\\021%s</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">ix</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">\\012\\0</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">], (unix)[</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;have&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;fun&quot;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> -</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> 0x</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">60</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">); </span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><hr><h5 id="_1-unix-021-six-012-0-的原理" tabindex="-1">1. <code>unix[&quot;\\021%six\\012\\0&quot;]</code> 的原理 <a class="header-anchor" href="#_1-unix-021-six-012-0-的原理" aria-label="Permalink to &quot;1. `unix[&quot;\\021%six\\012\\0&quot;]` 的原理&quot;">​</a></h5><p>在 C 语言里，<strong><code>a[b]</code> 与 <code>b[a]</code> 完全等价</strong>，因为定义就是 <code>*(a+b)</code>。 所以 <code>unix[&quot;string&quot;]</code> 与 <code>&quot;string&quot;[unix]</code> 是一样的。</p><ul><li><p><code>&quot;\\021%six\\012\\0&quot;</code> 是一个字符串常量：</p><ul><li><code>\\021</code> 是八进制表示的控制字符（十进制 17）。</li><li>后面 <code>%six</code> 是普通字符。</li><li><code>\\012</code> 是换行（十进制 10）。</li><li><code>\\0</code> 是字符串终止符。</li><li>整个字符串就是：<strong>[0x11]、%、s、i、x、[换行]、\\0</strong>。</li></ul></li></ul><p>当写成 <code>unix[&quot;\\021%six\\012\\0&quot;]</code> 时，其实就是 <code>&quot; \\021%six\\012\\0&quot;[unix]</code>，也就是从字符串中偏移 <code>unix</code> 个字符。</p><hr><h5 id="_2-unix-021-six-012-0" tabindex="-1">2. <code>&amp;unix[&quot;\\021%six\\012\\0&quot;]</code> <a class="header-anchor" href="#_2-unix-021-six-012-0" aria-label="Permalink to &quot;2. `&amp;unix[&quot;\\021%six\\012\\0&quot;]`&quot;">​</a></h5><p>取地址，等价于 <code>&amp;(&quot;...&quot;)[unix]</code>，即从字符串 <code>&quot; \\021%six\\012\\0&quot;</code> 的第 <code>unix</code> 个字符开始的指针。 所以这相当于给 <code>printf</code> 提供一个格式字符串。</p><hr><h5 id="_3-unix-have" tabindex="-1">3. <code>(unix)[&quot;have&quot;]</code> <a class="header-anchor" href="#_3-unix-have" aria-label="Permalink to &quot;3. `(unix)[&quot;have&quot;]`&quot;">​</a></h5><p>同理，这等价于 <code>&quot;have&quot;[unix]</code>。</p><ul><li><code>&quot;have&quot;</code> 的内容是 <code>&#39;h&#39;,&#39;a&#39;,&#39;v&#39;,&#39;e&#39;,&#39;\\0&#39;</code>。</li><li>所以 <code>&quot;have&quot;[0] = &#39;h&#39;</code>, <code>&quot;have&quot;[1] = &#39;a&#39;</code>，依此类推。</li></ul><p>因此 <code>(unix)[&quot;have&quot;]</code> 其实就是 <code>&quot;have&quot;[unix]</code>，取 <code>&quot;have&quot;</code> 中第 <code>unix</code> 个字符。</p><hr><h5 id="_4-unix-have-fun-0x60" tabindex="-1">4. <code>(unix)[&quot;have&quot;] + &quot;fun&quot; - 0x60</code> <a class="header-anchor" href="#_4-unix-have-fun-0x60" aria-label="Permalink to &quot;4. `(unix)[&quot;have&quot;] + &quot;fun&quot; - 0x60`&quot;">​</a></h5><p>这里比较绕：</p><ul><li><code>&quot;fun&quot;</code> 是字符串字面量 <code>&quot;fun\\0&quot;</code>，它会退化为指针 <code>char *</code>。</li><li><code>&quot;fun&quot;</code> 作为指针，能参与指针运算。</li><li><code>&quot;have&quot;[unix]</code> 是一个字符 (ASCII 值)。</li><li><code>&quot;have&quot;[unix] + &quot;fun&quot;</code> 就是把 <code>&quot;fun&quot;</code> 这个指针往后偏移 <code>&quot;have&quot;[unix]</code> 个字节。</li><li>然后再减去 <code>0x60</code>（十六进制 96），得到一个新指针。</li></ul><p>换句话说，这里利用字符的 ASCII 值来对字符串 <code>&quot;fun&quot;</code> 做偏移，得到一个奇怪的位置。</p><hr><h5 id="_5-printf" tabindex="-1">5. <code>printf(...)</code> <a class="header-anchor" href="#_5-printf" aria-label="Permalink to &quot;5. `printf(...)`&quot;">​</a></h5><p>最终调用 <code>printf(格式字符串, 参数)</code>。</p><ul><li>格式字符串来自 <code>&quot; \\021%six\\012\\0&quot;</code>，取决于 <code>unix</code> 的值。</li><li>参数是 <code>(unix)[&quot;have&quot;] + &quot;fun&quot; - 0x60</code>，也是个指针。</li></ul><hr><h5 id="_6-实际效果" tabindex="-1">6. 实际效果 <a class="header-anchor" href="#_6-实际效果" aria-label="Permalink to &quot;6. 实际效果&quot;">​</a></h5><p>这行代码是经典的 <strong>IOCCC（国际 C 代码混乱大赛）</strong> 风格作品。 在不同环境下，可能打印出 <strong>&quot;unix&quot;</strong> 或 <strong>&quot;fun&quot;</strong> 或其他和 <code>unix</code> 定义相关的东西。</p><p>如果你在某些老的 UNIX 系统下编译运行，会得到：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>unix</span></span></code></pre></div><hr><p>✅ <strong>总结原理</strong>：</p><ul><li>利用 <code>a[b] == b[a]</code> 迷惑读者。</li><li>利用字符串字面量既是数组又能转指针。</li><li>利用 ASCII 偏移和指针运算把 <code>printf</code> 的参数拼出特定的效果。</li><li>这是个“整蛊代码”，本质上就是打印出 “unix”。</li></ul><hr><p>要不要我帮你在 <strong>现代 GCC 环境下</strong> 写一个最简可运行的版本（带 <code>#include &lt;stdio.h&gt;</code> 和 <code>int main(void)</code>），并跑一遍结果给你？</p></div>',4)])])}const q=o(s,[["render",n]]);export{r as __pageData,q as default};
