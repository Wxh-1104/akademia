<!DOCTYPE html>
<html lang="zh-CN" dir="ltr">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>计算机教育中缺失的一课 | Akademia</title>
    <meta name="description" content="A VitePress Site">
    <meta name="generator" content="VitePress v1.6.4">
    <link rel="preload stylesheet" href="/assets/style.DVB6Vmrx.css" as="style">
    <link rel="preload stylesheet" href="/vp-icons.css" as="style">
    
    <script type="module" src="/assets/app.vxOQcGt7.js"></script>
    <link rel="preload" href="/assets/inter-roman-latin.Di8DUHzh.woff2" as="font" type="font/woff2" crossorigin="">
    <link rel="modulepreload" href="/assets/chunks/framework.BqMGeqrT.js">
    <link rel="modulepreload" href="/assets/chunks/theme.DBA76UfA.js">
    <link rel="modulepreload" href="/assets/chunks/katex.ChWnQ-fc.js">
    <link rel="modulepreload" href="/assets/chunks/dagre-5GWH7T2D.G5zXk8hW.js">
    <link rel="modulepreload" href="/assets/chunks/cose-bilkent-S5V4N54A.BSV_ciQ4.js">
    <link rel="modulepreload" href="/assets/chunks/c4Diagram-FPNF74CW.BvO8e_rl.js">
    <link rel="modulepreload" href="/assets/chunks/flowDiagram-PVAE7QVJ.CNS0M1BY.js">
    <link rel="modulepreload" href="/assets/chunks/erDiagram-AWTI2OKA.6wtgvOjy.js">
    <link rel="modulepreload" href="/assets/chunks/gitGraphDiagram-NY62KEGX.Dw-oWJfm.js">
    <link rel="modulepreload" href="/assets/chunks/ganttDiagram-OWAHRB6G.Bt9Sim-D.js">
    <link rel="modulepreload" href="/assets/chunks/infoDiagram-STP46IZ2.LyyeNQgJ.js">
    <link rel="modulepreload" href="/assets/chunks/pieDiagram-ADFJNKIX.DU7FpFDu.js">
    <link rel="modulepreload" href="/assets/chunks/quadrantDiagram-LMRXKWRM.B75FzK4S.js">
    <link rel="modulepreload" href="/assets/chunks/xychartDiagram-6GGTOJPD.CwKX7JOI.js">
    <link rel="modulepreload" href="/assets/chunks/requirementDiagram-4UW4RH46.C0mnl2dQ.js">
    <link rel="modulepreload" href="/assets/chunks/sequenceDiagram-C3RYC4MD.BQQG6a0-.js">
    <link rel="modulepreload" href="/assets/chunks/classDiagram-KNZD7YFC.D3Tu0Hos.js">
    <link rel="modulepreload" href="/assets/chunks/classDiagram-v2-RKCZMP56.D3Tu0Hos.js">
    <link rel="modulepreload" href="/assets/chunks/stateDiagram-KXAO66HF.DKba_R1O.js">
    <link rel="modulepreload" href="/assets/chunks/stateDiagram-v2-UMBNRL4Z.azUvqEYE.js">
    <link rel="modulepreload" href="/assets/chunks/journeyDiagram-BIP6EPQ6.D1xq7w34.js">
    <link rel="modulepreload" href="/assets/chunks/timeline-definition-XQNQX7LJ.BYtx_w5F.js">
    <link rel="modulepreload" href="/assets/chunks/mindmap-definition-Q6HEUPPD.C78KLRVu.js">
    <link rel="modulepreload" href="/assets/chunks/kanban-definition-6OIFK2YF.BijBt-OH.js">
    <link rel="modulepreload" href="/assets/chunks/sankeyDiagram-GR3RE2ED.D6fjsUMT.js">
    <link rel="modulepreload" href="/assets/chunks/diagram-S2PKOQOG.DLNdhLJq.js">
    <link rel="modulepreload" href="/assets/chunks/diagram-QEK2KX5R.DjNJZA02.js">
    <link rel="modulepreload" href="/assets/chunks/blockDiagram-QIGZ2CNN.CiZrbhuz.js">
    <link rel="modulepreload" href="/assets/chunks/architectureDiagram-W76B3OCA.C00aWf7E.js">
    <link rel="modulepreload" href="/assets/chunks/diagram-N5W7TBWH.BnrZW59P.js">
    <link rel="modulepreload" href="/assets/chunks/virtual_mermaid-config.DDnGl6nM.js">
    <link rel="modulepreload" href="/assets/tutorial_missing-cs-course.md.DeqhNiae.lean.js">
    <script id="check-dark-mode">(()=>{const e=localStorage.getItem("vitepress-theme-appearance")||"auto",a=window.matchMedia("(prefers-color-scheme: dark)").matches;(!e||e==="auto"?a:e==="dark")&&document.documentElement.classList.add("dark")})();</script>
    <script id="check-mac-os">document.documentElement.classList.toggle("mac",/Mac|iPhone|iPod|iPad/i.test(navigator.platform));</script>
  </head>
  <body>
    <div id="app"><div class="Layout" data-v-f60de8c8><!--[--><!--]--><!--[--><span tabindex="-1" data-v-0c9254bf></span><a href="#VPContent" class="VPSkipLink visually-hidden" data-v-0c9254bf>Skip to content</a><!--]--><!----><header class="VPNav" data-v-f60de8c8 data-v-732d1afa><div class="VPNavBar" data-v-732d1afa data-v-12308d8a><div class="wrapper" data-v-12308d8a><div class="container" data-v-12308d8a><div class="title" data-v-12308d8a><div class="VPNavBarTitle has-sidebar" data-v-12308d8a data-v-4e50a945><a class="title" href="/" data-v-4e50a945><!--[--><!--]--><!--[--><!--[--><!--[--><img class="VPImage dark logo" src="/logo-dark.svg" alt data-v-d3b2e96e><!--]--><!--[--><img class="VPImage light logo" src="/logo-light.svg" alt data-v-d3b2e96e><!--]--><!--]--><!--]--><span data-v-4e50a945>Akademia</span><!--[--><!--]--></a></div></div><div class="content" data-v-12308d8a><div class="content-body" data-v-12308d8a><!--[--><!--]--><div class="VPNavBarSearch search" data-v-12308d8a><!--[--><!----><div id="local-search"><button type="button" class="DocSearch DocSearch-Button" aria-label="Search"><span class="DocSearch-Button-Container"><span class="vp-icon DocSearch-Search-Icon"></span><span class="DocSearch-Button-Placeholder">Search</span></span><span class="DocSearch-Button-Keys"><kbd class="DocSearch-Button-Key"></kbd><kbd class="DocSearch-Button-Key">K</kbd></span></button></div><!--]--></div><nav aria-labelledby="main-nav-aria-label" class="VPNavBarMenu menu" data-v-12308d8a data-v-3be5b154><span id="main-nav-aria-label" class="visually-hidden" data-v-3be5b154> Main Navigation </span><!--[--><!--[--><a class="VPLink link VPNavBarMenuLink" href="/" tabindex="0" data-v-3be5b154 data-v-9fe3742a><!--[--><span data-v-9fe3742a>首页</span><!--]--></a><!--]--><!--[--><a class="VPLink link VPNavBarMenuLink" href="/guide/" tabindex="0" data-v-3be5b154 data-v-9fe3742a><!--[--><span data-v-9fe3742a>指引</span><!--]--></a><!--]--><!--[--><a class="VPLink link VPNavBarMenuLink" href="/schoolwork/" tabindex="0" data-v-3be5b154 data-v-9fe3742a><!--[--><span data-v-9fe3742a>课业</span><!--]--></a><!--]--><!--[--><a class="VPLink link VPNavBarMenuLink" href="/tutorial/" tabindex="0" data-v-3be5b154 data-v-9fe3742a><!--[--><span data-v-9fe3742a>教程</span><!--]--></a><!--]--><!--[--><a class="VPLink link VPNavBarMenuLink" href="/about" tabindex="0" data-v-3be5b154 data-v-9fe3742a><!--[--><span data-v-9fe3742a>关于</span><!--]--></a><!--]--><!--[--><div class="VPFlyout VPNavBarMenuGroup" data-v-3be5b154 data-v-cecc940f><button type="button" class="button" aria-haspopup="true" aria-expanded="false" data-v-cecc940f><span class="text" data-v-cecc940f><!----><span data-v-cecc940f>更多</span><span class="vpi-chevron-down text-icon" data-v-cecc940f></span></span></button><div class="menu" data-v-cecc940f><div class="VPMenu" data-v-cecc940f data-v-c527d78f><div class="items" data-v-c527d78f><!--[--><!--[--><div class="VPMenuLink" data-v-c527d78f data-v-c96126bd><a class="VPLink link" href="/playground" data-v-c96126bd><!--[--><span data-v-c96126bd>功能实验室</span><!--]--></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-c527d78f data-v-c96126bd><a class="VPLink link vp-external-link-icon" href="https://vitepress.dev/" target="_blank" rel="noreferrer" data-v-c96126bd><!--[--><span data-v-c96126bd>VitePress 官网</span><!--]--></a></div><!--]--><!--]--></div><!--[--><!--]--></div></div></div><!--]--><!--]--></nav><!----><div class="VPNavBarAppearance appearance" data-v-12308d8a data-v-440d4e1c><button class="VPSwitch VPSwitchAppearance" type="button" role="switch" title aria-checked="false" data-v-440d4e1c data-v-aab8f47e data-v-c26ff94b><span class="check" data-v-c26ff94b><span class="icon" data-v-c26ff94b><!--[--><span class="vpi-sun sun" data-v-aab8f47e></span><span class="vpi-moon moon" data-v-aab8f47e></span><!--]--></span></span></button></div><div class="VPSocialLinks VPNavBarSocialLinks social-links" data-v-12308d8a data-v-13208c4a data-v-632678ad><!--[--><a class="VPSocialLink no-icon" href="https://github.com/Wxh-1104/akademia" aria-label="github" target="_blank" rel="noopener" data-v-632678ad data-v-fc5cbb54><span class="vpi-social-github"></span></a><a class="VPSocialLink no-icon" href="https://weixin.qq.com/" aria-label="QQ" target="_blank" rel="noopener" data-v-632678ad data-v-fc5cbb54><svg role="img" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><title>QQ</title><path d="M21.395 15.035a40 40 0 0 0-.803-2.264l-1.079-2.695c.001-.032.014-.562.014-.836C19.526 4.632 17.351 0 12 0S4.474 4.632 4.474 9.241c0 .274.013.804.014.836l-1.08 2.695a39 39 0 0 0-.802 2.264c-1.021 3.283-.69 4.643-.438 4.673.54.065 2.103-2.472 2.103-2.472 0 1.469.756 3.387 2.394 4.771-.612.188-1.363.479-1.845.835-.434.32-.379.646-.301.778.343.578 5.883.369 7.482.189 1.6.18 7.14.389 7.483-.189.078-.132.132-.458-.301-.778-.483-.356-1.233-.646-1.846-.836 1.637-1.384 2.393-3.302 2.393-4.771 0 0 1.563 2.537 2.103 2.472.251-.03.581-1.39-.438-4.673"/></svg></a><!--]--></div><div class="VPFlyout VPNavBarExtra extra" data-v-12308d8a data-v-1e44e61d data-v-cecc940f><button type="button" class="button" aria-haspopup="true" aria-expanded="false" aria-label="extra navigation" data-v-cecc940f><span class="vpi-more-horizontal icon" data-v-cecc940f></span></button><div class="menu" data-v-cecc940f><div class="VPMenu" data-v-cecc940f data-v-c527d78f><!----><!--[--><!--[--><!----><div class="group" data-v-1e44e61d><div class="item appearance" data-v-1e44e61d><p class="label" data-v-1e44e61d>深浅模式</p><div class="appearance-action" data-v-1e44e61d><button class="VPSwitch VPSwitchAppearance" type="button" role="switch" title aria-checked="false" data-v-1e44e61d data-v-aab8f47e data-v-c26ff94b><span class="check" data-v-c26ff94b><span class="icon" data-v-c26ff94b><!--[--><span class="vpi-sun sun" data-v-aab8f47e></span><span class="vpi-moon moon" data-v-aab8f47e></span><!--]--></span></span></button></div></div></div><div class="group" data-v-1e44e61d><div class="item social-links" data-v-1e44e61d><div class="VPSocialLinks social-links-list" data-v-1e44e61d data-v-632678ad><!--[--><a class="VPSocialLink no-icon" href="https://github.com/Wxh-1104/akademia" aria-label="github" target="_blank" rel="noopener" data-v-632678ad data-v-fc5cbb54><span class="vpi-social-github"></span></a><a class="VPSocialLink no-icon" href="https://weixin.qq.com/" aria-label="QQ" target="_blank" rel="noopener" data-v-632678ad data-v-fc5cbb54><svg role="img" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><title>QQ</title><path d="M21.395 15.035a40 40 0 0 0-.803-2.264l-1.079-2.695c.001-.032.014-.562.014-.836C19.526 4.632 17.351 0 12 0S4.474 4.632 4.474 9.241c0 .274.013.804.014.836l-1.08 2.695a39 39 0 0 0-.802 2.264c-1.021 3.283-.69 4.643-.438 4.673.54.065 2.103-2.472 2.103-2.472 0 1.469.756 3.387 2.394 4.771-.612.188-1.363.479-1.845.835-.434.32-.379.646-.301.778.343.578 5.883.369 7.482.189 1.6.18 7.14.389 7.483-.189.078-.132.132-.458-.301-.778-.483-.356-1.233-.646-1.846-.836 1.637-1.384 2.393-3.302 2.393-4.771 0 0 1.563 2.537 2.103 2.472.251-.03.581-1.39-.438-4.673"/></svg></a><!--]--></div></div></div><!--]--><!--]--></div></div></div><!--[--><!--]--><button type="button" class="VPNavBarHamburger hamburger" aria-label="mobile navigation" aria-expanded="false" aria-controls="VPNavScreen" data-v-12308d8a data-v-bd3b020e><span class="container" data-v-bd3b020e><span class="top" data-v-bd3b020e></span><span class="middle" data-v-bd3b020e></span><span class="bottom" data-v-bd3b020e></span></span></button></div></div></div></div><div class="divider" data-v-12308d8a><div class="divider-line" data-v-12308d8a></div></div></div><!----></header><div class="VPLocalNav has-sidebar empty" data-v-f60de8c8 data-v-59d032e2><div class="container" data-v-59d032e2><button class="menu" aria-expanded="false" aria-controls="VPSidebarNav" data-v-59d032e2><span class="vpi-align-left menu-icon" data-v-59d032e2></span><span class="menu-text" data-v-59d032e2>目录</span></button><div class="VPLocalNavOutlineDropdown" style="--vp-vh:0px;" data-v-59d032e2 data-v-4092b375><button data-v-4092b375>返回顶部</button><!----></div></div></div><aside class="VPSidebar" data-v-f60de8c8 data-v-b081dc56><div class="curtain" data-v-b081dc56></div><nav class="nav" id="VPSidebarNav" aria-labelledby="sidebar-aria-label" tabindex="-1" data-v-b081dc56><span class="visually-hidden" id="sidebar-aria-label" data-v-b081dc56> Sidebar Navigation </span><!--[--><!--]--><!--[--><div class="no-transition group" data-v-ad3d29de><section class="VPSidebarItem level-0 collapsible" data-v-ad3d29de data-v-8917a4d2><div class="item" role="button" tabindex="0" data-v-8917a4d2><div class="indicator" data-v-8917a4d2></div><h2 class="text" data-v-8917a4d2>学习生活</h2><div class="caret" role="button" aria-label="toggle section" tabindex="0" data-v-8917a4d2><span class="vpi-chevron-right caret-icon" data-v-8917a4d2></span></div></div><div class="items" data-v-8917a4d2><!--[--><div class="VPSidebarItem level-1 is-link" data-v-8917a4d2 data-v-8917a4d2><div class="item" data-v-8917a4d2><div class="indicator" data-v-8917a4d2></div><a class="VPLink link link" href="/tutorial/growth" data-v-8917a4d2><!--[--><p class="text" data-v-8917a4d2>从成长到成才</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-8917a4d2 data-v-8917a4d2><div class="item" data-v-8917a4d2><div class="indicator" data-v-8917a4d2></div><a class="VPLink link link" href="/tutorial/genai" data-v-8917a4d2><!--[--><p class="text" data-v-8917a4d2>开始使用生成式人工智能</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-8917a4d2 data-v-8917a4d2><div class="item" data-v-8917a4d2><div class="indicator" data-v-8917a4d2></div><a class="VPLink link link" href="/tutorial/getting-advice-from-senior" data-v-8917a4d2><!--[--><p class="text" data-v-8917a4d2>向学长学姐请教</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-8917a4d2 data-v-8917a4d2><div class="item" data-v-8917a4d2><div class="indicator" data-v-8917a4d2></div><a class="VPLink link link" href="/tutorial/baoyan" data-v-8917a4d2><!--[--><p class="text" data-v-8917a4d2>保研那点儿事</p><!--]--></a><!----></div><!----></div><!--]--></div></section></div><div class="no-transition group" data-v-ad3d29de><section class="VPSidebarItem level-0 collapsible has-active" data-v-ad3d29de data-v-8917a4d2><div class="item" role="button" tabindex="0" data-v-8917a4d2><div class="indicator" data-v-8917a4d2></div><h2 class="text" data-v-8917a4d2>计算机进阶</h2><div class="caret" role="button" aria-label="toggle section" tabindex="0" data-v-8917a4d2><span class="vpi-chevron-right caret-icon" data-v-8917a4d2></span></div></div><div class="items" data-v-8917a4d2><!--[--><div class="VPSidebarItem level-1 is-link" data-v-8917a4d2 data-v-8917a4d2><div class="item" data-v-8917a4d2><div class="indicator" data-v-8917a4d2></div><a class="VPLink link link" href="/tutorial/cs-overview" data-v-8917a4d2><!--[--><p class="text" data-v-8917a4d2>计算机科学概览</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-8917a4d2 data-v-8917a4d2><div class="item" data-v-8917a4d2><div class="indicator" data-v-8917a4d2></div><a class="VPLink link link" href="/tutorial/cs-should-know" data-v-8917a4d2><!--[--><p class="text" data-v-8917a4d2>每个计算机科学专业的学生应该知道什么？</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-8917a4d2 data-v-8917a4d2><div class="item" data-v-8917a4d2><div class="indicator" data-v-8917a4d2></div><a class="VPLink link link" href="/tutorial/missing-cs-course" data-v-8917a4d2><!--[--><p class="text" data-v-8917a4d2>缺失的计科课程</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-8917a4d2 data-v-8917a4d2><div class="item" data-v-8917a4d2><div class="indicator" data-v-8917a4d2></div><a class="VPLink link link" href="/tutorial/python-tutorial" data-v-8917a4d2><!--[--><p class="text" data-v-8917a4d2>Python入门</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-8917a4d2 data-v-8917a4d2><div class="item" data-v-8917a4d2><div class="indicator" data-v-8917a4d2></div><a class="VPLink link link" href="/tutorial/numpy" data-v-8917a4d2><!--[--><p class="text" data-v-8917a4d2>NumPy完全入门指南</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-8917a4d2 data-v-8917a4d2><div class="item" data-v-8917a4d2><div class="indicator" data-v-8917a4d2></div><a class="VPLink link link" href="/tutorial/ee731-lecture-notes" data-v-8917a4d2><!--[--><p class="text" data-v-8917a4d2>Matrix Computations for Signal Processing翻译</p><!--]--></a><!----></div><!----></div><!--]--></div></section></div><!--]--><!--[--><!--]--></nav></aside><div class="VPContent has-sidebar" id="VPContent" data-v-f60de8c8 data-v-b3043a8b><div class="VPDoc has-sidebar has-aside" data-v-b3043a8b data-v-0e85892c><!--[--><!--]--><div class="container" data-v-0e85892c><div class="aside" data-v-0e85892c><div class="aside-curtain" data-v-0e85892c></div><div class="aside-container" data-v-0e85892c><div class="aside-content" data-v-0e85892c><div class="VPDocAside" data-v-0e85892c data-v-78098230><!--[--><!--]--><!--[--><!--]--><nav aria-labelledby="doc-outline-aria-label" class="VPDocAsideOutline" data-v-78098230 data-v-9da81cca><div class="content" data-v-9da81cca><div class="outline-marker" data-v-9da81cca></div><div aria-level="2" class="outline-title" id="doc-outline-aria-label" role="heading" data-v-9da81cca>当前页大纲</div><ul class="VPDocOutlineItem root" data-v-9da81cca data-v-c2371d72><!--[--><!--]--></ul></div></nav><!--[--><!--]--><div class="spacer" data-v-78098230></div><!--[--><!--]--><!----><!--[--><!--]--><!--[--><!--]--></div></div></div></div><div class="content" data-v-0e85892c><div class="content-container" data-v-0e85892c><!--[--><!--]--><main class="main" data-v-0e85892c><div style="position:relative;" class="vp-doc _tutorial_missing-cs-course" data-v-0e85892c><div><h1 id="计算机教育中缺失的一课" tabindex="-1">计算机教育中缺失的一课 <a class="header-anchor" href="#计算机教育中缺失的一课" aria-label="Permalink to &quot;计算机教育中缺失的一课&quot;">​</a></h1><div class="info custom-block github-alert"><p class="custom-block-title">INFO</p><p>参照 MIT 在线课程 <a href="https://missing-semester-cn.github.io/" target="_blank" rel="noreferrer">The Missing Semester of Your CS Education</a> 翻译和改编。 由 <a class="icon-link-wrapper" href="https://gemini.google.com/" target="_blank" rel="noopener noreferrer"><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" role="img" style="" width="1em" height="1em" viewBox="0 0 16 16"></svg></a>Gemini 2.5 Pro 生成，请对内容进行甄别。</p></div><h2 id="the-shell" tabindex="-1">The Shell <a class="header-anchor" href="#the-shell" aria-label="Permalink to &quot;The Shell&quot;">​</a></h2><p>本教程旨在深入讲解 Shell 的核心概念和基本用法，让你不仅知道如何使用，更能理解其工作原理。</p><h3 id="shell-是什么-——-与计算机对话的根本" tabindex="-1">Shell 是什么？—— 与计算机对话的根本 <a class="header-anchor" href="#shell-是什么-——-与计算机对话的根本" aria-label="Permalink to &quot;Shell 是什么？—— 与计算机对话的根本&quot;">​</a></h3><p>我们日常使用的图形用户界面（GUI）虽然直观，但其功能被设计者预先设定好了。你无法点击一个不存在的按钮，也无法执行一个未被编程的语音命令。</p><p>Shell 提供了一种更根本、更强大的交互方式：<strong>文本接口</strong>。它是一个命令行解释器，是你与操作系统内核沟通的桥梁。你输入文本命令，Shell 解析它们，并让操作系统执行相应的程序。</p><p>本课程将重点使用 <strong>Bash (Bourne Again SHell)</strong>，它是目前最流行、应用最广泛的 Shell 之一。</p><h3 id="shell-基础-命令与参数" tabindex="-1">Shell 基础：命令与参数 <a class="header-anchor" href="#shell-基础-命令与参数" aria-label="Permalink to &quot;Shell 基础：命令与参数&quot;">​</a></h3><p>打开终端后，你会看到一个<strong>提示符 (Prompt)</strong>，通常长这样：</p><div class="language-console vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">console</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">missing:~</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">$</span></span></code></pre></div><ul><li><code>missing</code>: 当前登录的主机名。</li><li><code>~</code>: 当前所在的目录。<code>~</code> 是主目录（Home Directory）的简写。</li><li><code>$</code>: 提示符的结束，表示当前是普通用户。如果是 <code>_</code>，则代表超级用户（root）。</li></ul><h4 id="执行程序" tabindex="-1">执行程序 <a class="header-anchor" href="#执行程序" aria-label="Permalink to &quot;执行程序&quot;">​</a></h4><p>在提示符后输入命令，就是让 Shell 执行一个程序。</p><div class="language-console vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">console</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">missing:~</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">$ date</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Fri 10 Jan 2020 11:49:31 AM EST</span></span></code></pre></div><p>这里，我们执行了名为 <code>date</code> 的程序，它打印出当前的日期和时间。</p><h4 id="传递参数" tabindex="-1">传递参数 <a class="header-anchor" href="#传递参数" aria-label="Permalink to &quot;传递参数&quot;">​</a></h4><p>大多数程序都可以接受<strong>参数 (Arguments)</strong>，以改变其行为。Shell 使用<strong>空格</strong>来分割命令和参数。</p><div class="language-console vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">console</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">missing:~</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">$ echo hello world</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">hello world</span></span></code></pre></div><p>在这个例子中：</p><ol><li><code>echo</code> 是要执行的程序。</li><li><code>hello</code>是传递给 <code>echo</code> 的第一个参数。</li><li><code>world</code> 是第二个参数。 <code>echo</code> 程序的功能就是把它接收到的所有参数打印出来。</li></ol><p><strong>处理带空格的参数</strong>：如果你的参数本身就包含空格（例如文件名 &quot;My Photos&quot;），你需要用引号或转义符来告诉 Shell 这是一个单独的参数。</p><div class="language-console vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">console</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">## 使用双引号</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">missing:~</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">$ echo </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;hello world&quot;</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">hello world</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">## 使用单引号</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">missing:~</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">$ echo </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;hello world&#39;</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">hello world</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">## 使用反斜杠 `\` 进行转义</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">missing:~</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">$ echo hello</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">\ </span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">world</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">hello world</span></span></code></pre></div><h4 id="shell-如何找到程序-path-环境变量" tabindex="-1">Shell 如何找到程序？<code>$PATH</code> 环境变量 <a class="header-anchor" href="#shell-如何找到程序-path-环境变量" aria-label="Permalink to &quot;Shell 如何找到程序？`$PATH` 环境变量&quot;">​</a></h4><p>当你输入 <code>date</code> 时，Shell 是如何知道去哪里找到并执行这个程序的呢？</p><p>答案是<strong>环境变量 <code>$PATH</code></strong>。它是一个包含多个目录路径的列表，用冒号 <code>:</code> 分隔。当你输入一个命令时，Shell 会依次在 <code>$PATH</code> 列表的这些目录中查找同名的可执行文件。</p><div class="language-console vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">console</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">## 查看 $PATH 的内容</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">missing:~</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">$ echo $PATH</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">## 使用 which 命令查看某个程序的确切路径</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">missing:~</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">$ which echo</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">/bin/echo</span></span></code></pre></div><p><code>which echo</code> 的输出 <code>/bin/echo</code> 告诉我们，<code>echo</code> 程序位于 <code>/bin</code> 目录下，而 <code>/bin</code> 正是 <code>$PATH</code> 列表中的一员。</p><p>我们也可以通过提供程序的<strong>绝对路径</strong>来绕过 <code>$PATH</code> 的搜索，直接执行它：</p><div class="language-console vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">console</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">missing:~</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">$ /bin/echo </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Directly executed&quot;</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Directly executed</span></span></code></pre></div><h3 id="在文件系统中穿梭" tabindex="-1">在文件系统中穿梭 <a class="header-anchor" href="#在文件系统中穿梭" aria-label="Permalink to &quot;在文件系统中穿梭&quot;">​</a></h3><p>文件系统是一个树状的目录结构。掌握如何在其中自由移动是 Shell 操作的基础。</p><ul><li><code>/</code>: 根目录，所有文件和目录的起点。</li><li><strong>绝对路径</strong>: 从根目录 <code>/</code> 开始的路径，例如 <code>/home/user/documents</code>。</li><li><strong>相对路径</strong>: 从当前目录开始的路径，例如 <code>../images</code>。</li></ul><h4 id="常用导航命令" tabindex="-1">常用导航命令 <a class="header-anchor" href="#常用导航命令" aria-label="Permalink to &quot;常用导航命令&quot;">​</a></h4><table tabindex="0"><thead><tr><th style="text-align:left;">命令</th><th style="text-align:left;">功能</th><th style="text-align:left;">示例</th></tr></thead><tbody><tr><td style="text-align:left;"><code>pwd</code></td><td style="text-align:left;"><strong>p</strong>rint <strong>w</strong>orking <strong>d</strong>irectory，显示当前工作目录的绝对路径。</td><td style="text-align:left;"><code>pwd</code></td></tr><tr><td style="text-align:left;"><code>cd</code></td><td style="text-align:left;"><strong>c</strong>hange <strong>d</strong>irectory，切换目录。</td><td style="text-align:left;"><code>cd /var/log</code> (切换到 <code>/var/log</code>)</td></tr><tr><td style="text-align:left;"><code>cd ..</code></td><td style="text-align:left;">切换到<strong>上级目录</strong>。</td><td style="text-align:left;"><code>cd ..</code></td></tr><tr><td style="text-align:left;"><code>cd ~</code> 或 <code>cd</code></td><td style="text-align:left;">切换到<strong>主目录</strong> (Home Directory)。</td><td style="text-align:left;"><code>cd</code></td></tr><tr><td style="text-align:left;"><code>.</code></td><td style="text-align:left;">代表<strong>当前目录</strong>。</td><td style="text-align:left;"><code>ls .</code></td></tr><tr><td style="text-align:left;"><code>..</code></td><td style="text-align:left;">代表<strong>上级目录</strong>。</td><td style="text-align:left;"><code>ls ..</code></td></tr></tbody></table><p><strong>示例：</strong></p><div class="language-console vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">console</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">## 查看当前位置</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">missing:~</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">$ pwd</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">/home/missing</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">## 切换到根目录</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">missing:~</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">$ cd /</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">missing:/</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">$ pwd</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">/</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">## 切换回主目录下的 missing 文件夹（使用相对路径）</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">missing:/</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">$ cd home/missing</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">missing:~</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">$ pwd</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">/home/missing</span></span></code></pre></div><h3 id="文件与目录操作" tabindex="-1">文件与目录操作 <a class="header-anchor" href="#文件与目录操作" aria-label="Permalink to &quot;文件与目录操作&quot;">​</a></h3><h4 id="ls-列出文件" tabindex="-1"><code>ls</code>：列出文件 <a class="header-anchor" href="#ls-列出文件" aria-label="Permalink to &quot;`ls`：列出文件&quot;">​</a></h4><p><code>ls</code> 命令用于列出目录内容。它支持非常多的选项（flags）来改变输出格式。</p><ul><li><code>ls</code>: 列出当前目录的内容。</li><li><code>ls /home</code>: 列出 <code>/home</code> 目录的内容。</li><li><code>ls -l</code>: 使用长列表格式（long listing format），显示更详细的信息。</li><li><code>ls -a</code>: 显示所有文件，包括以 <code>.</code> 开头的隐藏文件。</li><li><code>ls -t</code>: 按修改时间排序。</li><li><code>ls -lh</code>: 结合 <code>-l</code>，并以人类可读的格式显示文件大小 (e.g., K, M, G)。</li></ul><p><strong>解读 <code>ls -l</code> 的输出:</strong></p><div class="language-console vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">console</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">missing:~</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">$ ls -l /home</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">drwxr-xr-x 1 missing  users  4096 Jun 15  2019 missing</span></span></code></pre></div><p>让我们分解这行信息的含义：</p><table tabindex="0"><thead><tr><th style="text-align:left;">部分</th><th style="text-align:left;">示例</th><th style="text-align:left;">解释</th></tr></thead><tbody><tr><td style="text-align:left;"><strong>文件类型</strong></td><td style="text-align:left;"><code>d</code></td><td style="text-align:left;"><code>d</code>: 目录, <code>-</code>: 普通文件, <code>l</code>: 符号链接</td></tr><tr><td style="text-align:left;"><strong>权限</strong></td><td style="text-align:left;"><code>rwxr-xr-x</code></td><td style="text-align:left;">分为三组：<strong>用户 (owner)</strong>, <strong>用户组 (group)</strong>, <strong>其他人 (others)</strong>。 <code>r</code>: 读, <code>w</code>: 写, <code>x</code>: 执行。</td></tr><tr><td style="text-align:left;"><strong>硬链接数</strong></td><td style="text-align:left;"><code>1</code></td><td style="text-align:left;">指向此文件的硬链接数量。</td></tr><tr><td style="text-align:left;"><strong>所有者</strong></td><td style="text-align:left;"><code>missing</code></td><td style="text-align:left;">拥有此文件的用户。</td></tr><tr><td style="text-align:left;"><strong>所属组</strong></td><td style="text-align:left;"><code>users</code></td><td style="text-align:left;">拥有此文件的用户组。</td></tr><tr><td style="text-align:left;"><strong>大小</strong></td><td style="text-align:left;"><code>4096</code></td><td style="text-align:left;">文件大小（以字节为单位）。</td></tr><tr><td style="text-align:left;"><strong>修改日期</strong></td><td style="text-align:left;"><code>Jun 15 2019</code></td><td style="text-align:left;">最后修改的日期和时间。</td></tr><tr><td style="text-align:left;"><strong>文件名</strong></td><td style="text-align:left;"><code>missing</code></td><td style="text-align:left;">文件或目录的名称。</td></tr></tbody></table><h4 id="其他核心命令" tabindex="-1">其他核心命令 <a class="header-anchor" href="#其他核心命令" aria-label="Permalink to &quot;其他核心命令&quot;">​</a></h4><table tabindex="0"><thead><tr><th style="text-align:left;">命令</th><th style="text-align:left;">功能</th><th style="text-align:left;">示例</th></tr></thead><tbody><tr><td style="text-align:left;"><code>mkdir</code></td><td style="text-align:left;"><strong>m</strong>a<strong>k</strong>e <strong>dir</strong>ectory，创建新目录。</td><td style="text-align:left;"><code>mkdir new_project</code></td></tr><tr><td style="text-align:left;"><code>touch</code></td><td style="text-align:left;">创建一个空文件，或更新已存在文件的时间戳。</td><td style="text-align:left;"><code>touch README.md</code></td></tr><tr><td style="text-align:left;"><code>mv</code></td><td style="text-align:left;"><strong>m</strong>o<strong>v</strong>e，移动或重命名文件/目录。</td><td style="text-align:left;"><code>mv old.txt new.txt</code> (重命名)<br><code>mv report.pdf ./docs/</code> (移动)</td></tr><tr><td style="text-align:left;"><code>cp</code></td><td style="text-align:left;"><strong>c</strong>o<strong>p</strong>y，复制文件/目录。</td><td style="text-align:left;"><code>cp source.txt dest.txt</code> (复制文件)<br><code>cp -r source_dir/ dest_dir/</code> (递归复制目录)</td></tr><tr><td style="text-align:left;"><code>rm</code></td><td style="text-align:left;"><strong>r</strong>e<strong>m</strong>ove，删除文件。<strong>注意：此操作不可恢复！</strong></td><td style="text-align:left;"><code>rm temp.txt</code><br><code>rm -r old_project/</code> (递归删除目录)</td></tr><tr><td style="text-align:left;"><code>man</code></td><td style="text-align:left;"><strong>man</strong>ual，查看命令的帮助手册。按 <code>q</code> 退出。</td><td style="text-align:left;"><code>man ls</code></td></tr></tbody></table><h3 id="连接命令-输入-输出流与管道" tabindex="-1">连接命令：输入/输出流与管道 <a class="header-anchor" href="#连接命令-输入-输出流与管道" aria-label="Permalink to &quot;连接命令：输入/输出流与管道&quot;">​</a></h3><p>Shell 的真正威力在于将简单的工具组合起来完成复杂的任务。这是通过<strong>流 (streams)</strong> 和<strong>管道 (pipes)</strong> 实现的。</p><p>每个程序主要有两个流：</p><ul><li><strong>输入流 (stdin)</strong>: 程序读取数据的地方，默认为键盘。</li><li><strong>输出流 (stdout)</strong>: 程序写入数据的地方，默认为屏幕。</li></ul><h4 id="重定向-redirection" tabindex="-1">重定向 (Redirection) <a class="header-anchor" href="#重定向-redirection" aria-label="Permalink to &quot;重定向 (Redirection)&quot;">​</a></h4><p>我们可以改变流的默认目标，这就是<strong>重定向</strong>。</p><ul><li><p><code>&gt;</code>: <strong>重定向输出</strong>。将命令的输出写入文件，<strong>会覆盖文件原有内容</strong>。</p><div class="language-console vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">console</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">## 将 &quot;hello&quot; 写入 file.txt。如果 file.txt 已存在，其内容将被覆盖。</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">missing:~</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">$ echo </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;hello&quot;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> &gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> file.txt</span></span></code></pre></div></li><li><p><code>&gt;&gt;</code>: <strong>追加重定向输出</strong>。将命令的输出追加到文件末尾。</p><div class="language-console vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">console</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">## 在 file.txt 的末尾追加 &quot;world&quot;。</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">missing:~</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">$ echo </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;world&quot;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> &gt;&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> file.txt</span></span></code></pre></div></li><li><p><code>&lt;</code>: <strong>重定向输入</strong>。让命令从文件而不是键盘读取输入。</p><div class="language-console vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">console</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">missing:~</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">$ cat </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> file.txt</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">hello</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">world</span></span></code></pre></div></li></ul><h4 id="管道-pipes" tabindex="-1">管道 (Pipes) <a class="header-anchor" href="#管道-pipes" aria-label="Permalink to &quot;管道 (Pipes)&quot;">​</a></h4><p>管道 <code>|</code> 是 Shell 的精髓。它将一个命令的<strong>输出流 (stdout)</strong> 直接连接到另一个命令的<strong>输入流 (stdin)</strong>。</p><p><strong>示例：</strong> 假设你想找到 <code>/etc</code> 目录下所有包含 &quot;network&quot; 字符串的文件名。</p><div class="language-console vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">console</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">## 1. `ls -l /etc` 会输出 /etc 下的所有文件信息。</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">## 2. `|` 将这些信息作为 `grep` 命令的输入。</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">## 3. `grep network` 会在输入中筛选出包含 &quot;network&quot; 的行。</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">missing:~</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">$ ls -l /etc </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">|</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> grep</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> network</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">-rw-r--r-- 1 root root      841 Apr 15  2020 networks</span></span></code></pre></div><h3 id="超级用户-sudo" tabindex="-1">超级用户 <code>sudo</code> <a class="header-anchor" href="#超级用户-sudo" aria-label="Permalink to &quot;超级用户 `sudo`&quot;">​</a></h3><p>在类 Unix 系统中，<strong>root</strong> 用户拥有至高无上的权限，可以执行任何操作。为了避免误操作损坏系统，我们通常以普通用户身份工作，只在需要时临时获取 root 权限。</p><p><code>sudo</code> ( <strong>s</strong>uper <strong>u</strong>ser <strong>do</strong> ) 命令就是为此而生。它允许你以 root 身份执行单条命令。</p><div class="language-console vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">console</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">## 尝试在系统目录 /etc 下创建文件，将会失败</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">missing:~</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">$ touch /etc/test_file</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">touch: cannot touch &#39;/etc/test_file&#39;: Permission denied</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">## 使用 sudo 执行，输入你的密码后，命令成功</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">missing:~</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">$ sudo touch /etc/test_file</span></span></code></pre></div><h4 id="sudo-与重定向的陷阱" tabindex="-1"><code>sudo</code> 与重定向的陷阱 <a class="header-anchor" href="#sudo-与重定向的陷阱" aria-label="Permalink to &quot;`sudo` 与重定向的陷阱&quot;">​</a></h4><p>一个常见的误区是 <code>sudo</code> 和输出重定向 <code>&gt;</code> 的结合使用。</p><p><strong>错误示例：</strong> 假设你想向一个只有 root 才能写入的文件 <code>/sys/class/backlight/intel_backlight/brightness</code> 写入数值 <code>500</code> 来调节屏幕亮度。</p><div class="language-console vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">console</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">## 这个命令会失败！</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">missing:~</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">$ sudo echo 500 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> /sys/class/backlight/intel_backlight/brightness</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">bash: /sys/class/backlight/intel_backlight/brightness: Permission denied</span></span></code></pre></div><p><strong>为什么会失败？</strong> 重定向符号 <code>&gt;</code> 是由你<strong>当前的 Shell</strong> (以普通用户身份运行) 来解析的，而不是由 <code>sudo</code> 之后的 <code>echo</code> 命令。因此，Shell 在执行命令前，会先尝试以<strong>普通用户权限</strong>去打开并清空 <code>brightness</code> 文件，这个操作自然会被拒绝。</p><p><strong>正确做法：使用 <code>tee</code> 命令</strong><code>tee</code> 命令会从其输入流中读取内容，并将其同时写入到输出流和指定的文件中。我们可以让 <code>tee</code> 在 <code>sudo</code> 权限下运行。</p><div class="language-console vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">console</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">## `echo 500` 的输出通过管道传给 `sudo tee`</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">## `tee` 命令在 root 权限下运行，因此有权限写入 brightness 文件</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">missing:~</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">$ echo 500 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">|</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> sudo</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> tee</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> /sys/class/backlight/intel_backlight/brightness</span></span></code></pre></div><h3 id="课后练习" tabindex="-1">课后练习 <a class="header-anchor" href="#课后练习" aria-label="Permalink to &quot;课后练习&quot;">​</a></h3><p>现在，动手实践是巩固知识的最佳方式。请尝试完成以下任务：</p><ol><li><p><strong>环境检查</strong>: 打开你的终端，执行 <code>echo $SHELL</code>，确保你使用的是 Bash 或 Zsh。</p></li><li><p><strong>创建目录</strong>: 在 <code>/tmp</code> 目录下，创建一个名为 <code>missing</code> 的新目录。</p></li><li><p><strong>学习 <code>touch</code></strong>: 使用 <code>man touch</code> 命令阅读 <code>touch</code> 的手册。</p></li><li><p><strong>创建文件</strong>: 在 <code>/tmp/missing</code> 目录中，创建一个名为 <code>semester</code> 的空文件。</p></li><li><p><strong>写入脚本</strong>: 使用 <code>echo</code> 和重定向，将以下两行内容写入 <code>semester</code> 文件。</p><ul><li><code>#!/bin/sh</code></li><li><code>curl --head --silent https://missing.csail.mit.edu</code></li></ul><p><strong>提示</strong>: 由于 <code>!</code> 在 Bash 中有特殊含义，直接使用 <code>echo &quot;...&quot;</code> 可能会遇到问题。尝试使用单引号 <code>&#39;...&#39;</code> 来写入第一行。</p></li><li><p><strong>尝试执行</strong>: 在终端中输入 <code>./semester</code> 并回车，尝试执行它。你会看到一个 &quot;Permission denied&quot; 的错误。使用 <code>ls -l semester</code> 查看它的权限，理解为什么它不能被执行。</p></li><li><p><strong>学习 <code>chmod</code></strong>: 阅读 <code>chmod</code> 的手册 (<code>man chmod</code>)。</p></li><li><p><strong>添加权限</strong>: 使用 <code>chmod +x semester</code> 命令为文件添加执行权限。再次执行 <code>./semester</code>，观察它是否成功运行。</p></li><li><p><strong>组合命令</strong>: 使用管道 <code>|</code> 和重定向 <code>&gt;</code>，将 <code>semester</code> 脚本输出内容中包含 <code>last-modified</code> 的那一行，保存到你的主目录（<code>~</code>）下的 <code>last-modified.txt</code> 文件中。</p></li><li><p><strong>系统探索 (Linux 用户)</strong>: 编写一条命令，从 <code>/sys</code> 目录中找到并显示你笔记本的电池电量信息（通常在 <code>/sys/class/power_supply/</code> 下的某个文件里）。</p></li></ol><h2 id="shell-工具和脚本" tabindex="-1">Shell 工具和脚本 <a class="header-anchor" href="#shell-工具和脚本" aria-label="Permalink to &quot;Shell 工具和脚本&quot;">​</a></h2><h3 id="shell-脚本入门" tabindex="-1">Shell 脚本入门 <a class="header-anchor" href="#shell-脚本入门" aria-label="Permalink to &quot;Shell 脚本入门&quot;">​</a></h3><p>我们已经学会了如何单独执行命令和使用管道 <code>|</code> 连接它们。但要实现更复杂的自动化任务，我们需要编写<strong>脚本 (Script)</strong>。</p><p>Shell 脚本的优势在于，它为命令行操作（如创建命令管道、读写文件、获取输入）提供了原生的、简洁的支持，这比通用的脚本语言（如 Python）更直接。</p><h4 id="变量" tabindex="-1">变量 <a class="header-anchor" href="#变量" aria-label="Permalink to &quot;变量&quot;">​</a></h4><p>在 Bash 中，变量赋值的语法非常严格，<strong>等号两边不能有空格</strong>。</p><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">## 正确的赋值</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">foo</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">bar</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">## 错误的赋值 (会被解析为：执行 `foo` 命令，参数为 `=` 和 `bar`)</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">foo</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> =</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> bar</span></span></code></pre></div><p>使用 <code>$</code> 符号来访问变量的值。</p><p><strong>单引号 vs. 双引号</strong></p><ul><li><strong>单引号 (<code>&#39;</code>)</strong>: 定义<strong>原义字符串 (Literal String)</strong>。其中的任何字符（包括 <code>$</code>）都会被视为普通字符，变量不会被展开。</li><li><strong>双引号 (<code>&quot;</code>)</strong>: 定义<strong>解释字符串 (Interpreted String)</strong>。其中的变量会被替换为其对应的值。</li></ul><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">foo</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;bar&quot;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">## 双引号会进行变量替换</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">echo</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;The value of foo is </span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">$foo</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">## 输出: The value of foo is bar</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">## 单引号不进行变量替换</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">echo</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;The value of foo is $foo&#39;</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">## 输出: The value of foo is $foo</span></span></code></pre></div><h4 id="shell-中的特殊变量" tabindex="-1">Shell 中的特殊变量 <a class="header-anchor" href="#shell-中的特殊变量" aria-label="Permalink to &quot;Shell 中的特殊变量&quot;">​</a></h4><p>Bash 提供了一系列特殊的内置变量，用于访问脚本参数、执行状态等信息。这些变量是编写健壮脚本的关键。</p><table tabindex="0"><thead><tr><th style="text-align:left;">变量</th><th style="text-align:left;">解释</th><th style="text-align:left;">示例</th></tr></thead><tbody><tr><td style="text-align:left;"><code>$0</code></td><td style="text-align:left;"><strong>脚本本身的名称</strong>。</td><td style="text-align:left;"></td></tr><tr><td style="text-align:left;"><code>$1</code>, <code>$2</code>...<code>$9</code></td><td style="text-align:left;"><strong>位置参数</strong>。<code>$1</code> 是第一个参数，<code>$2</code> 是第二个，以此类推。</td><td style="text-align:left;"></td></tr><tr><td style="text-align:left;"><code>$@</code></td><td style="text-align:left;"><strong>所有参数</strong>。将每个参数视为一个独立的字符串。这是最常用的参数变量。</td><td style="text-align:left;"><code>for arg in &quot;$@&quot;</code></td></tr><tr><td style="text-align:left;"><code>$#</code></td><td style="text-align:left;"><strong>参数的个数</strong>。</td><td style="text-align:left;"><code>if [ $## -lt 2 ]</code></td></tr><tr><td style="text-align:left;"><code>$?</code></td><td style="text-align:left;"><strong>上一个命令的退出状态码 (Exit Code)</strong>。<code>0</code> 表示成功，非 <code>0</code> 表示失败。</td><td style="text-align:left;"><code>grep &quot;foo&quot; file.txt; echo $?</code></td></tr><tr><td style="text-align:left;"><code>$$</code></td><td style="text-align:left;"><strong>当前脚本的进程 ID (PID)</strong>。</td><td style="text-align:left;"><code>echo &quot;My PID is $$&quot;</code></td></tr><tr><td style="text-align:left;"><code>!!</code></td><td style="text-align:left;"><strong>上一条完整的命令</strong>，包括其参数。</td><td style="text-align:left;"><code>apt install vim</code> (失败) -&gt; <code>sudo !!</code> (以 sudo 再次执行)</td></tr><tr><td style="text-align:left;"><code>$_</code></td><td style="text-align:left;"><strong>上一条命令的最后一个参数</strong>。</td><td style="text-align:left;"><code>mkdir my_dir; cd $_</code></td></tr></tbody></table><h4 id="函数" tabindex="-1">函数 <a class="header-anchor" href="#函数" aria-label="Permalink to &quot;函数&quot;">​</a></h4><p>函数用于将一系列命令组合成一个可复用的代码块，让你的脚本更加模块化。</p><p><strong>定义函数的两种语法：</strong></p><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">## 语法一 (推荐)</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">my_func</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    ## 函数体</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    echo</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;Hello from function!&quot;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">## 语法二</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> another_func</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    ## 函数体</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    echo</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;Hello again!&quot;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p><strong>函数参数：</strong> 函数内部使用 <code>$1</code>, <code>$2</code>, <code>$@</code> 等特殊变量来接收传递给它的参数，用法与脚本参数完全相同。</p><p><strong>示例：一个创建并进入目录的函数 <code>mcd</code></strong></p><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">## 创建一个目录，并立即 cd 进去</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">mcd</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    mkdir</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -p</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">$1</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    cd</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">$1</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><ul><li><code>mkdir -p</code>: <code>-p</code> 选项确保即使父目录不存在也能成功创建。</li><li><code>&quot;$1&quot;</code>: <strong>始终用双引号包裹参数变量</strong>。这是一个至关重要的好习惯，可以防止在参数包含空格或特殊字符时出现问题。</li></ul><h4 id="控制流-if-语句和逻辑操作符" tabindex="-1">控制流：<code>if</code> 语句和逻辑操作符 <a class="header-anchor" href="#控制流-if-语句和逻辑操作符" aria-label="Permalink to &quot;控制流：`if` 语句和逻辑操作符&quot;">​</a></h4><h5 id="退出状态码与逻辑判断" tabindex="-1"><strong>退出状态码与逻辑判断</strong> <a class="header-anchor" href="#退出状态码与逻辑判断" aria-label="Permalink to &quot;**退出状态码与逻辑判断**&quot;">​</a></h5><p>在 Shell 中，命令的成功或失败是通过<strong>退出状态码 (<code>$?</code>)</strong> 来判断的。</p><ul><li><code>0</code>: 成功</li><li>非 <code>0</code>: 失败</li></ul><p><code>&amp;&amp;</code> (与) 和 <code>||</code> (或) 这两个操作符会根据前一个命令的退出状态码来决定是否执行下一个命令。</p><ul><li><code>command1 &amp;&amp; command2</code>: <strong>只有当 <code>command1</code> 成功时</strong>，才会执行 <code>command2</code>。</li><li><code>command1 || command2</code>: <strong>只有当 <code>command1</code> 失败时</strong>，才会执行 <code>command2</code>。</li></ul><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">## 如果 `mkdir` 成功，则执行 `echo`</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">mkdir</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> my_dir</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> &amp;&amp; </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">echo</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;Directory created successfully&quot;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">## 如果 `grep` 失败 (没找到)，则执行 `echo`</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">grep</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;non_existent_pattern&quot;</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> file.txt</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> ||</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> echo</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;Pattern not found&quot;</span></span></code></pre></div><h5 id="if-语句" tabindex="-1"><strong><code>if</code> 语句</strong> <a class="header-anchor" href="#if-语句" aria-label="Permalink to &quot;**`if` 语句**&quot;">​</a></h5><p>使用 <code>if</code> 语句可以构建更复杂的条件逻辑。</p><p><strong>基本语法：</strong></p><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> [[ condition ]]; </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">then</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    ## ... commands to execute if condition is true ...</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">elif</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> [[ another_condition ]]; </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">then</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    ## ... commands to execute if another_condition is true ...</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">else</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    ## ... commands to execute if no conditions are true ...</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">fi</span></span></code></pre></div><p><strong>关键点：</strong></p><ul><li>使用<strong>双方括号 <code>[[ ... ]]</code></strong> 进行条件测试。它比单方括号 <code>[ ... ]</code> 更健壮、更安全，错误更少。</li><li><code>[[</code> 和 <code>]]</code> 的两边必须有空格。</li><li><code>then</code> 必须单独占一行，或者用分号 <code>;</code> 与条件隔开：<code>if [[ ... ]]; then</code></li></ul><p><strong>常用的条件测试操作符：</strong></p><table tabindex="0"><thead><tr><th style="text-align:left;">操作符</th><th style="text-align:left;">含义</th></tr></thead><tbody><tr><td style="text-align:left;"><code>-f file</code></td><td style="text-align:left;">如果 <code>file</code> 是一个文件，则为真。</td></tr><tr><td style="text-align:left;"><code>-d dir</code></td><td style="text-align:left;">如果 <code>dir</code> 是一个目录，则为真。</td></tr><tr><td style="text-align:left;"><code>-e path</code></td><td style="text-align:left;">如果 <code>path</code> 存在，则为真。</td></tr><tr><td style="text-align:left;"><code>-z string</code></td><td style="text-align:left;">如果 <code>string</code> 为空，则为真。</td></tr><tr><td style="text-align:left;"><code>-n string</code></td><td style="text-align:left;">如果 <code>string</code> 不为空，则为真。</td></tr><tr><td style="text-align:left;"><code>str1 == str2</code></td><td style="text-align:left;">如果两个字符串相等，则为真。</td></tr><tr><td style="text-align:left;"><code>str1 != str2</code></td><td style="text-align:left;">如果两个字符串不相等，则为真。</td></tr><tr><td style="text-align:left;"><code>num1 -eq num2</code></td><td style="text-align:left;">如果两个数字相等 (equal)，则为真。</td></tr><tr><td style="text-align:left;"><code>num1 -ne num2</code></td><td style="text-align:left;">不相等 (not equal)</td></tr><tr><td style="text-align:left;"><code>num1 -lt num2</code></td><td style="text-align:left;">小于 (less than)</td></tr><tr><td style="text-align:left;"><code>num1 -gt num2</code></td><td style="text-align:left;">大于 (greater than)</td></tr><tr><td style="text-align:left;"><code>num1 -le num2</code></td><td style="text-align:left;">小于等于 (less or equal)</td></tr><tr><td style="text-align:left;"><code>num1 -ge num2</code></td><td style="text-align:left;">大于等于 (greater or equal)</td></tr></tbody></table><h4 id="命令替换" tabindex="-1">命令替换 <a class="header-anchor" href="#命令替换" aria-label="Permalink to &quot;命令替换&quot;">​</a></h4><p><strong>命令替换</strong> <code>$( ... )</code> 允许你将一个命令的输出结果捕获并赋值给一个变量，或者作为另一个命令的一部分。</p><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">## 获取当前日期并赋值给变量</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">current_date</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">$(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">date</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> +%Y-%m-%d</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">echo</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;Today is </span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">$current_date</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">## 在 for 循环中使用命令替换</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">echo</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;Listing all .txt files:&quot;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> file </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">in</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> $(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">ls</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> *</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">.txt</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">); </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">do</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    echo</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;  - </span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">$file</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">done</span></span></code></pre></div><h4 id="shell-通配-globbing" tabindex="-1">Shell 通配 (Globbing) <a class="header-anchor" href="#shell-通配-globbing" aria-label="Permalink to &quot;Shell 通配 (Globbing)&quot;">​</a></h4><p>Globbing 是 Shell 的一种模式匹配功能，用于匹配文件名。</p><ul><li><code>*</code>: 匹配<strong>任意数量</strong>的任意字符。 <ul><li><code>*.log</code>: 匹配所有以 <code>.log</code> 结尾的文件。</li></ul></li><li><code>?</code>: 匹配<strong>单个</strong>任意字符。 <ul><li><code>image_?.png</code>: 匹配 <code>image_1.png</code>, <code>image_A.png</code> 但不匹配 <code>image_10.png</code>。</li></ul></li><li><code>{}</code>: <strong>花括号扩展</strong>。用于生成一系列字符串。 <ul><li><code>mv image.{jpg,jpeg}</code> 会被 Shell 扩展为 <code>mv image.jpg image.jpeg</code>。</li><li><code>touch report-{2022,2023,2024}.md</code> 会创建三个文件。</li><li><code>touch {foo,bar}/{a..d}.txt</code> 会创建 <code>foo/a.txt</code>, <code>foo/b.txt</code>... <code>bar/d.txt</code>。</li></ul></li></ul><h3 id="强大的-shell-工具" tabindex="-1">强大的 Shell 工具 <a class="header-anchor" href="#强大的-shell-工具" aria-label="Permalink to &quot;强大的 Shell 工具&quot;">​</a></h3><h4 id="查找文件" tabindex="-1">查找文件 <a class="header-anchor" href="#查找文件" aria-label="Permalink to &quot;查找文件&quot;">​</a></h4><h5 id="find-精确而强大的传统工具" tabindex="-1"><code>find</code>: 精确而强大的传统工具 <a class="header-anchor" href="#find-精确而强大的传统工具" aria-label="Permalink to &quot;`find`: 精确而强大的传统工具&quot;">​</a></h5><p><code>find</code> 是一个功能极其丰富的搜索工具，它会递归地搜索指定目录下的文件，并可以根据名称、类型、大小、修改时间等多种条件进行过滤。</p><p><code>find [path] [expression]</code></p><p><strong>常用表达式：</strong></p><table tabindex="0"><thead><tr><th style="text-align:left;">表达式</th><th style="text-align:left;">功能</th></tr></thead><tbody><tr><td style="text-align:left;"><code>-name &quot;pattern&quot;</code></td><td style="text-align:left;">按文件名模式查找（区分大小写）。</td></tr><tr><td style="text-align:left;"><code>-iname &quot;pattern&quot;</code></td><td style="text-align:left;">按文件名模式查找（不区分大小写）。</td></tr><tr><td style="text-align:left;"><code>-type f</code></td><td style="text-align:left;">查找普通文件。</td></tr><tr><td style="text-align:left;"><code>-type d</code></td><td style="text-align:left;">查找目录。</td></tr><tr><td style="text-align:left;"><code>-mtime -N</code></td><td style="text-align:left;">查找 N 天内修改过的文件。</td></tr><tr><td style="text-align:left;"><code>-mtime +N</code></td><td style="text-align:left;">查找 N 天前修改过的文件。</td></tr><tr><td style="text-align:left;"><code>-size +10M</code></td><td style="text-align:left;">查找大于 10MB 的文件。</td></tr><tr><td style="text-align:left;"><code>-size -1G</code></td><td style="text-align:left;">查找小于 1GB 的文件。</td></tr></tbody></table><p><strong><code>find</code> 的 <code>-exec</code> 动作：</strong><code>-exec</code> 允许你对 <code>find</code> 找到的每一个结果执行一个命令。</p><ul><li><code>{}</code>: 代表 <code>find</code> 找到的当前文件。</li><li><code>;</code>: 是 <code>-exec</code> 命令的结束符，需要用 <code>\</code> 转义。</li></ul><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">## 查找所有 .tmp 文件并删除它们</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">find</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> .</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -name</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;*.tmp&quot;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -type</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> f</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -exec</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> rm</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> {}</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> \;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">## 将所有 .jpeg 文件重命名为 .jpg</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">find</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> .</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -name</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;*.jpeg&quot;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -type</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> f</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -exec</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> mv</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> {}</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> {}.jpg</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> \;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  ## 这会变成 a.jpeg.jpg，需要更复杂的处理</span></span></code></pre></div><h5 id="fd-简单、快速、友好的替代品" tabindex="-1"><code>fd</code>: 简单、快速、友好的替代品 <a class="header-anchor" href="#fd-简单、快速、友好的替代品" aria-label="Permalink to &quot;`fd`: 简单、快速、友好的替代品&quot;">​</a></h5><p><code>find</code> 的语法有时会比较繁琐。<code>fd</code> 是一个现代化的替代品，它更快、更直观，并提供了合理的默认设置（如自动忽略 <code>.gitignore</code> 中的文件，默认使用正则表达式）。</p><table tabindex="0"><thead><tr><th style="text-align:left;"><code>find</code> 命令</th><th style="text-align:left;"><code>fd</code> 命令</th></tr></thead><tbody><tr><td style="text-align:left;"><code>find . -name &quot;pattern&quot;</code></td><td style="text-align:left;"><code>fd pattern</code></td></tr><tr><td style="text-align:left;"><code>find . -iname &quot;pattern&quot;</code></td><td style="text-align:left;"><code>fd -i pattern</code></td></tr><tr><td style="text-align:left;"><code>find . -type f -name &quot;*.py&quot;</code></td><td style="text-align:left;"><code>fd -e py</code></td></tr></tbody></table><h4 id="查找文件内容-grep-及其替代品" tabindex="-1">查找文件内容 (<code>grep</code> 及其替代品) <a class="header-anchor" href="#查找文件内容-grep-及其替代品" aria-label="Permalink to &quot;查找文件内容 (`grep` 及其替代品)&quot;">​</a></h4><h5 id="grep-内容搜索的瑞士军刀" tabindex="-1"><code>grep</code>: 内容搜索的瑞士军刀 <a class="header-anchor" href="#grep-内容搜索的瑞士军刀" aria-label="Permalink to &quot;`grep`: 内容搜索的瑞士军刀&quot;">​</a></h5><p><code>grep</code> 用于在文件或标准输入中搜索匹配指定模式的行。</p><p><strong>常用选项：</strong></p><table tabindex="0"><thead><tr><th style="text-align:left;">选项</th><th style="text-align:left;">功能</th></tr></thead><tbody><tr><td style="text-align:left;"><code>-i</code></td><td style="text-align:left;"><strong>i</strong>gnore-case，忽略大小写。</td></tr><tr><td style="text-align:left;"><code>-r</code> 或 <code>-R</code></td><td style="text-align:left;"><strong>r</strong>ecursive，递归搜索子目录。</td></tr><tr><td style="text-align:left;"><code>-v</code></td><td style="text-align:left;">in<strong>v</strong>ert-match，反向选择，即打印不匹配的行。</td></tr><tr><td style="text-align:left;"><code>-C N</code></td><td style="text-align:left;"><strong>C</strong>ontext，打印匹配行及其<strong>前后各 N 行</strong>的上下文。</td></tr><tr><td style="text-align:left;"><code>-l</code></td><td style="text-align:left;">files-with-matches，只打印包含匹配项的文件名。</td></tr></tbody></table><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">## 在所有 .py 文件中递归搜索 &quot;import requests&quot;，不区分大小写</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">grep</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -ir</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;import requests&quot;</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> .</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> --include=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;*.py&quot;</span></span></code></pre></div><h5 id="rg-ripgrep-grep-的超高速替代品" tabindex="-1"><code>rg</code> (ripgrep): <code>grep</code> 的超高速替代品 <a class="header-anchor" href="#rg-ripgrep-grep-的超高速替代品" aria-label="Permalink to &quot;`rg` (ripgrep): `grep` 的超高速替代品&quot;">​</a></h5><p>与 <code>fd</code> 类似，<code>rg</code> (ripgrep) 是 <code>grep</code> 的一个现代替代品。它非常快，并且默认行为很智能（例如，自动忽略二进制文件和 <code>.gitignore</code> 中的文件）。</p><table tabindex="0"><thead><tr><th style="text-align:left;"><code>grep</code> 命令</th><th style="text-align:left;"><code>rg</code> 命令</th></tr></thead><tbody><tr><td style="text-align:left;"><code>grep -ir &quot;pattern&quot; .</code></td><td style="text-align:left;"><code>rg -i &quot;pattern&quot;</code></td></tr><tr><td style="text-align:left;"><code>grep -irl &quot;pattern&quot; .</code></td><td style="text-align:left;"><code>rg -il &quot;pattern&quot;</code></td></tr><tr><td style="text-align:left;"><code>grep -v &quot;pattern&quot; file.txt</code></td><td style="text-align:left;"><code>rg -v &quot;pattern&quot; file.txt</code></td></tr><tr><td style="text-align:left;"></td><td style="text-align:left;"><code>rg -t py &quot;pattern&quot;</code> (只在 python 文件中搜索)</td></tr></tbody></table><h4 id="历史命令的查找与补全" tabindex="-1">历史命令的查找与补全 <a class="header-anchor" href="#历史命令的查找与补全" aria-label="Permalink to &quot;历史命令的查找与补全&quot;">​</a></h4><ul><li><strong><code>history</code></strong>: 显示你执行过的所有命令的列表。 <ul><li><code>history | grep docker</code>: 搜索历史记录中所有包含 &quot;docker&quot; 的命令。</li></ul></li><li><strong><code>Ctrl+R</code></strong>: <strong>反向搜索</strong>。按下 <code>Ctrl+R</code> 后，开始输入你记得的命令片段，Shell 会实时显示最近的匹配项。持续按 <code>Ctrl+R</code> 会在所有匹配项之间循环。</li><li><strong><code>fzf</code> (Fuzzy Finder)</strong>: 这是一个模糊查找工具，可以极大地增强 <code>Ctrl+R</code> 的体验，提供一个交互式的、可滚动的历史列表。</li><li><strong>zsh-autosuggestions (Zsh 插件)</strong>: 它会根据你的历史记录，在你输入时以灰色显示一个可能的命令补全建议。按 → (右方向键) 即可采纳。</li></ul><h4 id="xargs-连接命令的桥梁" tabindex="-1"><code>xargs</code>: 连接命令的桥梁 <a class="header-anchor" href="#xargs-连接命令的桥梁" aria-label="Permalink to &quot;`xargs`: 连接命令的桥梁&quot;">​</a></h4><p>管道 <code>|</code> 将前一个命令的<strong>标准输出</strong>连接到后一个命令的<strong>标准输入</strong>。但有些命令（如 <code>rm</code>, <code>cp</code>, <code>mkdir</code>）并不从标准输入读取数据，而是期望从<strong>命令行参数</strong>中获取文件名。</p><p><code>xargs</code> 的作用就是一座桥梁：它从标准输入读取数据（通常是文件名列表），然后将这些数据作为参数传递给它后面的命令。</p><p><strong>场景：查找所有 <code>.log</code> 文件并压缩它们</strong></p><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">## 1. 找到所有 .log 文件，并将列表通过管道传给 xargs</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">## 2. xargs 读取文件名列表，然后将它们作为参数传递给 `tar` 命令</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">find</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> .</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -name</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;*.log&quot;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> |</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> xargs</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> tar</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -czvf</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> logs.tar.gz</span></span></code></pre></div><p><strong>处理带空格的文件名</strong></p><p>如果文件名包含空格，简单的 <code>| xargs</code> 会出错。安全的做法是让 <code>find</code> 输出以 NULL 字符 (<code>\0</code>) 分隔的文件列表，并告诉 <code>xargs</code> 以同样的方式解析。</p><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">find</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> .</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -name</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;*.log&quot;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -print0</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> |</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> xargs</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -0</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> tar</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -czvf</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> logs.tar.gz</span></span></code></pre></div><h3 id="课后练习-1" tabindex="-1">课后练习 <a class="header-anchor" href="#课后练习-1" aria-label="Permalink to &quot;课后练习&quot;">​</a></h3><ol><li><strong><code>ls</code> 的高级用法</strong>: <ul><li>阅读 <code>man ls</code>。</li><li>编写一条 <code>ls</code> 命令，使其能够： <ol><li>列出所有文件，包括隐藏文件 (<code>.file</code>)。</li><li>以人类可读的格式显示文件大小 (e.g., <code>1K</code>, <code>234M</code>, <code>2G</code>)。</li><li>按最近修改时间排序。</li><li>输出结果带有颜色。</li></ol></li></ul></li><li><strong><code>marco</code> 和 <code>polo</code></strong>: <ul><li>编写两个 Bash 函数，<code>marco</code> 和 <code>polo</code>。</li><li>执行 <code>marco</code> 时，它应该保存当前的目录位置。</li><li>执行 <code>polo</code> 时，它应该立即 <code>cd</code> 回到你执行 <code>marco</code> 时的那个目录。</li></ul></li><li><strong>循环调试</strong>: <ul><li>有一个偶尔会出错的脚本（见课程原文）。</li><li>编写一个 Bash 脚本，循环执行这个 &quot;不稳定&quot; 的脚本，直到它出错为止。</li><li>当出错时，将它的标准输出和标准错误都保存到一个日志文件中。</li><li>（加分项）在脚本结束时，报告它在失败前成功运行了多少次。</li></ul></li><li><strong><code>find</code> 与 <code>xargs</code></strong>: <ul><li>编写一条命令，递归地查找当前目录及子目录下的所有 <code>.html</code> 文件，并将它们打包成一个名为 <code>archive.zip</code> 的压缩文件。</li><li>你的命令必须能正确处理带空格的文件名。</li></ul></li><li><strong>(进阶) 查找最新文件</strong>: <ul><li>编写一个命令或脚本，可以递归地在目录中找到那个<strong>最后被修改</strong>的文件。</li><li>（更进一步）你能否让它按修改时间倒序列出所有文件吗？</li></ul></li></ol><h2 id="编辑器-vim" tabindex="-1">编辑器 (Vim) <a class="header-anchor" href="#编辑器-vim" aria-label="Permalink to &quot;编辑器 (Vim)&quot;">​</a></h2><h3 id="为什么程序员需要一个-特别-的编辑器" tabindex="-1">为什么程序员需要一个“特别”的编辑器？ <a class="header-anchor" href="#为什么程序员需要一个-特别-的编辑器" aria-label="Permalink to &quot;为什么程序员需要一个“特别”的编辑器？&quot;">​</a></h3><p>编程和普通写作有本质区别。编程时，我们花费大量时间在阅读、跳转、修改代码片段，而不是像写文章那样进行大段的连续输入。因此，为编程设计的<strong>代码编辑器</strong>和为写作设计的<strong>文本编辑器</strong>（如 Word）是两种截然不同的工具。</p><p>掌握一个强大的代码编辑器，是一项高回报的投资。学习曲线可能如下：</p><ul><li><strong>最初2小时</strong>：学习打开、编辑、保存、退出等基本操作，你会觉得效率比以前低。</li><li><strong>累计20小时</strong>：你的编辑速度将追平甚至超过使用旧编辑器的你。</li><li><strong>此后</strong>：随着肌肉记忆的形成和高级技巧的掌握，效率将大大提升。Vim 的学习永无止境，学的越多，效率越高。</li></ul><h3 id="vim-的哲学-为何如此与众不同" tabindex="-1">Vim 的哲学：为何如此与众不同？ <a class="header-anchor" href="#vim-的哲学-为何如此与众不同" aria-label="Permalink to &quot;Vim 的哲学：为何如此与众不同？&quot;">​</a></h3><p>Vim (Vi IMproved) 是一个历史悠久、久经考验的编辑器。它的核心设计哲学基于一个关键洞察：<strong>程序员花费在移动、阅读和修改上的时间远多于纯粹的输入</strong>。</p><p>为此，Vim 创造了几个核心理念：</p><ol><li><strong>多模态编辑 (Modal Editing)</strong>：Vim 有不同的“模式”来处理不同的任务。在“插入模式”下打字，在“正常模式”下高效移动和修改。这避免了复杂的快捷键组合（比如 <code>Ctrl+Shift+Alt+P</code>）。</li><li><strong>告别鼠标 (Mouse-Free Navigation)</strong>：鼠标会打断你的心流，因为它需要你将手从键盘移开。Vim 的所有操作都可以通过键盘完成，甚至它鼓励你放弃方向键，因为 <code>hjkl</code> 键就在你的指尖。</li><li><strong>像语言一样操作 (Interface as a Language)</strong>：Vim 的操作是可组合的。一个<strong>动词</strong>（操作，如 <code>d</code> 代表删除）可以跟一个<strong>名词</strong>（移动范围，如 <code>w</code> 代表一个单词）组合成一个强大的命令（<code>dw</code> 删除一个单词）。</li></ol><h3 id="核心概念-vim-的模式" tabindex="-1">核心概念：Vim 的模式 <a class="header-anchor" href="#核心概念-vim-的模式" aria-label="Permalink to &quot;核心概念：Vim 的模式&quot;">​</a></h3><p>Vim 的精髓在于其多种模式，不同的模式下，相同的按键有不同的含义。</p><ul><li><p><strong>正常模式 (Normal Mode)</strong>：</p><ul><li><strong>这是 Vim 的默认和核心模式</strong>。你大部分时间都应该待在这里。</li><li>此模式下，所有按键都是功能键，用于导航、删除、复制、粘贴等。</li><li><strong>如何进入</strong>：启动 Vim 时默认进入。任何其他模式下按 <code>&lt;ESC&gt;</code> 键即可返回正常模式。</li></ul></li><li><p><strong>插入模式 (Insert Mode)</strong>：</p><ul><li>此模式下，Vim 就像一个普通的文本编辑器，你输入的字符会直接显示在屏幕上。</li><li><strong>如何进入</strong>：在正常模式下按 <code>i</code> (insert) 键。左下角会显示 <code>-- INSERT --</code>。</li><li><strong>如何退出</strong>：按 <code>&lt;ESC&gt;</code> 返回正常模式。</li></ul></li><li><p><strong>命令模式 (Command-Line Mode)</strong>：</p><ul><li>用于执行保存、退出、搜索、替换、显示行号等“编辑器级别”的命令。</li><li><strong>如何进入</strong>：在正常模式下按 <code>:</code> 键，光标会跳到底部命令行。</li><li><strong>如何退出</strong>：命令执行完后会自动返回正常模式，也可以按 <code>&lt;ESC&gt;</code>。</li></ul></li><li><p><strong>可视模式 (Visual Mode)</strong>：</p><ul><li>用于选择文本块，类似于用鼠标拖拽高亮。</li><li><strong>如何进入</strong>：在正常模式下按 <code>v</code> (字符选择)、<code>V</code> (行选择) 或 <code>Ctrl+v</code> (块选择)。</li><li><strong>如何退出</strong>：按 <code>&lt;ESC&gt;</code>。</li></ul></li></ul><blockquote><p><strong>高手提示</strong>：<code>&lt;ESC&gt;</code> 键是使用最频繁的键。许多 Vim 用户会将键盘上的 <code>Caps Lock</code> (大小写锁定) 键映射为 <code>&lt;ESC&gt;</code>，这样左手小指就能轻松按到，极大提升效率。</p></blockquote><h3 id="vim-基础操作-生存指南" tabindex="-1">Vim 基础操作：生存指南 <a class="header-anchor" href="#vim-基础操作-生存指南" aria-label="Permalink to &quot;Vim 基础操作：生存指南&quot;">​</a></h3><p>打开终端，输入 <code>vim filename.txt</code> 即可创建或打开一个文件。现在，让我们学习如何生存下来。</p><h4 id="保存与退出-命令模式" tabindex="-1">保存与退出 (命令模式) <a class="header-anchor" href="#保存与退出-命令模式" aria-label="Permalink to &quot;保存与退出 (命令模式)&quot;">​</a></h4><p>这些命令都在正常模式下，先输入 <code>:</code> 进入命令模式后执行。</p><table tabindex="0"><thead><tr><th style="text-align:left;">命令</th><th style="text-align:left;">功能</th></tr></thead><tbody><tr><td style="text-align:left;"><code>:w</code></td><td style="text-align:left;"><strong>w</strong>rite，保存文件。</td></tr><tr><td style="text-align:left;"><code>:q</code></td><td style="text-align:left;"><strong>q</strong>uit，退出 Vim。如果文件有未保存的修改，会提示错误。</td></tr><tr><td style="text-align:left;"><code>:wq</code></td><td style="text-align:left;">保存并退出。</td></tr><tr><td style="text-align:left;"><code>:q!</code></td><td style="text-align:left;">强制退出，<strong>不保存</strong>任何修改。</td></tr><tr><td style="text-align:left;"><code>:x</code> 或 <code>:wq</code></td><td style="text-align:left;">效果相同，都是保存并退出。</td></tr><tr><td style="text-align:left;"><code>:w new_filename</code></td><td style="text-align:left;">将当前内容另存为 <code>new_filename</code>。</td></tr></tbody></table><h3 id="vim-的语言-操作-动词-名词" tabindex="-1">Vim 的语言：操作 = 动词 + 名词 <a class="header-anchor" href="#vim-的语言-操作-动词-名词" aria-label="Permalink to &quot;Vim 的语言：操作 = 动词 + 名词&quot;">​</a></h3><p>这是 Vim 最强大、最核心的概念。一个操作命令（动词）可以和任意一个移动命令（名词）组合使用。</p><h4 id="移动-名词" tabindex="-1">移动 (名词) <a class="header-anchor" href="#移动-名词" aria-label="Permalink to &quot;移动 (名词)&quot;">​</a></h4><p>在<strong>正常模式</strong>下，忘记方向键，用下面的按键在文件中穿梭。</p><p><strong>基本移动</strong></p><ul><li><code>h</code> <code>j</code> <code>k</code> <code>l</code>：左、下、上、右。</li></ul><p><strong>词汇移动</strong></p><ul><li><code>w</code>：移动到下一个<strong>w</strong>ord (单词) 的开头。</li><li><code>b</code>：<strong>b</strong>ackward，移动到上一个单词的开头。</li><li><code>e</code>：移动到当前单词的 <strong>e</strong>nd (结尾)。</li></ul><p><strong>行内移动</strong></p><ul><li><code>0</code>：移动到行首 (第0列)。</li><li><code>^</code>：移动到行内第一个非空白字符。</li><li><code>$</code>：移动到行尾。</li></ul><p><strong>文件级移动</strong></p><ul><li><code>gg</code>：移动到文件第一行。</li><li><code>G</code>：移动到文件最后一行。</li><li><code>{行数}G</code> 或 <code>:{行数}</code>：跳转到指定行，例如 <code>15G</code> 跳转到第15行。</li></ul><p><strong>屏幕移动</strong></p><ul><li><code>H</code>: <strong>H</strong>igh，移动到屏幕顶部。</li><li><code>M</code>: <strong>M</strong>iddle，移动到屏幕中间。</li><li><code>L</code>: <strong>L</strong>ow，移动到屏幕底部。</li><li><code>Ctrl+u</code> / <code>Ctrl+d</code>: 向上/向下翻半页。</li></ul><h4 id="编辑-动词" tabindex="-1">编辑 (动词) <a class="header-anchor" href="#编辑-动词" aria-label="Permalink to &quot;编辑 (动词)&quot;">​</a></h4><p>在<strong>正常模式</strong>下执行。</p><table tabindex="0"><thead><tr><th style="text-align:left;">命令</th><th style="text-align:left;">功能</th><th style="text-align:left;">示例组合</th></tr></thead><tbody><tr><td style="text-align:left;"><code>d</code></td><td style="text-align:left;"><strong>d</strong>elete，删除。</td><td style="text-align:left;"><code>dw</code> (删除一个单词), <code>d$</code> (删除到行尾), <code>dG</code> (删除到文件尾)</td></tr><tr><td style="text-align:left;"><code>c</code></td><td style="text-align:left;"><strong>c</strong>hange，改变。删除后立即进入插入模式。</td><td style="text-align:left;"><code>cw</code> (改变一个单词), <code>c$</code> (改变到行尾)</td></tr><tr><td style="text-align:left;"><code>y</code></td><td style="text-align:left;"><strong>y</strong>ank，复制。</td><td style="text-align:left;"><code>yw</code> (复制一个单词), <code>yy</code> (复制整行)</td></tr><tr><td style="text-align:left;"><code>p</code></td><td style="text-align:left;"><strong>p</strong>aste，粘贴。在光标后粘贴。</td><td style="text-align:left;"><code>p</code> (小写p)</td></tr><tr><td style="text-align:left;"><code>P</code></td><td style="text-align:left;"><strong>P</strong>aste，粘贴。在光标前粘贴。</td><td style="text-align:left;"><code>P</code> (大写P)</td></tr><tr><td style="text-align:left;"><code>u</code></td><td style="text-align:left;"><strong>u</strong>ndo，撤销。</td><td style="text-align:left;"><code>u</code></td></tr><tr><td style="text-align:left;"><code>&lt;C-r&gt;</code></td><td style="text-align:left;"><strong>r</strong>edo，重做。</td><td style="text-align:left;"><code>Ctrl+r</code></td></tr></tbody></table><p><strong>命令重复</strong>：许多命令可以通过连续按两次来作用于<strong>整行</strong>。</p><ul><li><code>dd</code>：删除当前行。</li><li><code>cc</code>：改变 (删除并重写) 当前行。</li><li><code>yy</code>：复制当前行。</li></ul><h4 id="计数-量词" tabindex="-1">计数 (量词) <a class="header-anchor" href="#计数-量词" aria-label="Permalink to &quot;计数 (量词)&quot;">​</a></h4><p>你可以在任何“动词+名词”的组合前加上一个数字，来重复执行它。</p><ul><li><code>3w</code>：向后移动 3 个单词。</li><li><code>5j</code>：向下移动 5 行。</li><li><code>d2w</code>：删除 2 个单词。</li><li><code>3yy</code>：复制 3 行。</li></ul><h4 id="修饰语" tabindex="-1">修饰语 <a class="header-anchor" href="#修饰语" aria-label="Permalink to &quot;修饰语&quot;">​</a></h4><p>修饰语 <code>i</code> (inside) 和 <code>a</code> (around) 让操作更精确。</p><ul><li><code>ci(</code>：<strong>c</strong>hange <strong>i</strong>nside <code>()</code>，改变括号内的内容。</li><li><code>di&quot;</code>：<strong>d</strong>elete <strong>i</strong>nside <code>&quot;&quot;</code>，删除双引号内的内容。</li><li><code>ca&#39;</code>：<strong>c</strong>hange <strong>a</strong>round <code>&#39;&#39;</code>，改变整个单引号字符串 (包括引号本身)。</li><li><code>dat</code>: <strong>d</strong>elete <strong>a</strong>round <strong>t</strong>ag，删除整个 HTML/XML 标签。</li></ul><h3 id="自定义与扩展-vim" tabindex="-1">自定义与扩展 Vim <a class="header-anchor" href="#自定义与扩展-vim" aria-label="Permalink to &quot;自定义与扩展 Vim&quot;">​</a></h3><p>原生的 Vim 已经很强大，但通过配置和插件，你可以把它打造成属于你的终极编辑器。</p><h4 id="配置文件-vimrc" tabindex="-1">配置文件 <code>~/.vimrc</code> <a class="header-anchor" href="#配置文件-vimrc" aria-label="Permalink to &quot;配置文件 `~/.vimrc`&quot;">​</a></h4><p>Vim 的所有配置都存储在用户主目录下的 <code>.vimrc</code> 文件中。你可以用 Vim 打开它来编辑：<code>vim ~/.vimrc</code>。</p><p>以下是一些推荐的基础配置：</p><div class="language-vim vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">vim</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">&quot; 显示行号</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">set</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> number</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">&quot; 开启语法高亮</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">syntax on</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">&quot; 设置缩进为4个空格</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">set</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> tabstop</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">4</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">set</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> shiftwidth</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">4</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">set</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> expandtab</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">&quot; 搜索时高亮匹配项</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">set</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> hlsearch</span></span></code></pre></div><h4 id="扩展插件" tabindex="-1">扩展插件 <a class="header-anchor" href="#扩展插件" aria-label="Permalink to &quot;扩展插件&quot;">​</a></h4><p>从 Vim 8.0 开始，内置了强大的插件管理功能。你不再需要第三方的插件管理器。</p><p><strong>安装插件的步骤：</strong></p><ol><li>创建插件目录：<code>mkdir -p ~/.vim/pack/vendor/start</code></li><li>进入目录：<code>cd ~/.vim/pack/vendor/start</code></li><li>克隆插件仓库：例如，安装模糊文件搜索插件 <code>ctrlp.vim</code>： <code>git clone https://github.com/ctrlpvim/ctrlp.vim</code></li></ol><p><strong>一些广受欢迎的插件：</strong></p><ul><li><strong><a href="https://github.com/ctrlpvim/ctrlp.vim" target="_blank" rel="noreferrer">ctrlp.vim</a></strong>: 模糊文件查找神器。</li><li><strong><a href="https://github.com/preservim/nerdtree" target="_blank" rel="noreferrer">nerdtree</a></strong>: 在 Vim 中添加一个文件树侧边栏。</li><li><strong><a href="https://github.com/vim-airline/vim-airline" target="_blank" rel="noreferrer">vim-airline</a></strong>: 美化底部的状态栏。</li></ul><h3 id="实践出真知-课后练习" tabindex="-1">实践出真知：课后练习 <a class="header-anchor" href="#实践出真知-课后练习" aria-label="Permalink to &quot;实践出真知：课后练习&quot;">​</a></h3><ol><li><strong>完成官方教程</strong>: 在你的终端里输入 <code>vimtutor</code> 命令。这是一个交互式的官方入门教程，大约需要30分钟，是学习 Vim 最好的第一步。</li><li><strong>配置你的 <code>.vimrc</code></strong>: 创建并编辑你自己的 <code>~/.vimrc</code> 文件，至少加上显示行号和语法高亮。</li><li><strong>安装一个插件</strong>: 按照上面的步骤，尝试安装 <code>ctrlp.vim</code> 插件，并学习使用 <code>Ctrl+P</code> 在你的项目中快速查找文件。</li><li><strong>坚持使用</strong>: 最重要的一步！<strong>强迫自己接下来一周内，所有的文本编辑任务都只用 Vim 完成</strong>。当感觉“一定有更好的方法”时，去网上搜索，你总能发现惊喜。</li></ol><h2 id="数据整理" tabindex="-1">数据整理 <a class="header-anchor" href="#数据整理" aria-label="Permalink to &quot;数据整理&quot;">​</a></h2><h3 id="什么是数据整理" tabindex="-1">什么是数据整理？ <a class="header-anchor" href="#什么是数据整理" aria-label="Permalink to &quot;什么是数据整理？&quot;">​</a></h3><p>数据整理（Data Wrangling）是将数据从一种原始格式转换为另一种更有用、更结构化的格式的过程。在 Shell 环境中，这通常意味着将一系列简单的、专用的命令行工具通过<strong>管道 (<code>|</code>)</strong> 连接起来，一步步地过滤、转换和重塑文本数据，直至得到你想要的结果。</p><p>我们的核心场景是<strong>日志分析</strong>。日志文件记录了系统和应用程序的详细活动，但信息量巨大，手动阅读几乎不可能。通过数据整理，我们可以从中提取出有价值的信息。</p><h3 id="核心工具链-日志分析实战" tabindex="-1">核心工具链：日志分析实战 <a class="header-anchor" href="#核心工具链-日志分析实战" aria-label="Permalink to &quot;核心工具链：日志分析实战&quot;">​</a></h3><p>我们的目标是：<strong>分析服务器的 SSH 登录日志，找出尝试登录次数最多的用户名。</strong></p><h4 id="步骤-1-获取和初步过滤-ssh-grep" tabindex="-1">步骤 1: 获取和初步过滤 (<code>ssh</code>, <code>grep</code>) <a class="header-anchor" href="#步骤-1-获取和初步过滤-ssh-grep" aria-label="Permalink to &quot;步骤 1: 获取和初步过滤 (`ssh`, `grep`)&quot;">​</a></h4><p>首先，我们从远程服务器获取日志。<code>ssh</code> 命令允许我们在远程机器上执行命令，并将其输出流传送到本地。</p><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">## 1. 登录到 myserver 并执行 journalctl 命令</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">## 2. 将远程命令的输出通过管道传送到本地的 grep 命令</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">## 3. grep 会筛选出所有包含 &quot;sshd&quot; 的行</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">ssh</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> myserver</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> journalctl</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> |</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> grep</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> sshd</span></span></code></pre></div><p>日志内容仍然太多。我们只关心用户断开连接的记录，因为这通常包含了用户名。我们可以串联另一个 <code>grep</code> 来进一步过滤。</p><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">ssh</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> myserver</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> journalctl</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> |</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> grep</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> sshd</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> |</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> grep</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;Disconnected from&quot;</span></span></code></pre></div><p><strong>技巧</strong>：为了节省网络流量，更好的做法是在远程服务器上完成所有过滤，只将最终结果传回本地。</p><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">## 在远程服务器上执行整个管道命令，然后将结果重定向到本地文件 ssh.log</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">ssh</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> myserver</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;journalctl | grep sshd | grep &quot;Disconnected from&quot;&#39;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> &gt;</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> ssh.log</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">## 使用 less 命令分页查看，更适合浏览大文件</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">less</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> ssh.log</span></span></code></pre></div><h4 id="步骤-2-精确提取-sed-与正则表达式" tabindex="-1">步骤 2: 精确提取 (<code>sed</code> 与正则表达式) <a class="header-anchor" href="#步骤-2-精确提取-sed-与正则表达式" aria-label="Permalink to &quot;步骤 2: 精确提取 (`sed` 与正则表达式)&quot;">​</a></h4><p>我们得到的日志行格式如下： <code>Jan 17 03:13:00 hostname sshd[2631]: Disconnected from invalid user C-ute 46.97.239.16 port 55920 [preauth]</code></p><p>我们只想要用户名 (<code>C-ute</code>)。这时，流编辑器 <code>sed</code> 和强大的<strong>正则表达式</strong>就派上用场了。</p><p><code>sed</code> 最常用的命令是 <code>s</code> (substitute/替换)，其基本语法是：<code>s/REGEX/SUBSTITUTION/</code>。</p><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">## ... (前面的命令) ...</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">## | sed &#39;s/.*Disconnected from</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> //&#39;</span></span></code></pre></div><p>这条命令会查找匹配 <code>.*Disconnected from </code> 的部分，并将其替换为空字符串（即删除它）。</p><h5 id="正则表达式入门" tabindex="-1"><strong>正则表达式入门</strong> <a class="header-anchor" href="#正则表达式入门" aria-label="Permalink to &quot;**正则表达式入门**&quot;">​</a></h5><p>正则表达式是一种描述文本模式的语言。</p><table tabindex="0"><thead><tr><th style="text-align:left;">元字符</th><th style="text-align:left;">含义</th><th style="text-align:left;">示例</th></tr></thead><tbody><tr><td style="text-align:left;"><code>.</code></td><td style="text-align:left;">匹配除换行符外的任意<strong>单个</strong>字符</td><td style="text-align:left;"><code>a.c</code> 匹配 &quot;abc&quot;, &quot;axc&quot;, &quot;a1c&quot;</td></tr><tr><td style="text-align:left;"><code>*</code></td><td style="text-align:left;">匹配<strong>零次或多次</strong>前一个字符</td><td style="text-align:left;"><code>a*</code> 匹配 &quot;&quot;, &quot;a&quot;, &quot;aa&quot;, &quot;aaa&quot;</td></tr><tr><td style="text-align:left;"><code>+</code></td><td style="text-align:left;">匹配<strong>一次或多次</strong>前一个字符</td><td style="text-align:left;"><code>a+</code> 匹配 &quot;a&quot;, &quot;aa&quot;, &quot;aaa&quot;</td></tr><tr><td style="text-align:left;"><code>?</code></td><td style="text-align:left;">匹配<strong>零次或一次</strong>前一个字符</td><td style="text-align:left;"><code>colou?r</code> 匹配 &quot;color&quot; 和 &quot;colour&quot;</td></tr><tr><td style="text-align:left;"><code>[abc]</code></td><td style="text-align:left;">匹配 <code>a</code>, <code>b</code>, <code>c</code> 中的任意一个字符</td><td style="text-align:left;"><code>gr[ae]y</code> 匹配 &quot;gray&quot; 和 &quot;grey&quot;</td></tr><tr><td style="text-align:left;"><code>[^abc]</code></td><td style="text-align:left;">匹配<strong>除</strong> <code>a</code>, <code>b</code>, <code>c</code> 之外的任意字符</td><td style="text-align:left;"><code>[^0-9]</code> 匹配任何非数字字符</td></tr><tr><td style="text-align:left;"><code>(..|..)</code></td><td style="text-align:left;">逻辑&quot;或&quot;，匹配其中一个模式</td><td style="text-align:left;">`cat</td></tr><tr><td style="text-align:left;"><code>^</code></td><td style="text-align:left;">匹配行首</td><td style="text-align:left;"><code>^start</code> 匹配以 &quot;start&quot; 开头的行</td></tr><tr><td style="text-align:left;"><code>$</code></td><td style="text-align:left;">匹配行尾</td><td style="text-align:left;"><code>end$</code> 匹配以 &quot;end&quot; 结尾的行</td></tr></tbody></table><p><strong>贪婪匹配问题</strong>: <code>*</code> 和 <code>+</code> 默认是“贪婪的”，它们会尽可能多地匹配文本。例如，对于 <code>Disconnected from invalid user Disconnected from 46.97...</code>，正则表达式 <code>.*Disconnected from </code> 会一直匹配到第二个 &quot;Disconnected from&quot;，这不是我们想要的。</p><h5 id="使用捕获组提取用户名" tabindex="-1"><strong>使用捕获组提取用户名</strong> <a class="header-anchor" href="#使用捕获组提取用户名" aria-label="Permalink to &quot;**使用捕获组提取用户名**&quot;">​</a></h5><p>为了精确地提取用户名，我们需要一个更复杂的正则表达式，并使用<strong>捕获组 (<code>(...)</code>)</strong>。被圆括号包裹的模式所匹配到的内容，可以被后续引用，如 <code>\1</code>, <code>\2</code>。</p><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">## ... | sed -E &#39;s/.*Disconnected from (invalid |authenticating )?user (.*) [^ ]+ port [0-9]+( \[preauth\])?$/\2/&#39;</span></span></code></pre></div><p>让我们分解这个复杂的命令：</p><ul><li><code>sed -E</code>: 使用扩展正则表达式语法，让 <code>?</code>, <code>+</code>, <code>()</code> 等元字符无需转义。</li><li><code>s/.../\2/</code>: 整个是一个替换命令。</li><li><code>.*Disconnected from</code>: 匹配并跳过日志前缀。</li><li><code>(invalid |authenticating )?</code>: 匹配 &quot;invalid user&quot; 或 &quot;authenticating user&quot;，<code>?</code> 表示这部分可能不存在。</li><li><code>user </code>: 匹配 &quot;user &quot;。</li><li><code>(.*)</code>: <strong>这是关键！</strong> 这是第二个捕获组，它会匹配并“捕获”任意字符序列（即用户名）。</li><li><code>[^ ]+ port [0-9]+</code>: 匹配 IP 地址、&quot;port&quot; 和端口号。</li><li><code>( \[preauth\])?$</code>: 匹配行尾可能出现的 <code>[preauth]</code>。</li><li><code>\2</code>: 在替换部分，我们使用 <code>\2</code> 来引用第二个捕获组的内容，也就是我们想要的用户名。</li></ul><p>执行后，我们就得到了一个干净的用户名列表。</p><h4 id="步骤-3-计数与排序-sort-uniq" tabindex="-1">步骤 3: 计数与排序 (<code>sort</code>, <code>uniq</code>) <a class="header-anchor" href="#步骤-3-计数与排序-sort-uniq" aria-label="Permalink to &quot;步骤 3: 计数与排序 (`sort`, `uniq`)&quot;">​</a></h4><p>现在我们有了一个用户名列表，如何统计每个用户出现的次数呢？</p><ol><li><strong><code>sort</code></strong>: <code>uniq</code> 只能检测<strong>连续</strong>的重复行，所以我们必须先用 <code>sort</code> 将相同的用户名排在一起。</li><li><strong><code>uniq -c</code></strong>: <code>-c</code> 选项会统计每个重复行出现的次数，并将其作为前缀输出。</li></ol><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">## ... (前面的命令) ...</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">## | sort | uniq -c</span></span></code></pre></div><p>输出会是这样：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>   5 admin</span></span>
<span class="line"><span>  12 c-ute</span></span>
<span class="line"><span>   3 root</span></span></code></pre></div><h4 id="步骤-4-按频率排序并提取结果-sort-tail-awk-paste" tabindex="-1">步骤 4: 按频率排序并提取结果 (<code>sort</code>, <code>tail</code>, <code>awk</code>, <code>paste</code>) <a class="header-anchor" href="#步骤-4-按频率排序并提取结果-sort-tail-awk-paste" aria-label="Permalink to &quot;步骤 4: 按频率排序并提取结果 (`sort`, `tail`, `awk`, `paste`)&quot;">​</a></h4><p>我们想按出现次数从高到低排序，并提取最终结果。</p><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">## ... (前面的命令) ...</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">## | sort -nk1,1 | tail -n10</span></span></code></pre></div><ul><li><code>sort -n</code>: 按<strong>数字</strong>顺序排序，而不是默认的字典序。</li><li><code>sort -k1,1</code>: 只根据第一个字段（由空格分隔）进行排序。</li><li><code>tail -n10</code>: 显示排序后结果的最后 10 行（即出现次数最多的 10 个）。</li></ul><p>现在，如果我们只想得到一个由逗号分隔的用户名列表：</p><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">## ... (前面的命令) ...</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">## | awk &#39;{print $2}&#39; | paste -sd,</span></span></code></pre></div><ul><li><strong><code>awk &#39;{print $2}&#39;</code></strong>: <code>awk</code> 是一个强大的文本处理语言。这条命令的意思是：对于每一行输入，打印第二个字段（<code>$2</code>），默认用空格分隔。这会提取出用户名。</li><li><strong><code>paste -sd,</code></strong>: <code>paste</code> 命令用于合并行。<code>-s</code> 表示串行合并，<code>-d,</code> 表示使用逗号作为分隔符。</li></ul><p>最终，我们得到了一行由逗号分隔的、尝试登录次数最多的 10 个用户名。</p><h3 id="更强大的工具-awk" tabindex="-1">更强大的工具：<code>awk</code> <a class="header-anchor" href="#更强大的工具-awk" aria-label="Permalink to &quot;更强大的工具：`awk`&quot;">​</a></h3><p><code>awk</code> 不仅仅是字段提取工具，它本身就是一种编程语言。其基本结构是 <code>pattern { action }</code>。</p><p><strong>示例</strong>：统计所有以 <code>c</code> 开头、以 <code>e</code> 结尾，且只尝试过一次登录的用户名数量。</p><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">## ... (经过 sort | uniq -c 之后) ...</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">## | awk &#39;$1 == 1 &amp;&amp; $2 ~ /^c.*e$/ { count++ } END { print count }&#39;</span></span></code></pre></div><ul><li><code>$1 == 1</code>: 这是一个模式，要求第一个字段（计数值）等于 1。</li><li><code>&amp;&amp;</code>: 逻辑与。</li><li><code>$2 ~ /^c.*e$/</code>: 这是另一个模式，要求第二个字段（用户名）匹配正则表达式。</li><li><code>{ count++ }</code>: 如果模式匹配，则执行花括号内的动作，让变量 <code>count</code> 自增。</li><li><code>END { print count }</code>: <code>END</code> 是一个特殊模式，在处理完所有行后执行。这里我们打印最终的计数值。</li></ul><p>可以看到，<code>awk</code> 几乎可以独立完成 <code>grep</code>, <code>sed</code>, <code>uniq</code> 的所有工作。</p><h3 id="处理现代-web-数据-curl-pup-jq" tabindex="-1">处理现代 Web 数据 (<code>curl</code>, <code>pup</code>, <code>jq</code>) <a class="header-anchor" href="#处理现代-web-数据-curl-pup-jq" aria-label="Permalink to &quot;处理现代 Web 数据 (`curl`, `pup`, `jq`)&quot;">​</a></h3><p>数据整理不仅限于日志文件。我们经常需要从网站或 API 获取数据。</p><ul><li><strong><code>curl</code></strong>: 一个强大的网络请求工具，用于从 URL 获取数据。</li><li><strong><code>pup</code></strong>: 一个用于 HTML 的命令行解析器，可以像 <code>jq</code> 处理 JSON 一样使用 CSS 选择器来提取 HTML 元素。</li><li><strong><code>jq</code></strong>: 一个用于 JSON 的命令行处理器，可以轻松地切片、过滤和重构 JSON 数据。</li></ul><p><strong>示例：从网页提取标题</strong></p><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">## 1. curl -s 下载网页的 HTML 内容</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">## 2. pup 使用 CSS 选择器 &#39;title&#39; 找到 &lt;title&gt; 标签</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">## 3. text{} 表示只提取标签内的文本内容</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">curl</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -s</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> https://missing.csail.mit.edu/</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> |</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> pup</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;title text{}&#39;</span></span></code></pre></div><p><strong>示例：从 API 获取数据并用 <code>jq</code> 解析</strong></p><p>假设一个 API <code>https://api.github.com/users/octocat</code> 返回如下 JSON 数据：</p><div class="language-json vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">json</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  &quot;login&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;octocat&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  &quot;id&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">583231</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  &quot;name&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;The Octocat&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  &quot;location&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;San Francisco&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#B31D28;--shiki-light-font-style:italic;--shiki-dark:#FDAEB7;--shiki-dark-font-style:italic;">  ...</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>我们可以用 <code>jq</code> 轻松提取特定字段：</p><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">## 获取 &#39;name&#39; 字段的值</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">curl</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -s</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> https://api.github.com/users/octocat</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> |</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> jq</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;.name&#39;</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">## &quot;The Octocat&quot;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">## 获取 &#39;location&#39; 字段的值</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">curl</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -s</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> https://api.github.com/users/octocat</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> |</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> jq</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;.location&#39;</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">## &quot;San Francisco&quot;</span></span></code></pre></div><p>这些工具的组合为我们从网络上抓取和整理数据提供了无限可能。</p><h3 id="课后练习-2" tabindex="-1">课后练习 <a class="header-anchor" href="#课后练习-2" aria-label="Permalink to &quot;课后练习&quot;">​</a></h3><ol><li><strong>正则表达式</strong>: 完成这个简短的<a href="https://regexone.com/" target="_blank" rel="noreferrer">交互式正则表达式教程</a>来巩固你的知识。</li><li><strong>原地替换的风险</strong>: 为什么 <code>sed s/REGEX/SUB/ input.txt &gt; input.txt</code> 这样的命令是危险的，并且通常会导致 <code>input.txt</code> 文件被清空？（提示：查阅 <code>man sed</code> 关于 <code>-i</code> 选项的说明，并思考 Shell 重定向的工作时机）。</li><li><strong>统计分析</strong>: 找出 <code>/usr/share/dict/words</code> 文件中，包含至少三个 <code>a</code> 且不以 <code>&#39;s</code> 结尾的单词个数。</li><li><strong>系统日志分析 (Linux)</strong>: 使用 <code>journalctl</code> 找出你最近三次开机的启动耗时，并计算平均值。</li><li><strong>网页数据提取</strong>: 找一个你感兴趣的网站（例如新闻、维基百科页面），使用 <code>curl</code> 和 <code>pup</code> 提取出所有的标题和对应的链接。</li><li><strong>API 数据提取</strong>: 使用 <code>curl</code> 和 <code>jq</code> 从 <a href="https://api.github.com/users/torvalds" target="_blank" rel="noreferrer">GitHub API</a> 获取 Linus Torvalds 的信息，并提取出他的 <code>name</code>, <code>company</code> 和 <code>public_repos</code> 数量。</li></ol><h2 id="命令行环境" tabindex="-1">命令行环境 <a class="header-anchor" href="#命令行环境" aria-label="Permalink to &quot;命令行环境&quot;">​</a></h2><p>精通单个命令是基础，但要真正提升效率，你需要学会如何管理和定制你的整个命令行<strong>环境</strong>。本章将教你如何驾驭多任务、个性化你的 Shell、并通过 SSH 高效地与远程服务器协作。</p><h3 id="任务控制-管理正在运行的进程" tabindex="-1">任务控制：管理正在运行的进程 <a class="header-anchor" href="#任务控制-管理正在运行的进程" aria-label="Permalink to &quot;任务控制：管理正在运行的进程&quot;">​</a></h3><p>当你执行一个长时间运行的命令时（例如在庞大的文件系统中搜索），你不需要一直等到它结束。你可以通过<strong>信号 (Signals)</strong> 来与进程进行通信。</p><p>信号是一种<strong>软件中断</strong>，用于通知进程发生了某个事件。</p><h4 id="终止进程-不仅仅是-ctrl-c" tabindex="-1">终止进程：不仅仅是 <code>Ctrl-C</code> <a class="header-anchor" href="#终止进程-不仅仅是-ctrl-c" aria-label="Permalink to &quot;终止进程：不仅仅是 `Ctrl-C`&quot;">​</a></h4><table tabindex="0"><thead><tr><th style="text-align:left;">快捷键/命令</th><th style="text-align:left;">信号</th><th style="text-align:left;">含义和作用</th></tr></thead><tbody><tr><td style="text-align:left;"><code>Ctrl-C</code></td><td style="text-align:left;"><code>SIGINT</code> (Interrupt)</td><td style="text-align:left;"><strong>中断信号</strong>。这是最常用的方式，请求程序终止。程序可以<strong>捕获 (catch)</strong> 这个信号并选择忽略它或执行清理操作后退出。</td></tr><tr><td style="text-align:left;"><code>Ctrl-\</code></td><td style="text-align:left;"><code>SIGQUIT</code> (Quit)</td><td style="text-align:left;"><strong>退出信号</strong>。比 <code>SIGINT</code> 更强硬，通常会导致程序立即终止并生成一个<strong>核心转储 (core dump)</strong>，用于调试。</td></tr><tr><td style="text-align:left;"><code>kill -TERM &lt;PID&gt;</code></td><td style="text-align:left;"><code>SIGTERM</code> (Terminate)</td><td style="text-align:left;"><strong>终止信号</strong>。这是通过 <code>kill</code> 命令发送的默认信号，是请求程序终止的“标准”和“优雅”的方式。程序同样可以捕获它并进行清理。</td></tr><tr><td style="text-align:left;"><code>kill -KILL &lt;PID&gt;</code></td><td style="text-align:left;"><code>SIGKILL</code> (Kill)</td><td style="text-align:left;"><strong>强制杀死信号</strong>。这是一个特殊的、终极的信号。它不能被程序捕获或忽略，会由操作系统内核立即终止进程。这可能导致数据丢失或留下孤儿进程，应作为最后手段使用。</td></tr></tbody></table><p><strong>示例：一个无法被 <code>Ctrl-C</code> 终止的程序</strong> 下面这个 Python 脚本捕获了 <code>SIGINT</code> 信号，因此你无法用 <code>Ctrl-C</code> 来终止它。</p><div class="language-python vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">python</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">#!/usr/bin/env python</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> signal, time</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">def</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> handler</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(signum, frame):</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    print</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">\n</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">I got a SIGINT, but I am not stopping&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">signal.signal(signal.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">SIGINT</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, handler)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">while</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> True</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    time.sleep(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">.1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    print</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">f</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">\r{</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">i</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">}</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">end</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span></span></code></pre></div><p>运行它，然后按下 <code>Ctrl-C</code>，你会看到它打印了消息但并未退出。此时，你需要使用 <code>Ctrl-\</code> (<code>SIGQUIT</code>) 来强制退出它。</p><h4 id="暂停与后台执行" tabindex="-1">暂停与后台执行 <a class="header-anchor" href="#暂停与后台执行" aria-label="Permalink to &quot;暂停与后台执行&quot;">​</a></h4><p>有时候你不想终止一个任务，只是想暂时把它“放一边”。</p><table tabindex="0"><thead><tr><th style="text-align:left;">快捷键/命令</th><th style="text-align:left;">信号</th><th style="text-align:left;">作用</th></tr></thead><tbody><tr><td style="text-align:left;"><code>Ctrl-Z</code></td><td style="text-align:left;"><code>SIGTSTP</code> (Terminal Stop)</td><td style="text-align:left;"><strong>暂停</strong>当前在前台运行的进程，并将其放入后台。</td></tr><tr><td style="text-align:left;"><code>bg</code></td><td style="text-align:left;">-</td><td style="text-align:left;">将后台中一个<strong>已暂停 (suspended)</strong> 的任务，转为<strong>在后台继续运行 (running)</strong>。</td></tr><tr><td style="text-align:left;"><code>fg</code></td><td style="text-align:left;">-</td><td style="text-align:left;">将后台中的一个任务（无论是暂停的还是运行的）拉回到<strong>前台</strong>来。</td></tr><tr><td style="text-align:left;"><code>jobs</code></td><td style="text-align:left;">-</td><td style="text-align:left;">列出当前 Shell 会话中所有在后台的任务及其状态。</td></tr><tr><td style="text-align:left;"><code>command &amp;</code></td><td style="text-align:left;">-</td><td style="text-align:left;">在命令末尾加上 <code>&amp;</code>，可以直接让它在<strong>后台运行</strong>。</td></tr></tbody></table><p><strong>工作流示例：</strong></p><div class="language-console vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">console</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">## 1. 启动一个长时间任务</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">$ sleep 1000</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">## 2. 发现它会阻塞终端，按 Ctrl-Z 暂停它</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">^Z</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">[1]+  Stopped                 sleep 1000</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">## 3. 查看后台任务列表</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">$ jobs</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">[1]+  Stopped                 sleep 1000</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">## 4. 让它在后台继续运行</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">$ bg %1</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">[1]+ sleep 1000 &amp;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">## 5. 现在你可以继续使用终端了。如果想把它调回前台：</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">$ fg %1</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">sleep 1000</span></span></code></pre></div><ul><li><code>%1</code> 是 <code>jobs</code> 命令输出的任务编号。</li><li><code>$!</code> 是一个特殊的 shell 变量，代表最近一个放入后台的进程的 PID。</li></ul><p><strong>让进程在关闭终端后依然运行：</strong> 默认情况下，关闭终端会发送 <code>SIGHUP</code> (Hangup) 信号，这会导致该终端启动的所有子进程（包括后台任务）终止。为了避免这种情况：</p><ul><li><strong><code>nohup command &amp;</code></strong>: 使用 <code>nohup</code> (no hangup) 启动命令，它会忽略 <code>SIGHUP</code> 信号，并将输出重定向到 <code>nohup.out</code> 文件。</li><li><strong><code>disown</code></strong>: 对于一个<strong>已经</strong>在后台运行的任务 (例如通过 <code>Ctrl-Z</code> 和 <code>bg</code>)，使用 <code>disown -h %1</code> 可以让它忽略 <code>SIGHUP</code>。</li><li><strong>终端多路复用器 (Tmux/Screen)</strong>: 这是管理远程会话和后台任务的最佳方式，详见下一节。</li></ul><h3 id="终端多路复用器-tmux" tabindex="-1">终端多路复用器 (Tmux) <a class="header-anchor" href="#终端多路复用器-tmux" aria-label="Permalink to &quot;终端多路复用器 (Tmux)&quot;">​</a></h3><p>终端多路复用器 (Terminal Multiplexer) 允许你在一个终端窗口内创建和管理多个独立的 Shell 会话。<code>tmux</code> 是目前最流行和功能最强大的选择。</p><p><strong>为什么 <code>tmux</code> 是必备工具？</strong></p><ol><li><strong>多任务处理</strong>: 在一个屏幕内创建多个窗格 (pane) 和窗口 (window)，同时运行编辑器、编译器、服务器日志等。</li><li><strong>会话分离与重连</strong>: 与远程服务器的 SSH 连接断开后，<code>tmux</code> 会话和其中的所有进程会继续在服务器上运行。你可以随时重新连接 SSH，并恢复到之前的工作状态。这是 <code>nohup</code> 和 <code>disown</code> 的完美替代方案。</li></ol><p><strong><code>tmux</code> 核心概念</strong></p><ul><li><strong>会话 (Session)</strong>: 一个独立的工作区，可以包含多个窗口。</li><li><strong>窗口 (Window)</strong>: 类似于浏览器的标签页，占据整个屏幕。</li><li><strong>窗格 (Pane)</strong>: 一个窗口可以被分割成多个窗格，每个窗格都是一个独立的终端。</li></ul><p><strong>基本操作 (所有快捷键的前缀都是 <code>Ctrl-b</code>)</strong></p><table tabindex="0"><thead><tr><th style="text-align:left;">操作</th><th style="text-align:left;">命令/快捷键</th><th style="text-align:left;">描述</th></tr></thead><tbody><tr><td style="text-align:left;"><strong>会话管理</strong></td><td style="text-align:left;"></td><td style="text-align:left;">(在普通 Shell 中执行)</td></tr><tr><td style="text-align:left;">新建会话</td><td style="text-align:left;"><code>tmux</code> 或 <code>tmux new -s &lt;name&gt;</code></td><td style="text-align:left;">启动一个新的 <code>tmux</code> 会话，可指定名称。</td></tr><tr><td style="text-align:left;">列出所有会话</td><td style="text-align:left;"><code>tmux ls</code></td><td style="text-align:left;"></td></tr><tr><td style="text-align:left;">分离会话</td><td style="text-align:left;"><code>Ctrl-b d</code></td><td style="text-align:left;">从 <code>tmux</code> 会话中返回到普通 Shell，会话在后台继续运行。</td></tr><tr><td style="text-align:left;">重新连接</td><td style="text-align:left;"><code>tmux a</code> 或 <code>tmux a -t &lt;name&gt;</code></td><td style="text-align:left;">重新连接到上一个或指定名称的会话。</td></tr><tr><td style="text-align:left;"><strong>窗口管理</strong></td><td style="text-align:left;"></td><td style="text-align:left;">(在 <code>tmux</code> 会话中执行)</td></tr><tr><td style="text-align:left;">创建新窗口</td><td style="text-align:left;"><code>Ctrl-b c</code></td><td style="text-align:left;"></td></tr><tr><td style="text-align:left;">切换到下/上一个窗口</td><td style="text-align:left;"><code>Ctrl-b n</code> / <code>Ctrl-b p</code></td><td style="text-align:left;"></td></tr><tr><td style="text-align:left;">切换到指定编号的窗口</td><td style="text-align:left;"><code>Ctrl-b &lt;0-9&gt;</code></td><td style="text-align:left;"></td></tr><tr><td style="text-align:left;"><strong>窗格管理</strong></td><td style="text-align:left;"></td><td style="text-align:left;">(在 <code>tmux</code> 会话中执行)</td></tr><tr><td style="text-align:left;">垂直分割</td><td style="text-align:left;"><code>Ctrl-b %</code></td><td style="text-align:left;"></td></tr><tr><td style="text-align:left;">水平分割</td><td style="text-align:left;"><code>Ctrl-b &quot;</code></td><td style="text-align:left;"></td></tr><tr><td style="text-align:left;">在窗格间移动</td><td style="text-align:left;"><code>Ctrl-b &lt;方向键&gt;</code></td><td style="text-align:left;"></td></tr><tr><td style="text-align:left;">切换窗格布局</td><td style="text-align:left;"><code>Ctrl-b Space</code></td><td style="text-align:left;"></td></tr><tr><td style="text-align:left;">最大化/还原当前窗格</td><td style="text-align:left;"><code>Ctrl-b z</code></td><td style="text-align:left;"></td></tr></tbody></table><h3 id="定制你的环境-别名与配置文件" tabindex="-1">定制你的环境：别名与配置文件 <a class="header-anchor" href="#定制你的环境-别名与配置文件" aria-label="Permalink to &quot;定制你的环境：别名与配置文件&quot;">​</a></h3><h4 id="别名-alias" tabindex="-1">别名 (Alias) <a class="header-anchor" href="#别名-alias" aria-label="Permalink to &quot;别名 (Alias)&quot;">​</a></h4><p>别名是为长命令创建的快捷方式。它们可以极大地减少你的键盘输入，并使常用命令更易于记忆。</p><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">## 在 bash 或 zsh 中定义别名的语法</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">alias</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> short_name</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;a_very_long_and_complex_command --with --many --options&quot;</span></span></code></pre></div><p><strong>实用的别名示例：</strong></p><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">## 1. 常用命令的缩写</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">alias</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ll</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;ls -lh&quot;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">alias</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> la</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;ls -lha&quot;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">## 2. 防止误操作</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">alias</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> rm</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;rm -i&quot;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    ## 删除前进行提示</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">alias</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> mv</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;mv -i&quot;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    ## 覆盖前进行提示</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">alias</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> cp</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;cp -i&quot;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">## 3. 统一不同系统的命令 (例如在 macOS 和 Linux 间)</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">## 在 macOS 上，ls 不支持 --color=auto, ggrep 是通过 brew 安装的 GNU grep</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> [[ </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;$(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">uname</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">)&quot;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> ==</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;Darwin&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ]]; </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">then</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  alias</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ls</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;ls -G&quot;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  alias</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> grep</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;ggrep --color=auto&quot;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">else</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  alias</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ls</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;ls --color=auto&quot;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  alias</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> grep</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;grep --color=auto&quot;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">fi</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">## 4. Git 快捷方式</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">alias</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> g</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;git&quot;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">alias</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> gs</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;git status&quot;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">alias</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ga</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;git add&quot;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">alias</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> gc</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;git commit -m&quot;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">alias</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> gp</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;git push&quot;</span></span></code></pre></div><h4 id="配置文件-dotfiles" tabindex="-1">配置文件 (Dotfiles) <a class="header-anchor" href="#配置文件-dotfiles" aria-label="Permalink to &quot;配置文件 (Dotfiles)&quot;">​</a></h4><p>几乎所有命令行工具都通过<strong>点文件 (dotfiles)</strong>（文件名以 <code>.</code> 开头，如 <code>.bashrc</code>）进行配置。将这些配置文件管理好，你就可以在任何一台新机器上快速复现你熟悉的工作环境。</p><p><strong>为什么要管理 Dotfiles？</strong></p><ul><li><strong>可移植性</strong>: 在任何新电脑或服务器上，一键恢复你所有的配置。</li><li><strong>同步性</strong>: 在一处修改，所有设备同步更新。</li><li><strong>版本控制</strong>: 使用 Git 跟踪你对配置的所有修改，随时可以回滚。</li></ul><p><strong>管理 Dotfiles 的最佳实践：</strong></p><ol><li><p><strong>创建 Git 仓库</strong>: 在主目录下创建一个专门的文件夹（例如 <code>~/dotfiles</code>），并将其初始化为 Git 仓库。</p></li><li><p><strong>移动配置文件</strong>: 将你的配置文件（如 <code>.bashrc</code>, <code>.zshrc</code>, <code>.vimrc</code>, <code>.tmux.conf</code>, <code>.gitconfig</code>）移动到这个仓库中。</p></li><li><p><strong>创建符号链接 (Symlink)</strong>: 从仓库中的文件创建符号链接到它们原本应该在的位置。这会让程序以为文件还在原处，但实际上你编辑的是 Git 仓库中的版本。</p><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">## 将 .bashrc 移入仓库</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">mv</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> ~/.bashrc</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> ~/dotfiles/bashrc</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">## 创建从仓库到主目录的符号链接</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">ln</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -s</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> ~/dotfiles/bashrc</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> ~/.bashrc</span></span></code></pre></div></li><li><p><strong>编写安装脚本</strong>: 创建一个简单的安装脚本 (<code>install.sh</code>)，自动完成创建符号链接的过程，这样在新机器上部署就变得非常简单。</p></li><li><p><strong>发布到 GitHub</strong>: 将你的 dotfiles 仓库推送到 GitHub，方便随时随地访问。</p></li></ol><h3 id="高效的-ssh-连接远程服务器" tabindex="-1">高效的 SSH：连接远程服务器 <a class="header-anchor" href="#高效的-ssh-连接远程服务器" aria-label="Permalink to &quot;高效的 SSH：连接远程服务器&quot;">​</a></h3><p>SSH (Secure Shell) 是与远程服务器交互的标准工具。除了基本的登录，它还有许多强大的功能。</p><h4 id="ssh-密钥-告别密码登录" tabindex="-1">SSH 密钥：告别密码登录 <a class="header-anchor" href="#ssh-密钥-告别密码登录" aria-label="Permalink to &quot;SSH 密钥：告别密码登录&quot;">​</a></h4><p>使用密钥对进行认证，比密码更安全、更方便。</p><ol><li><p><strong>生成密钥对</strong>:</p><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">## ed25519 是目前推荐的算法，更安全、更快速</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">ssh-keygen</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -t</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> ed25519</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -C</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;your_email@example.com&quot;</span></span></code></pre></div><p>这会在 <code>~/.ssh/</code> 目录下生成 <code>id_ed25519</code> (私钥，<strong>绝不能泄露！</strong>) 和 <code>id_ed25519.pub</code> (公钥)。</p></li><li><p><strong>将公钥复制到服务器</strong>: 最简单的方式是使用 <code>ssh-copy-id</code>：</p><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">ssh-copy-id</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> user@remote_host</span></span></code></pre></div><p>它会自动将你的公钥追加到远程服务器的 <code>~/.ssh/authorized_keys</code> 文件中。</p></li></ol><h4 id="ssh-配置文件-ssh-config" tabindex="-1">SSH 配置文件：<code>~/.ssh/config</code> <a class="header-anchor" href="#ssh-配置文件-ssh-config" aria-label="Permalink to &quot;SSH 配置文件：`~/.ssh/config`&quot;">​</a></h4><p>不要每次都输入冗长的 <code>ssh</code> 命令。通过配置 <code>~/.ssh/config</code> 文件，可以为你的远程连接创建快捷方式。</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>## ~/.ssh/config</span></span>
<span class="line"><span></span></span>
<span class="line"><span>## 一个简单的例子</span></span>
<span class="line"><span>Host dev-server</span></span>
<span class="line"><span>    HostName 192.168.1.100</span></span>
<span class="line"><span>    User myuser</span></span>
<span class="line"><span>    Port 2222</span></span>
<span class="line"><span>    IdentityFile ~/.ssh/id_ed25519</span></span>
<span class="line"><span></span></span>
<span class="line"><span>## 使用通配符</span></span>
<span class="line"><span>Host *.compute.amazonaws.com</span></span>
<span class="line"><span>    User ec2-user</span></span>
<span class="line"><span>    IdentityFile ~/.ssh/aws-key.pem</span></span>
<span class="line"><span></span></span>
<span class="line"><span>## 包含端口转发的例子</span></span>
<span class="line"><span>Host jupyter</span></span>
<span class="line"><span>    HostName 10.0.0.5</span></span>
<span class="line"><span>    User data-scientist</span></span>
<span class="line"><span>    ## 将本地的 8888 端口转发到远程服务器的 8888 端口</span></span>
<span class="line"><span>    LocalForward 8888 localhost:8888</span></span></code></pre></div><p>配置好之后，你就可以：</p><ul><li>用 <code>ssh dev-server</code> 代替 <code>ssh -p 2222 -i ~/.ssh/id_ed25519 myuser@192.168.1.100</code>。</li><li>用 <code>scp file.txt dev-server:~/</code> 来复制文件。</li><li>用 <code>ssh jupyter</code> 自动建立端口转发，然后在本地浏览器访问 <code>http://localhost:8888</code>。</li></ul><h4 id="远程文件操作" tabindex="-1">远程文件操作 <a class="header-anchor" href="#远程文件操作" aria-label="Permalink to &quot;远程文件操作&quot;">​</a></h4><ul><li><strong><code>scp</code></strong>: 简单地复制文件/文件夹。<code>scp local_file user@host:remote_path</code>。</li><li><strong><code>rsync</code></strong>: 更强大的复制工具，支持增量同步（只传输变化的部分），速度更快，功能更丰富。<code>rsync -avz --progress local_dir/ user@host:remote_dir/</code>。</li><li><strong><code>sshfs</code></strong>: 将远程服务器的目录挂载到本地文件系统，像操作本地文件一样操作远程文件，非常适合图形界面的编辑器。</li></ul><h3 id="扩展你的-shell-zsh-fish-和框架" tabindex="-1">扩展你的 Shell：Zsh, Fish 和框架 <a class="header-anchor" href="#扩展你的-shell-zsh-fish-和框架" aria-label="Permalink to &quot;扩展你的 Shell：Zsh, Fish 和框架&quot;">​</a></h3><p>Bash 虽然强大且普遍，但还有更现代、更用户友好的替代品：</p><ul><li><strong>Zsh</strong>: Bash 的超集，提供了更好的自动补全、主题、拼写纠错等。结合 <a href="https://ohmyz.sh/" target="_blank" rel="noreferrer">Oh My Zsh</a> 框架可以轻松获得大量插件和漂亮的主题。</li><li><strong>Fish (Friendly Interactive Shell)</strong>: 开箱即用，提供语法高亮、强大的历史搜索和智能的自动补全，非常适合新手。</li></ul><h3 id="课后练习-3" tabindex="-1">课后练习 <a class="header-anchor" href="#课后练习-3" aria-label="Permalink to &quot;课后练习&quot;">​</a></h3><ol><li><strong>任务控制</strong>: <ul><li>运行 <code>sleep 10000</code>。用 <code>Ctrl-Z</code> 将其暂停。</li><li>用 <code>bg</code> 让它在后台继续运行。</li><li>使用 <code>pgrep sleep</code> 找到它的 PID。</li><li>使用 <code>pkill sleep</code> (或 <code>kill &lt;PID&gt;</code>) 来终止它。</li></ul></li><li><strong>Tmux</strong>: <ul><li>安装 <code>tmux</code>。</li><li>启动一个新的 <code>tmux</code> 会话。</li><li>创建一个垂直分割和一个水平分割的窗格布局。</li><li>创建一个新窗口，然后在两个窗口之间切换。</li><li>按 <code>Ctrl-b d</code> 分离会话，然后用 <code>tmux a</code> 重新连接。</li></ul></li><li><strong>别名与配置文件</strong>: <ul><li>在你 shell 的配置文件 (<code>.bashrc</code> 或 <code>.zshrc</code>) 中，为你最常用的 5 个命令创建别名。</li><li>创建一个 <code>~/dotfiles</code> 目录，并用 Git 进行版本控制。将你的 shell 配置文件移入其中，并创建符号链接。</li></ul></li><li><strong>SSH</strong>: <ul><li>确保你有一个 SSH 密钥对。</li><li>配置 <code>~/.ssh/config</code>，为你经常访问的服务器创建一个 Host 别名。</li><li>尝试禁用服务器的密码登录（编辑 <code>/etc/ssh/sshd_config</code> 并设置 <code>PasswordAuthentication no</code>），只允许密钥登录，以提高安全性。</li></ul></li></ol><h2 id="版本控制-git" tabindex="-1">版本控制 (Git) <a class="header-anchor" href="#版本控制-git" aria-label="Permalink to &quot;版本控制 (Git)&quot;">​</a></h2><h3 id="为什么需要版本控制" tabindex="-1">为什么需要版本控制？ <a class="header-anchor" href="#为什么需要版本控制" aria-label="Permalink to &quot;为什么需要版本控制？&quot;">​</a></h3><p>想象一下你正在写一个大型项目，你可能会这样做：</p><ul><li><code>project_v1.zip</code></li><li><code>project_v2_final.zip</code></li><li><code>project_v3_really_final.zip</code></li><li><code>project_v3_bugfix_for_boss.zip</code></li></ul><p>这种方式混乱、低效且容易出错。版本控制系统 (Version Control System, VCS) 正是为了解决这个问题而生的。它是一种能追踪文件和目录变更的工具。</p><p><strong>即使是单人开发，VCS 也极其有用：</strong></p><ul><li><strong>创建项目快照</strong>：你可以随时将项目“存档”，并在未来恢复到任何一个存档点。</li><li><strong>记录变更目的</strong>：每一次存档，你都可以附上说明，解释你“为什么”做出这些修改。</li><li><strong>并行开发</strong>：可以同时在多个“版本”（分支）上工作，而互不干扰。例如，在一个分支上修复紧急 bug，同时在另一个分支上开发新功能。</li></ul><p><strong>在团队协作中，VCS 更是不可或缺：</strong></p><ul><li><strong>协同工作</strong>：清晰地看到团队成员的修改，避免互相覆盖。</li><li><strong>解决冲突</strong>：当多人修改了同一个文件的同一部分时，VCS 提供了工具来帮助你合并这些冲突。</li><li><strong>责任追溯</strong>：可以轻松回答“这行代码是谁写的？”、“这个 bug 是哪个版本引入的？”等问题。</li></ul><p>在众多 VCS 中，<strong>Git</strong> 已经成为事实上的标准。虽然它的命令行初看可能有些复杂，但其底层的设计模型却非常优雅和强大。理解了这个模型，你就能真正掌握 Git。</p><p>因此，我们将采用一种“自底向上”的方式来学习：<strong>先理解数据模型，再学习命令行</strong>。</p><h3 id="git-的核心-数据模型" tabindex="-1">Git 的核心：数据模型 <a class="header-anchor" href="#git-的核心-数据模型" aria-label="Permalink to &quot;Git 的核心：数据模型&quot;">​</a></h3><p>Git 并不记录文件的差异或变化。相反，它将项目的历史记录视为一系列<strong>快照 (Snapshots)</strong>。</p><h4 id="基础构建块-对象-objects" tabindex="-1">基础构建块：对象 (Objects) <a class="header-anchor" href="#基础构建块-对象-objects" aria-label="Permalink to &quot;基础构建块：对象 (Objects)&quot;">​</a></h4><p>Git 仓库的核心是其数据库，里面存储了三种类型的“对象”：</p><ol><li><p><strong>Blob (Binary Large Object)</strong>:</p><ul><li><strong>是什么</strong>：一个文件的<strong>内容</strong>。</li><li><strong>特点</strong>：它只包含文件的数据，不包含文件名、时间戳等任何元信息。你可以把它想象成一坨二进制数据。</li></ul></li><li><p><strong>Tree (树)</strong>:</p><ul><li><strong>是什么</strong>：一个<strong>目录</strong>的快照。</li><li><strong>特点</strong>：它像一个清单，记录了某个目录下包含的文件和子目录。对于每个条目，它存储了： <ul><li>文件/目录名</li><li>指向对应的 Blob 或 Tree 对象的指针 (哈希值)</li><li>文件类型（是普通文件、可执行文件还是子目录）</li></ul></li></ul><p>一个 Tree 对象看起来像这样：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>&lt;root&gt; (tree)</span></span>
<span class="line"><span>|</span></span>
<span class="line"><span>+- foo (tree) -&gt; 指向代表 foo 目录的 Tree 对象的哈希</span></span>
<span class="line"><span>|  |</span></span>
<span class="line"><span>|  + bar.txt (blob) -&gt; 指向代表 bar.txt 内容的 Blob 对象的哈希</span></span>
<span class="line"><span>|</span></span>
<span class="line"><span>+- baz.txt (blob) -&gt; 指向代表 baz.txt 内容的 Blob 对象的哈希</span></span></code></pre></div></li><li><p><strong>Commit (提交)</strong>:</p><ul><li><strong>是什么</strong>：一个项目在特定时间点的<strong>快照</strong>。这是构成 Git 历史的基本单位。</li><li><strong>特点</strong>：一个 Commit 对象包含： <ul><li>一个指向<strong>顶层 Tree 对象</strong>的指针，代表了该次提交时整个项目的完整快照。</li><li>指向一个或多个<strong>父 Commit (Parent Commits)</strong> 的指针。这正是将所有提交串联成历史记录的关键。</li><li><strong>元数据</strong>：作者、提交者、时间戳，以及最重要的——<strong>提交信息 (Commit Message)</strong>。</li></ul></li></ul></li></ol><h4 id="唯一标识-sha-1-哈希" tabindex="-1">唯一标识：SHA-1 哈希 <a class="header-anchor" href="#唯一标识-sha-1-哈希" aria-label="Permalink to &quot;唯一标识：SHA-1 哈希&quot;">​</a></h4><p>Git 数据库中的所有对象（Blob、Tree、Commit）都是通过其内容的 <strong>SHA-1 哈希值</strong>来索引的。这是一个 40 位的十六进制字符串。</p><ul><li><strong>唯一性</strong>：任何内容的微小改变都会导致一个全新的哈希值。</li><li><strong>完整性</strong>：Git 通过哈希值来确保数据的完整性。如果一个对象损坏了，它的哈希值将不再匹配。</li><li><strong>不可变性</strong>：由于对象的 ID 由其内容决定，所以 Git 中的对象都是<strong>不可变的</strong>。你不能“修改”一个 Commit，你只能创建一个新的 Commit 来替代它。</li></ul><h4 id="历史记录-提交构成的有向无环图-dag" tabindex="-1">历史记录：提交构成的有向无环图 (DAG) <a class="header-anchor" href="#历史记录-提交构成的有向无环图-dag" aria-label="Permalink to &quot;历史记录：提交构成的有向无环图 (DAG)&quot;">​</a></h4><p>每个 Commit 都有指向其父辈的指针，这就在所有 Commit 之间形成了一个<strong>有向无环图 (Directed Acyclic Graph, DAG)</strong>。</p><ul><li><p><strong>线性历史</strong>：最简单的情况，每个提交只有一个父提交。</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>Commit A &lt;-- Commit B &lt;-- Commit C (master)</span></span></code></pre></div><p>(箭头指向父提交)</p></li><li><p><strong>分支与合并</strong>：当历史出现分叉（例如，创建了一个新分支来开发特性），并在之后合并时，会产生一个拥有<strong>两个父提交</strong>的“合并提交”。</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>o &lt;-- o &lt;-- o &lt;----  o (合并提交)</span></span>
<span class="line"><span>            ^      /</span></span>
<span class="line"><span>             \    v</span></span>
<span class="line"><span>              --- o &lt;-- o</span></span></code></pre></div></li></ul><h4 id="人类可读的指针-引用-references" tabindex="-1">人类可读的指针：引用 (References) <a class="header-anchor" href="#人类可读的指针-引用-references" aria-label="Permalink to &quot;人类可读的指针：引用 (References)&quot;">​</a></h4><p>记住一长串 SHA-1 哈希值是不现实的。因此，Git 提供了<strong>引用 (References)</strong>，它们是<strong>指向特定 Commit 哈希值的、人类可读的指针</strong>。</p><ul><li><strong>分支 (Branches)</strong>：例如 <code>master</code>, <code>develop</code>, <code>feature-x</code>。它们是<strong>可变的</strong>，当你创建一个新的 Commit 时，当前分支的指针会自动向前移动到这个新的 Commit。</li><li><strong>标签 (Tags)</strong>：例如 <code>v1.0</code>, <code>v2.1.3</code>。它们通常是<strong>不可变的</strong>，用于标记项目历史中的重要节点（如版本发布）。</li><li><strong>HEAD</strong>：这是一个特殊的引用，它指向你<strong>当前所在的位置</strong>。通常情况下，<code>HEAD</code> 指向一个分支（例如 <code>master</code>），意味着你正工作在这个分支上。</li></ul><p><strong>总结：一个 Git 仓库就是一个由 Blob、Tree、Commit 对象构成的数据库，外加一组指向特定 Commit 的引用（如分支）。</strong></p><h3 id="工作区、暂存区与仓库" tabindex="-1">工作区、暂存区与仓库 <a class="header-anchor" href="#工作区、暂存区与仓库" aria-label="Permalink to &quot;工作区、暂存区与仓库&quot;">​</a></h3><p>理解了数据模型后，我们来看实际操作中涉及的三个区域：</p><ol><li><strong>工作区 (Working Directory)</strong>：你在电脑上实际看到和编辑的文件目录。</li><li><strong>暂存区 (Staging Area / Index)</strong>：一个位于 <code>.git</code> 目录中的文件。它像一个购物车的清单，记录了你<strong>下一次准备提交</strong>的内容的快照。它让你能够精确控制哪些改动要被包含在下一次提交中。</li><li><strong>仓库 (Repository)</strong>：即 <code>.git</code> 目录，存储了项目所有的对象（Commits, Trees, Blobs）和引用，也就是项目的完整历史。</li></ol><p><strong>基本的 Git 工作流程如下：</strong></p><ol><li>在<strong>工作区</strong>修改文件。</li><li>使用 <code>git add</code> 将你想要包含在下一次提交中的改动，放入<strong>暂存区</strong>。</li><li>使用 <code>git commit</code> 将<strong>暂存区</strong>中的内容永久性地记录成一个快照（一个新的 Commit），存入<strong>仓库</strong>。</li></ol><p><img src="https://git-scm.com/book/en/v2/images/areas.png" alt="Git Three Areas" loading="lazy"></p><h3 id="常用-git-命令解析" tabindex="-1">常用 Git 命令解析 <a class="header-anchor" href="#常用-git-命令解析" aria-label="Permalink to &quot;常用 Git 命令解析&quot;">​</a></h3><p>现在，我们可以将具体的命令与它们对数据模型的操作对应起来。</p><h4 id="基础操作" tabindex="-1">基础操作 <a class="header-anchor" href="#基础操作" aria-label="Permalink to &quot;基础操作&quot;">​</a></h4><ul><li><code>git init</code>: 在当前目录创建一个新的 Git 仓库（即 <code>.git</code> 文件夹）。</li><li><code>git status</code>: 显示工作区、暂存区和当前 <code>HEAD</code> 指向的 Commit 之间的差异。这是你最常用的命令之一。</li><li><code>git add &lt;filename&gt;</code>: <ol><li>读取 <code>&lt;filename&gt;</code> 的内容，创建一个新的 Blob 对象。</li><li>将这个 Blob 对象的信息更新到<strong>暂存区</strong>。</li></ol></li><li><code>git commit -m &quot;Your message&quot;</code>: <ol><li>根据<strong>暂存区</strong>的内容，创建一系列 Tree 对象。</li><li>创建一个新的 Commit 对象，让它指向顶层 Tree，并设置其父提交为当前 <code>HEAD</code> 指向的 Commit。</li><li>将<strong>当前分支</strong>的引用（例如 <code>master</code>）移动到这个新创建的 Commit 上。</li></ol></li><li><code>git log</code>: 从 <code>HEAD</code> 开始，沿着父提交指针回溯，显示提交历史。 <ul><li><code>git log --all --graph --decorate --oneline</code>: 一个非常有用的别名，可以清晰地可视化分支和合并历史。</li></ul></li><li><code>git diff</code>: <ul><li><code>git diff</code>: 显示<strong>工作区</strong>和<strong>暂存区</strong>之间的差异。</li><li><code>git diff --staged</code>: 显示<strong>暂存区</strong>和上一次<strong>提交</strong>之间的差异。</li></ul></li></ul><h4 id="分支与合并" tabindex="-1">分支与合并 <a class="header-anchor" href="#分支与合并" aria-label="Permalink to &quot;分支与合并&quot;">​</a></h4><ul><li><code>git branch &lt;name&gt;</code>: 创建一个新的分支（引用），让它指向<strong>当前 <code>HEAD</code> 所在的 Commit</strong>。<strong>这只是创建了一个指针，并不会切换过去。</strong></li><li><code>git checkout &lt;name&gt;</code> (或 <code>git switch &lt;name&gt;</code>): <ol><li>将 <code>HEAD</code> 引用移动到 <code>&lt;name&gt;</code> 分支上。</li><li>将<strong>工作区</strong>的文件内容更新为该分支所指向的 Commit 的快照。</li></ol></li><li><code>git checkout -b &lt;name&gt;</code>: 创建新分支并立即切换过去（<code>branch</code> + <code>checkout</code> 的组合）。</li><li><code>git merge &lt;revision&gt;</code>: 将 <code>&lt;revision&gt;</code> 分支的历史合并到当前分支。Git 会找到两个分支的共同祖先，并创建一个新的“合并提交”，这个提交会有<strong>两个父提交</strong>。</li></ul><h4 id="远程协作" tabindex="-1">远程协作 <a class="header-anchor" href="#远程协作" aria-label="Permalink to &quot;远程协作&quot;">​</a></h4><ul><li><code>git clone &lt;url&gt;</code>: 从远程服务器下载一个完整的仓库副本，包括所有历史记录。</li><li><code>git remote add &lt;name&gt; &lt;url&gt;</code>: 添加一个远程仓库的“书签”，通常默认名为 <code>origin</code>。</li><li><code>git fetch &lt;remote&gt;</code>: 从远程仓库下载你本地没有的对象和引用（如 <code>origin/master</code>），但<strong>不会修改你本地的分支或工作区</strong>。</li><li><code>git pull &lt;remote&gt;</code>: 拉取远程更新并合并。它基本上是 <code>git fetch</code> + <code>git merge</code> 的组合。</li><li><code>git push &lt;remote&gt; &lt;branch&gt;</code>: 将你本地的提交上传到远程仓库，并更新远程仓库的分支引用。</li></ul><h4 id="撤销操作" tabindex="-1">撤销操作 <a class="header-anchor" href="#撤销操作" aria-label="Permalink to &quot;撤销操作&quot;">​</a></h4><ul><li><code>git commit --amend</code>: 用暂存区的内容创建一个<strong>新的</strong> Commit，来<strong>替换</strong>掉当前分支的最新一次 Commit。用于修改最后一次提交的信息或内容。</li><li><code>git reset HEAD &lt;file&gt;</code>: 将文件从<strong>暂存区</strong>中移除，但保留在<strong>工作区</strong>的修改。</li><li><code>git checkout -- &lt;file&gt;</code> (或 <code>git restore &lt;file&gt;</code>): <strong>丢弃</strong>在<strong>工作区</strong>中对文件的修改，用暂- 存区中的版本覆盖它。</li></ul><h3 id="课后练习-4" tabindex="-1">课后练习 <a class="header-anchor" href="#课后练习-4" aria-label="Permalink to &quot;课后练习&quot;">​</a></h3><ol><li><strong>基础学习</strong>：如果你是 Git 新手，强烈推荐完成 <a href="https://learngitbranching.js.org/" target="_blank" rel="noreferrer">Learn Git Branching</a> 教程，它能以可视化的方式帮助你理解分支操作。</li><li><strong>仓库探索</strong>： <ul><li>克隆本课程网站的仓库: <code>git clone https://github.com/missing-semester-cn/missing-semester-cn.github.io.git</code></li><li>进入该目录，使用 <code>git log --all --graph --decorate --oneline</code> 可视化历史记录。</li><li>找出最后一次修改 <code>README.md</code> 文件的人是谁？(提示: <code>git log -- README.md</code>)</li><li>找出 <code>_config.yml</code> 文件中 <code>collections:</code> 这一行，最后一次是被哪次提交修改的？提交信息是什么？(提示: <code>git blame _config.yml</code> 会告诉你每一行的最后修改信息，然后用 <code>git show &lt;commit_hash&gt;</code> 查看该次提交的详情)。</li></ul></li><li><strong>历史修改</strong>： <ul><li>在本地仓库中，创建一个新文件，并提交它。</li><li>现在，假装这个文件包含敏感信息，你需要从整个项目的历史中彻底删除它。参考<a href="https://help.github.com/articles/removing-sensitive-data-from-a-repository/" target="_blank" rel="noreferrer">这篇文章</a>来完成这个挑战。</li></ul></li><li><strong>配置别名</strong>： <ul><li>编辑你的全局 Git 配置文件 <code>~/.gitconfig</code>。</li><li>在 <code>[alias]</code> 部分添加一个别名 <code>graph</code>，使其成为 <code>log --all --graph --decorate --oneline</code> 的简写。之后，你就可以直接运行 <code>git graph</code> 了。</li></ul></li><li><strong>全局 <code>.gitignore</code></strong>： <ul><li>创建一个 <code>~/.gitignore_global</code> 文件。</li><li>在其中添加常见的系统或编辑器临时文件，例如 <code>.DS_Store</code>, <code>*.swp</code>, <code>*~</code> 等。</li><li>运行 <code>git config --global core.excludesfile ~/.gitignore_global</code> 来让这个全局忽略文件生效。</li></ul></li></ol><h2 id="元编程-metaprogramming" tabindex="-1">元编程 (Metaprogramming) <a class="header-anchor" href="#元编程-metaprogramming" aria-label="Permalink to &quot;元编程 (Metaprogramming)&quot;">​</a></h2><p>本教程将深入探讨软件开发中的“元”流程：构建、测试和依赖管理。这些技能在处理任何规模的项目时都至关重要。</p><h3 id="什么是-元编程" tabindex="-1">什么是“元编程”？ <a class="header-anchor" href="#什么是-元编程" aria-label="Permalink to &quot;什么是“元编程”？&quot;">​</a></h3><p>首先，我们需要厘清“元编程”在本课程中的含义。</p><ul><li><strong>经典定义</strong>: 元编程指的是编写“能操作程序的程序”。这意味着代码可以读取、生成、分析甚至在运行时修改自己或其他程序。这通常通过反射（Reflection）或宏（Macros）等技术实现。</li><li><strong>本课程的定义</strong>: 这里，我们借用这个词来涵盖更广泛的“关于编程的编程”流程。它不侧重于代码修改代码，而是关注<strong>如何自动化和管理整个软件开发周期</strong>，包括： <ul><li><strong>构建系统 (Build Systems)</strong>: 如何将源代码和其他资源自动编译、打包成最终产品。</li><li><strong>依赖管理 (Dependency Management)</strong>: 如何处理和版本化你的项目所依赖的外部库和工具。</li><li><strong>持续集成 (Continuous Integration)</strong>: 如何在代码变更时自动运行构建和测试流程。</li><li><strong>软件测试 (Software Testing)</strong>: 保证代码质量和功能正确性的基本原则。</li></ul></li></ul><h3 id="构建系统-使用-make-自动化流程" tabindex="-1">构建系统：使用 <code>make</code> 自动化流程 <a class="header-anchor" href="#构建系统-使用-make-自动化流程" aria-label="Permalink to &quot;构建系统：使用 `make` 自动化流程&quot;">​</a></h3><p>几乎所有项目，从编译代码到生成论文，都有一系列需要执行的命令。手动重复运行这些命令既繁琐又容易出错。构建系统就是为了解决这个问题而生的。</p><p><code>make</code> 是一个经典且功能强大的构建工具，通过一个名为 <code>Makefile</code> 的文件来定义构建规则。</p><h4 id="makefile-的核心概念" tabindex="-1"><code>Makefile</code> 的核心概念 <a class="header-anchor" href="#makefile-的核心概念" aria-label="Permalink to &quot;`Makefile` 的核心概念&quot;">​</a></h4><p><code>Makefile</code> 由一系列<strong>规则 (rules)</strong> 组成，基本语法如下：</p><div class="language-makefile vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">makefile</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">target</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: dependency1 dependency2 ...</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    &lt;tab&gt; command1</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    &lt;tab&gt; command2</span></span></code></pre></div><ul><li><strong><code>target</code> (目标)</strong>: 你想要生成的文件名，例如 <code>paper.pdf</code> 或 <code>program</code>。</li><li><strong><code>dependencies</code> (依赖)</strong>: 构建目标所需要的文件或其他的目标。</li><li><strong><code>command</code> (命令)</strong>: 从依赖构建目标的具体 Shell 命令。<strong>极其重要：命令行的开头必须是一个 <code>Tab</code> 字符，而不是空格！</strong></li></ul><p><code>make</code> 的工作逻辑是：</p><ol><li>检查目标文件是否存在。</li><li>如果目标文件不存在，或者<strong>任何一个依赖文件比目标文件更新</strong>，那么就执行相应的命令来重新生成目标。</li><li>如果目标文件及其所有依赖都存在，并且目标文件是更新的，那么 <code>make</code> 就什么也不做，因为没有必要。</li></ol><h4 id="实例解析" tabindex="-1">实例解析 <a class="header-anchor" href="#实例解析" aria-label="Permalink to &quot;实例解析&quot;">​</a></h4><p>让我们分解课程讲义中的 <code>Makefile</code> 示例：</p><div class="language-makefile vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">makefile</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">## 规则 1: 默认目标</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">paper.pdf</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: paper.tex plot-data.png</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">	pdflatex paper.tex</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">## 规则 2: 模式规则</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">plot-</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">%</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">.png</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">%</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.dat plot.py</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">	./plot.py -i </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">$*</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.dat -o </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">$@</span></span></code></pre></div><p><strong>分析:</strong></p><ol><li><strong>默认目标</strong>: 当你只输入 <code>make</code> 命令时，<code>make</code> 会构建 <code>Makefile</code> 中的第一个目标，这里是 <code>paper.pdf</code>。</li><li><strong>规则 1</strong>: 要构建 <code>paper.pdf</code>，<code>make</code> 需要 <code>paper.tex</code> 和 <code>plot-data.png</code> 这两个文件。如果这两个文件中的任何一个比 <code>paper.pdf</code> 更新，<code>make</code> 就会运行 <code>pdflatex paper.tex</code> 命令。</li><li><strong>规则 2 (模式规则)</strong>: 这是一个更通用的规则。<code>%</code> 是一个通配符。 <ul><li>它表示：任何以 <code>.png</code> 结尾的目标（如 <code>plot-data.png</code>），都依赖于一个同名但以 <code>.dat</code> 结尾的文件（<code>data.dat</code>）以及 <code>plot.py</code>。</li><li><strong>特殊变量</strong>: <ul><li><code>$@</code>: 代表规则中的目标文件名 (e.g., <code>plot-data.png</code>)。</li><li><code>$*</code>: 代表模式 <code>％</code> 匹配到的部分 (e.g., <code>data</code>)。</li></ul></li></ul></li></ol><h4 id="make-的执行流程" tabindex="-1"><code>make</code> 的执行流程 <a class="header-anchor" href="#make-的执行流程" aria-label="Permalink to &quot;`make` 的执行流程&quot;">​</a></h4><p>当你第一次在目录下运行 <code>make</code>：</p><ol><li><code>make</code> 想构建 <code>paper.pdf</code>。</li><li>它发现 <code>paper.pdf</code> 依赖于 <code>paper.tex</code> 和 <code>plot-data.png</code>。</li><li>它发现 <code>paper.tex</code> 存在，但 <code>plot-data.png</code> 不存在。</li><li>它在 <code>Makefile</code> 中寻找一个可以生成 <code>plot-data.png</code> 的规则，并找到了模式规则 <code>plot-%.png</code>。</li><li>这个模式规则需要 <code>data.dat</code> 和 <code>plot.py</code>。假设这两个文件都存在。</li><li><code>make</code> 执行 <code>./plot.py -i data.dat -o plot-data.png</code> 来生成 <code>plot-data.png</code>。</li><li>现在 <code>paper.pdf</code> 的所有依赖都准备好了，<code>make</code> 执行 <code>pdflatex paper.tex</code> 来生成最终的 PDF。</li></ol><h4 id="phony-targets-伪目标" tabindex="-1">Phony Targets (伪目标) <a class="header-anchor" href="#phony-targets-伪目标" aria-label="Permalink to &quot;Phony Targets (伪目标)&quot;">​</a></h4><p>有些目标，如 <code>clean</code> 或 <code>install</code>，并不代表一个要生成的文件。它们只是一个需要执行的动作标签。为了避免与同名文件冲突，并确保命令总是执行，我们将它们声明为伪目标。</p><div class="language-makefile vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">makefile</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">## ... 其他规则 ...</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">## clean 目标用于删除所有生成的文件</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">clean</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">	rm -f *.pdf *.png</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">## 将 clean 声明为伪目标</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">.PHONY</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: clean</span></span></code></pre></div><p>现在，运行 <code>make clean</code> 将总是会执行 <code>rm</code> 命令，即使目录下恰好有一个名为 <code>clean</code> 的文件。</p><h3 id="依赖管理" tabindex="-1">依赖管理 <a class="header-anchor" href="#依赖管理" aria-label="Permalink to &quot;依赖管理&quot;">​</a></h3><p>现代软件开发很少从零开始，我们总是站在巨人的肩膀上，使用他人编写的库和工具。这些外部的代码就是<strong>依赖</strong>。</p><h4 id="包管理器和软件仓库" tabindex="-1">包管理器和软件仓库 <a class="header-anchor" href="#包管理器和软件仓库" aria-label="Permalink to &quot;包管理器和软件仓库&quot;">​</a></h4><p>为了方便地获取和管理依赖，我们使用<strong>包管理器 (Package Managers)</strong>。它们会从集中的<strong>软件仓库 (Repositories)</strong> 中下载、安装和管理依赖。</p><table tabindex="0"><thead><tr><th style="text-align:left;">领域</th><th style="text-align:left;">包管理器</th><th style="text-align:left;">软件仓库</th></tr></thead><tbody><tr><td style="text-align:left;"><strong>操作系统 (Debian/Ubuntu)</strong></td><td style="text-align:left;"><code>apt</code></td><td style="text-align:left;">Ubuntu Packages</td></tr><tr><td style="text-align:left;"><strong>操作系统 (macOS)</strong></td><td style="text-align:left;"><code>brew</code> (Homebrew)</td><td style="text-align:left;">Homebrew Core</td></tr><tr><td style="text-align:left;"><strong>Python</strong></td><td style="text-align:left;"><code>pip</code>, <code>poetry</code></td><td style="text-align:left;">PyPI (Python Package Index)</td></tr><tr><td style="text-align:left;"><strong>JavaScript/Node.js</strong></td><td style="text-align:left;"><code>npm</code>, <code>yarn</code></td><td style="text-align:left;">npm Registry</td></tr><tr><td style="text-align:left;"><strong>Java</strong></td><td style="text-align:left;"><code>Maven</code>, <code>Gradle</code></td><td style="text-align:left;">Maven Central</td></tr><tr><td style="text-align:left;"><strong>Rust</strong></td><td style="text-align:left;"><code>cargo</code></td><td style="text-align:left;">Crates.io</td></tr></tbody></table><h4 id="版本控制与语义版本号-semantic-versioning" tabindex="-1">版本控制与语义版本号 (Semantic Versioning) <a class="header-anchor" href="#版本控制与语义版本号-semantic-versioning" aria-label="Permalink to &quot;版本控制与语义版本号 (Semantic Versioning)&quot;">​</a></h4><p>当你依赖一个库时，你不能总是使用它的最新版本，因为新版本可能会引入不兼容的改动，导致你的代码崩溃。因此，我们需要精确地管理依赖的版本。</p><p><strong>语义版本号 (SemVer)</strong> 是一个被广泛采纳的版本号标准，格式为 <code>主版本号.次版本号.补丁号</code> (MAJOR.MINOR.PATCH)，例如 <code>1.3.7</code>。</p><ul><li><strong>PATCH (补丁号)</strong>: 递增此版本号，表示你修复了一些 bug，但没有改变任何功能接口 (API)。这些改动是完全向后兼容的。</li><li><strong>MINOR (次版本号)</strong>: 递增此版本号，表示你增加了一些新功能，但仍然保持向后兼容。</li><li><strong>MAJOR (主版本号)</strong>: 递增此版本号，表示你做了<strong>不向后兼容</strong>的 API 修改。</li></ul><p>这个约定非常有用。如果你的项目依赖 <code>1.3.7</code> 版本，那么你可以安全地升级到 <code>1.3.8</code> 或 <code>1.6.1</code>，但升级到 <code>2.0.0</code> 就需要小心了，因为它可能需要你修改自己的代码来适配。</p><h4 id="锁文件-lock-files" tabindex="-1">锁文件 (Lock Files) <a class="header-anchor" href="#锁文件-lock-files" aria-label="Permalink to &quot;锁文件 (Lock Files)&quot;">​</a></h4><p>即使你指定了版本范围（例如 <code>^1.3.7</code>，表示可以使用 <code>1.x.x</code> 系列的任何新版本），为了保证团队中每个开发者和最终部署时使用的依赖版本<strong>完全一致</strong>，包管理器会生成一个<strong>锁文件</strong>（如 <code>package-lock.json</code>, <code>poetry.lock</code>）。</p><p>这个文件会记录下当前安装的每个依赖的<strong>确切版本号</strong>。这确保了构建是<strong>可复现的 (reproducible)</strong>。</p><h3 id="持续集成-continuous-integration-ci" tabindex="-1">持续集成 (Continuous Integration, CI) <a class="header-anchor" href="#持续集成-continuous-integration-ci" aria-label="Permalink to &quot;持续集成 (Continuous Integration, CI)&quot;">​</a></h3><p>持续集成是一种开发实践，它会自动地在你每次提交代码时执行一系列任务，例如：</p><ul><li>运行代码风格检查 (Linting)</li><li>构建项目</li><li>运行所有测试</li><li>部署到服务器</li></ul><p><strong>工作流程:</strong></p><ol><li>你在本地修改代码，并推送到代码托管平台（如 GitHub）。</li><li>该平台检测到代码变更，并通知 CI 服务（如 GitHub Actions, Travis CI）。</li><li>CI 服务启动一个干净的虚拟机，拉取你的最新代码。</li><li>CI 服务根据你项目中的配置文件（例如 <code>.github/workflows/main.yml</code>），执行你定义好的所有命令。</li><li>CI 服务报告结果（成功或失败）。如果失败，团队会收到通知，以便立即修复问题。</li></ol><p>这确保了代码库中的代码永远处于一个可工作、已测试的状态。</p><p><strong>示例：一个简单的 GitHub Actions 配置文件</strong> 在你的项目根目录下创建 <code>.github/workflows/main.yml</code>:</p><div class="language-yaml vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">yaml</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">name</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">CI</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">## 当有代码 push 到 main 分支时触发</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">on</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">  push</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">    branches</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: [ </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">main</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ]</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">jobs</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">  build-and-test</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    ## 在最新的 Ubuntu 虚拟机上运行</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">    runs-on</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">ubuntu-latest</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">    steps</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    ## 1. 拉取你的代码到虚拟机</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    - </span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">uses</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">actions/checkout@v2</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    ## 2. 设置 Python 3.8 环境</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    - </span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">name</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">Set up Python 3.8</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">      uses</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">actions/setup-python@v2</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">      with</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">        python-version</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">3.8</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    ## 3. 安装项目依赖</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    - </span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">name</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">Install dependencies</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">      run</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">|</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">        python -m pip install --upgrade pip</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">        pip install -r requirements.txt</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    ## 4. 运行测试</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    - </span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">name</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">Run tests</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">      run</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">|</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">        python -m pytest</span></span></code></pre></div><h3 id="测试简介" tabindex="-1">测试简介 <a class="header-anchor" href="#测试简介" aria-label="Permalink to &quot;测试简介&quot;">​</a></h3><p>软件测试是保证代码质量的基石。一个好的测试套件能让你在修改或添加功能时充满信心。</p><h4 id="关键测试术语" tabindex="-1">关键测试术语 <a class="header-anchor" href="#关键测试术语" aria-label="Permalink to &quot;关键测试术语&quot;">​</a></h4><ul><li><strong>测试套件 (Test Suite)</strong>: 项目中所有测试的总称。</li><li><strong>单元测试 (Unit Test)</strong>: 粒度最小的测试，专注于测试一个独立的函数或模块的功能是否正确。就像测试一块乐高积木是否合格。</li><li><strong>集成测试 (Integration Test)</strong>: 测试多个组件协同工作时是否正常。就像测试几块乐高积木拼在一起后是否稳固。</li><li><strong>回归测试 (Regression Test)</strong>: 当一个 bug 被发现并修复后，专门为这个 bug 编写一个测试。这个测试确保该 bug 将来不会再次出现。</li><li><strong>模拟 (Mocking)</strong>: 在测试中，用一个“假的”实现来替换一个真实的依赖（如数据库连接、网络请求）。这可以让你的测试更专注于被测单元本身，而不会受到外部因素的干扰。</li></ul><h3 id="课后练习-5" tabindex="-1">课后练习 <a class="header-anchor" href="#课后练习-5" aria-label="Permalink to &quot;课后练习&quot;">​</a></h3><ol><li><strong>为 Makefile 添加 <code>clean</code> 目标</strong>: <ul><li>为教程中的 <code>Makefile</code> 添加一个 <code>clean</code> 伪目标 (<code>.PHONY: clean</code>)。</li><li><code>clean</code> 目标应该能删除所有构建生成的文件（如 <code>.pdf</code> 和 <code>.png</code> 文件），让目录恢复到干净状态。</li></ul></li><li><strong>理解版本要求</strong>: <ul><li>研究 <a href="https://doc.rust-lang.org/cargo/reference/specifying-dependencies.html" target="_blank" rel="noreferrer">Rust Cargo 的依赖指定语法</a>。</li><li>对于尖号 (<code>^1.2.3</code>)、波浪号 (<code>~1.2.3</code>)、通配符 (<code>*</code>) 等不同的版本约束，分别设想一个使用场景。</li></ul></li><li><strong>使用 Git 钩子</strong>: <ul><li>在任意一个 Git 仓库的 <code>.git/hooks</code> 目录下，找到 <code>pre-commit.sample</code> 文件。</li><li>将其重命名为 <code>pre-commit</code> 并编写一个脚本：在每次 <code>git commit</code> 之前，自动运行 <code>make</code>。如果 <code>make</code> 失败，则中断本次提交。</li></ul></li><li><strong>设置 GitHub Actions</strong>: <ul><li>创建一个新的 GitHub 仓库，并基于 <a href="https://pages.github.com/" target="_blank" rel="noreferrer">GitHub Pages</a> 创建一个简单的个人页面。</li><li>为该仓库添加一个 GitHub Action，对仓库中所有的 Shell 脚本 (<code>.sh</code> 文件) 执行 <code>shellcheck</code> 检查。</li></ul></li><li><strong>构建自己的 GitHub Action</strong>: <ul><li>尝试<a href="https://help.github.com/en/actions/automating-your-workflow-with-github-actions/building-actions" target="_blank" rel="noreferrer">构建一个自己的 GitHub Action</a>。</li><li>这个 Action 的功能是：对仓库中所有的 Markdown 文件 (<code>.md</code>) 执行 <code>proselint</code> 或 <code>write-good</code> 这样的写作风格检查工具。</li><li>在你的仓库中启用这个 Action，并故意提交一个有语法错误的文件来验证它是否能正常工作。</li></ul></li></ol><h2 id="安全与密码学" tabindex="-1">安全与密码学 <a class="header-anchor" href="#安全与密码学" aria-label="Permalink to &quot;安全与密码学&quot;">​</a></h2><p>本教程将深入探讨一些在现代计算机工具（如 Git 和 SSH）背后默默工作的核心安全与密码学概念。理解这些基本原理，能帮助你更好地认识我们所使用的工具，并建立起更完善的安全观。</p><p><strong>注意</strong>：本教程旨在普及概念，而非培养密码学专家。请切勿自行设计或修改加密算法，这是一项需要深厚专业知识的工作。</p><h3 id="熵-衡量密码的真正强度" tabindex="-1">熵：衡量密码的真正强度 <a class="header-anchor" href="#熵-衡量密码的真正强度" aria-label="Permalink to &quot;熵：衡量密码的真正强度&quot;">​</a></h3><p>我们常常被告知要使用“复杂”的密码，比如 <code>Tr0ub4dor&amp;3</code>。但一个更长、看似更简单的密码，如 <code>correcthorsebatterystaple</code>，实际上可能安全得多。衡量这种“强度”的科学标准，就是<strong>熵 (Entropy)</strong>。</p><h4 id="什么是熵" tabindex="-1">什么是熵？ <a class="header-anchor" href="#什么是熵" aria-label="Permalink to &quot;什么是熵？&quot;">​</a></h4><p>在信息安全领域，熵是<strong>不确定性</strong>的度量。一个密码的熵越高，意味着它包含的不确定性越大，攻击者猜中它的难度也就越高。</p><p>熵的单位是<strong>比特 (bit)</strong>。一个系统的熵可以通过以下公式计算： <code>熵 (比特) = log₂(可能组合的总数)</code></p><ul><li><strong>抛硬币</strong>: 只有正反两种可能，所以熵是 <code>log₂(2) = 1</code> 比特。</li><li><strong>掷六面骰子</strong>: 有六种可能，熵是 <code>log₂(6) ≈ 2.58</code> 比特。</li></ul><h4 id="计算密码的熵" tabindex="-1">计算密码的熵 <a class="header-anchor" href="#计算密码的熵" aria-label="Permalink to &quot;计算密码的熵&quot;">​</a></h4><p>假设攻击者了解密码的构成规则（比如“8位随机字母和数字”），我们可以计算出其熵。</p><ul><li><p><strong>例1: <code>rg8Ql34g</code></strong></p><ul><li><strong>字符池 (R)</strong>: 26个小写字母 + 26个大写字母 + 10个数字 = 62种可能。</li><li><strong>长度 (L)</strong>: 8位。</li><li><strong>可能组合总数</strong>: 62⁸</li><li><strong>熵</strong>: <code>log₂(62⁸) = 8 * log₂(62) ≈ 8 * 5.95 ≈ 47.6</code> 比特。</li></ul></li><li><p><strong>例2: <code>correcthorsebatterystaple</code></strong></p><ul><li><strong>字符池 (R)</strong>: 从一个包含10万个单词的词典中随机选择。</li><li><strong>长度 (L)</strong>: 4个单词。</li><li><strong>可能组合总数</strong>: (100,000)⁴</li><li><strong>熵</strong>: <code>log₂((10⁵)⁴) = 4 * log₂(10⁵) ≈ 4 * 16.6 ≈ 66.4</code> 比特。</li></ul></li></ul><p><strong>结论</strong>：<code>correcthorsebatterystaple</code> 的熵远高于 <code>rg8Ql34g</code>，因此它是一个更强的密码。 长度对密码强度的贡献通常比字符复杂性更大。</p><h3 id="哈希函数-数据的数字指纹" tabindex="-1">哈希函数：数据的数字指纹 <a class="header-anchor" href="#哈希函数-数据的数字指纹" aria-label="Permalink to &quot;哈希函数：数据的数字指纹&quot;">​</a></h3><p>密码学哈希函数（或称散列函数）是一种特殊的数学函数，它可以将<strong>任意大小</strong>的输入数据，转换成一个<strong>固定大小</strong>的输出，这个输出被称为<strong>哈希值 (Hash)</strong> 或<strong>摘要 (Digest)</strong>。</p><p>你可以把它想象成一个数据的“指纹”生成器。</p><div class="language-console vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">console</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">## 对 &quot;hello&quot; 进行 SHA-1 哈希</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">$ printf </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;hello&#39;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> |</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> sha1sum</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">aaf4c61ddcc5e8a2dabede0f3b482cd9aea9434d</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">## 即使输入只改变一个字母的大小写，输出也面目全非</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">$ printf </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;Hello&#39;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> |</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> sha1sum</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">f7ff9e8b7bb2e09b70935a5d785e0cc5d9d0abf0</span></span></code></pre></div><h4 id="核心特性" tabindex="-1">核心特性 <a class="header-anchor" href="#核心特性" aria-label="Permalink to &quot;核心特性&quot;">​</a></h4><p>一个理想的加密哈希函数必须具备以下特性：</p><ol><li><strong>确定性</strong>: 相同的输入永远会产生相同的输出。</li><li><strong>高效性</strong>: 计算一个输入的哈希值必须非常快。</li><li><strong>不可逆性 (单向性)</strong>: 从哈希值反推出原始输入，在计算上是不可行的。这就像你无法从指纹复原出整个人的样貌。</li><li><strong>雪崩效应</strong>: 输入的任何微小变化（哪怕只改一个比特）都会导致输出的哈希值发生巨大且不可预测的变化。</li><li><strong>抗碰撞性</strong>: 找到两个不同的输入，使得它们的哈希值相同，在计算上是不可行的。</li></ol><h4 id="应用场景" tabindex="-1">应用场景 <a class="header-anchor" href="#应用场景" aria-label="Permalink to &quot;应用场景&quot;">​</a></h4><ul><li><strong>文件完整性校验</strong>: 你从镜像站下载了一个 Linux ISO 文件，网站会提供官方的 SHA256 哈希值。你在本地计算下载文件的哈希值，如果两者一致，就证明文件在下载过程中没有被篡改或损坏。</li><li><strong>Git 的内容存储</strong>: Git 为你的每一次提交、每一个文件都生成一个哈希值作为其唯一ID。正是基于哈希的不可逆性和抗碰撞性，Git 才能确保历史记录的完整和不可篡改。</li><li><strong>密码存储</strong>: 网站绝不能明文存储你的密码。它们存储的是 <code>KDF(密码 + 盐)</code> 的结果。<code>KDF</code> (密钥生成函数) 是一种特殊的、更慢的哈希函数，而<code>盐 (salt)</code> 是为每个用户生成的随机字符串，用来抵御“彩虹表攻击”。</li></ul><h3 id="对称加密-一把钥匙锁天下" tabindex="-1">对称加密：一把钥匙锁天下 <a class="header-anchor" href="#对称加密-一把钥匙锁天下" aria-label="Permalink to &quot;对称加密：一把钥匙锁天下&quot;">​</a></h3><p>对称加密是最直观的加密方式。它使用<strong>同一个密钥</strong>来进行加密和解密。</p><ul><li><strong>工作流程</strong>: <ol><li><code>keygen()</code> -&gt; <code>密钥</code></li><li><code>encrypt(明文, 密钥)</code> -&gt; <code>密文</code></li><li><code>decrypt(密文, 密钥)</code> -&gt; <code>明文</code></li></ol></li></ul><p><strong>类比</strong>: 就像你家的门锁，你用一把钥匙锁门，也用<strong>同一把钥匙</strong>开门。</p><ul><li><strong>优点</strong>: 加密解密速度非常快，适合对大量数据进行加密。</li><li><strong>缺点</strong>: <strong>密钥分发难题</strong>。如何将这把唯一的密钥安全地送到接收方手中？如果在网络上传输，密钥本身就可能被窃取。</li><li><strong>常见算法</strong>: AES (Advanced Encryption Standard) 是目前最广泛使用的标准。</li></ul><p><strong>应用场景</strong>: 加密存储在云盘上的个人文件。你可以用一个密码通过密钥生成函数（KDF）派生出一个密钥，然后用这个密钥加密文件。</p><h3 id="非对称加密-公开的锁-私有的钥匙" tabindex="-1">非对称加密：公开的锁，私有的钥匙 <a class="header-anchor" href="#非对称加密-公开的锁-私有的钥匙" aria-label="Permalink to &quot;非对称加密：公开的锁，私有的钥匙&quot;">​</a></h3><p>为了解决对称加密的密钥分发难题，非对称加密应运而生。它使用<strong>一对</strong>密钥：<strong>公钥 (Public Key)</strong> 和 <strong>私钥 (Private Key)</strong>。</p><ul><li><strong>公钥</strong>: 可以随意分发，公之于众，就像一把打开的挂锁。</li><li><strong>私钥</strong>: 必须由本人严格保密，绝不外泄，是能打开这把挂锁的唯一钥匙。</li></ul><p>这对密钥有两个核心用途：</p><h4 id="用途一-加密与解密-实现机密性" tabindex="-1">用途一：加密与解密（实现机密性） <a class="header-anchor" href="#用途一-加密与解密-实现机密性" aria-label="Permalink to &quot;用途一：加密与解密（实现机密性）&quot;">​</a></h4><ul><li><strong>加密</strong>: 任何人都可以用你的<strong>公钥</strong>来加密信息。</li><li><strong>解密</strong>: 只有拥有对应<strong>私钥</strong>的你，才能解密这些信息。</li></ul><p><strong>工作流程</strong>:</p><ol><li>A 想给 B 发送秘密信息。</li><li>A 获取 B 的<strong>公钥</strong>。</li><li>A 用 B 的<strong>公钥</strong>加密信息，然后发送出去。</li><li>B 收到密文后，用自己的<strong>私钥</strong>解密，读取信息。</li></ol><p>即使中间有人截获了密文，因为没有 B 的私钥，也无法解密。</p><h4 id="用途二-签名与验证-实现认证与完整性" tabindex="-1">用途二：签名与验证（实现认证与完整性） <a class="header-anchor" href="#用途二-签名与验证-实现认证与完整性" aria-label="Permalink to &quot;用途二：签名与验证（实现认证与完整性）&quot;">​</a></h4><ul><li><strong>签名</strong>: 你可以用自己的<strong>私钥</strong>对一段数据的哈希值进行“签名”。</li><li><strong>验证</strong>: 任何人都可以用你的<strong>公钥</strong>来验证这个签名是否真实有效。</li></ul><p><strong>工作流程</strong>:</p><ol><li>A 要发布一个软件，为了防止别人冒充，A 先计算软件的哈希值。</li><li>A 用自己的<strong>私钥</strong>对这个哈希值进行签名。</li><li>A 将软件、签名、以及自己的公钥一同发布。</li><li>用户下载后，用 A 的<strong>公钥</strong>验证签名。如果验证通过，就证明： <ul><li><strong>认证</strong>: 这个软件确实是 A 发布的（因为只有 A 的私钥才能生成这个签名）。</li><li><strong>完整性</strong>: 软件从发布到下载，内容没有被篡改过（因为哈希值对得上）。</li></ul></li></ol><h3 id="案例分析-ssh-的工作原理" tabindex="-1">案例分析：SSH 的工作原理 <a class="header-anchor" href="#案例分析-ssh-的工作原理" aria-label="Permalink to &quot;案例分析：SSH 的工作原理&quot;">​</a></h3><p><code>ssh</code> 是我们每天都在使用的工具，它完美地结合了以上多种密码学技术，实现安全远程登录。</p><p><strong>连接过程分解</strong>:</p><ol><li><p><strong>密钥生成 (<code>ssh-keygen</code>)</strong>:</p><ul><li>你在本地运行 <code>ssh-keygen</code>，它会为你生成一对非对称密钥：<code>id_rsa</code> (私钥) 和 <code>id_rsa.pub</code> (公钥)。</li><li>系统会提示你为私钥设置一个<strong>密码 (passphrase)</strong>。这个密码通过 <strong>KDF</strong> 生成一个<strong>对称密钥</strong>，用来加密你的私钥文件，确保即使私钥文件被盗也不会立刻泄露。</li></ul></li><li><p><strong>建立连接与身份验证</strong>:</p><ul><li>你将你的<strong>公钥</strong> (<code>id_rsa.pub</code>) 放到远程服务器的 <code>~/.ssh/authorized_keys</code> 文件中。</li><li>当你执行 <code>ssh user@host</code> 时，连接开始。</li><li>服务器向你的客户端发送一个随机生成的字符串（<strong>挑战</strong>）。</li><li>你的客户端使用你的<strong>私钥</strong>对这个字符串进行<strong>签名</strong>，并将签名发回给服务器（<strong>应答</strong>）。</li><li>服务器在你 <code>authorized_keys</code> 文件里找到你的公钥，用它来<strong>验证</strong>客户端发回的签名。</li><li>如果验证成功，服务器就确认了你的身份——因为只有持有对应私钥的人才能正确完成挑战。这就是<strong>挑战-应答</strong>认证机制。</li></ul></li><li><p><strong>会话加密</strong>:</p><ul><li>一旦身份验证通过，非对称加密的使命就完成了。因为它计算速度较慢，不适合加密大量的实时数据。</li><li>此时，客户端和服务器会通过一个安全的密钥交换算法（如 Diffie-Hellman）协商出一个临时的<strong>对称会话密钥</strong>。</li><li>之后的所有通信数据，都由这个对称密钥进行加密，保证了高效和安全。连接断开后，这个密钥即被销毁。</li></ul></li></ol><p>总结一下，SSH 在：</p><ul><li><strong>认证时</strong>使用<strong>非对称加密</strong>（签名/验证）来确认你的身份。</li><li><strong>通信时</strong>使用<strong>对称加密</strong>来保护数据流。</li></ul><h3 id="课后练习-6" tabindex="-1">课后练习 <a class="header-anchor" href="#课后练习-6" aria-label="Permalink to &quot;课后练习&quot;">​</a></h3><ol><li><p><strong>熵计算</strong>:</p><ul><li>一个密码由4个随机的、从一个包含2048个单词的词典中选出的单词组成。它的熵是多少比特？</li><li>一个密码是10位的随机数字（0-9）。它的熵是多少比特？</li><li>哪个密码更强？破解它们分别需要多长时间（假设攻击者每秒尝试10亿次）？</li></ul></li><li><p><strong>哈希函数实践</strong>:</p><ul><li>找一个较大文件的下载链接（如 Ubuntu Desktop ISO）。</li><li>在下载页面找到官方提供的 <code>SHA256SUMS</code> 文件。</li><li>下载文件后，在你的终端里使用 <code>sha256sum [文件名]</code> 命令计算其哈希值。</li><li>对比你计算出的哈希值和官方提供的是否完全一致。</li></ul></li><li><p><strong>对称加密体验</strong>:</p><ul><li>创建一个名为 <code>secret.txt</code> 的文件，并写入一些文字。</li><li>使用 OpenSSL 对它进行 AES 加密：<code>openssl aes-256-cbc -salt -in secret.txt -out secret.enc</code> (会提示你输入密码)。</li><li>尝试用 <code>cat</code> 查看加密后的 <code>secret.enc</code> 文件，看看是什么内容。</li><li>使用命令解密文件：<code>openssl aes-256-cbc -d -in secret.enc -out decrypted.txt</code>。</li><li>使用 <code>diff secret.txt decrypted.txt</code> 命令，确认解密后的文件和原文件完全相同。</li></ul></li><li><p><strong>非对称加密应用</strong>:</p><ul><li>如果你还没有 SSH 密钥对，使用 <code>ssh-keygen -t ed25519</code> 命令生成一个。务必为你的私钥设置一个健壮的密码。</li><li>将你的公钥配置到 GitHub 或 GitLab 账户中。</li><li>尝试使用 <code>git commit -S</code> 命令对你的一个 Git 提交进行 GPG/SSH 签名，并用 <code>git log --show-signature</code> 查看签名验证信息。</li></ul></li></ol><h2 id="程序员的-大杂烩-工具箱" tabindex="-1">程序员的“大杂烩”工具箱 <a class="header-anchor" href="#程序员的-大杂烩-工具箱" aria-label="Permalink to &quot;程序员的“大杂烩”工具箱&quot;">​</a></h2><p>除了核心的编程语言和算法知识，一名高效的开发者还需要掌握大量能够提升效率、简化工作流程的工具和概念。本章将介绍一系列这样的“大杂烩”主题，它们虽然零散，但每一个都可能在你的职业生涯中扮演重要角色。</p><hr><h3 id="修改键位映射-打造你的专属键盘" tabindex="-1">修改键位映射：打造你的专属键盘 <a class="header-anchor" href="#修改键位映射-打造你的专属键盘" aria-label="Permalink to &quot;修改键位映射：打造你的专属键盘&quot;">​</a></h3><p>键盘是你的主要生产力工具。花时间定制它，使其更符合你的习惯，是一项回报率极高的投资。通过软件，我们可以拦截键盘按下的信号，并将其替换为我们想要的操作。</p><h4 id="常见的键位修改建议" tabindex="-1">常见的键位修改建议 <a class="header-anchor" href="#常见的键位修改建议" aria-label="Permalink to &quot;常见的键位修改建议&quot;">​</a></h4><ul><li><strong>Caps Lock -&gt; Ctrl / Escape</strong>: Caps Lock 键位于键盘的黄金位置，但其功能使用频率极低。将其映射为更常用的 <code>Ctrl</code>（尤其对于需要频繁使用组合键的 Emacs 或终端用户）或 <code>Escape</code>（对于 Vim 用户）是首选改造。</li><li><strong>Media Keys</strong>: 将不常用的键（如 <code>PrtSc</code>）映射为播放/暂停、上一首/下一首等多媒体控制键。</li><li><strong>修饰键互换</strong>: 交换 <code>Ctrl</code> 和 <code>Meta</code> (Win/Cmd) 键，以统一不同操作系统下的使用习惯。</li></ul><h4 id="高级玩法-自动化与快捷指令" tabindex="-1">高级玩法：自动化与快捷指令 <a class="header-anchor" href="#高级玩法-自动化与快捷指令" aria-label="Permalink to &quot;高级玩法：自动化与快捷指令&quot;">​</a></h4><ul><li><strong>启动应用</strong>: 设置快捷键一键打开终端、浏览器或代码编辑器。</li><li><strong>输入常用文本</strong>: 映射一个组合键来快速输入你的邮箱地址、常用代码片段等。</li><li><strong>系统控制</strong>: 设置快捷键让电脑或显示器进入睡眠模式。</li><li><strong>序列与长按</strong>: <ul><li><strong>序列</strong>: 设置“连按五次 Shift”来切换一个特殊模式。</li><li><strong>单击 vs 长按</strong>: 实现“单击 Caps Lock 为 Escape，长按则为 Ctrl”的智能操作。</li></ul></li></ul><h4 id="推荐工具" tabindex="-1">推荐工具 <a class="header-anchor" href="#推荐工具" aria-label="Permalink to &quot;推荐工具&quot;">​</a></h4><ul><li><strong>macOS</strong>: <ul><li><a href="https://pqrs.org/osx/karabiner/" target="_blank" rel="noreferrer">Karabiner-Elements</a>: 功能极其强大的键位修改工具。</li><li><a href="https://github.com/koekeishiya/skhd" target="_blank" rel="noreferrer">skhd</a>: 轻量级的快捷键守护进程，常与窗口管理器配合使用。</li><li><a href="https://folivora.ai/" target="_blank" rel="noreferrer">BetterTouchTool</a>: 除了键盘，还能自定义触控板、鼠标等多种输入设备。</li></ul></li><li><strong>Linux</strong>: <ul><li><code>xmodmap</code>: 传统的 X11 键位映射工具。</li><li><a href="https://github.com/autokey/autokey" target="_blank" rel="noreferrer">Autokey</a>: 功能更丰富的自动化脚本工具。</li></ul></li><li><strong>Windows</strong>: <ul><li><a href="https://www.autohotkey.com/" target="_blank" rel="noreferrer">AutoHotkey</a>: Windows 平台上的自动化神器，通过脚本实现无限可能。</li><li><a href="https://www.randyrants.com/category/sharpkeys/" target="_blank" rel="noreferrer">SharpKeys</a>: 通过修改注册表来实现键位映射，简单直接。</li></ul></li><li><strong>硬件级 (跨平台)</strong>: <ul><li><a href="https://docs.qmk.fm/" target="_blank" rel="noreferrer">QMK Firmware</a>: 如果你拥有客制化机械键盘，可以通过刷写 QMK 固件，将键位设置直接保存在键盘硬件中，从而在任何电脑上都能享受一致的体验。</li></ul></li></ul><hr><h3 id="守护进程-daemons-让服务在后台默默运行" tabindex="-1">守护进程 (Daemons)：让服务在后台默默运行 <a class="header-anchor" href="#守护进程-daemons-让服务在后台默默运行" aria-label="Permalink to &quot;守护进程 (Daemons)：让服务在后台默默运行&quot;">​</a></h3><p><strong>守护进程 (Daemon)</strong> 是一种在后台运行、无需用户直接交互的特殊进程。它们是操作系统服务的基石，负责处理网络请求、管理硬件、定时执行任务等。通常，守护进程的程序名以 <code>d</code> 结尾，例如 <code>sshd</code> (SSH aemon)。</p><h4 id="使用-systemd-管理服务-linux" tabindex="-1">使用 <code>systemd</code> 管理服务 (Linux) <a class="header-anchor" href="#使用-systemd-管理服务-linux" aria-label="Permalink to &quot;使用 `systemd` 管理服务 (Linux)&quot;">​</a></h4><p>在现代 Linux 系统中，<code>systemd</code> 是管理守护进程和系统服务的标准工具。通过 <code>systemctl</code> 命令，你可以轻松地控制服务的生命周期。</p><ul><li><code>systemctl status sshd</code>: 查看 <code>sshd</code> 服务的当前状态。</li><li><code>systemctl start myapp</code>: 启动名为 <code>myapp</code> 的服务。</li><li><code>systemctl stop myapp</code>: 停止服务。</li><li><code>systemctl restart myapp</code>: 重启服务。</li><li><code>systemctl enable myapp</code>: 设置服务开机自启。</li><li><code>systemctl disable myapp</code>: 取消开机自启。</li></ul><h4 id="示例-创建一个自定义服务" tabindex="-1">示例：创建一个自定义服务 <a class="header-anchor" href="#示例-创建一个自定义服务" aria-label="Permalink to &quot;示例：创建一个自定义服务&quot;">​</a></h4><p>假设我们有一个 Python Web 应用 (<code>app.py</code>)，我们希望它能作为服务在后台持续运行。我们可以创建一个 <code>systemd</code> 服务文件：</p><p><strong>路径</strong>: <code>/etc/systemd/system/myapp.service</code></p><div class="language-ini vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">ini</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">[Unit]</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">## 服务的描述</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">Description</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=My Custom Python Web App</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">## 指定此服务在网络服务启动后才启动</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">After</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=network.target</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">[Service]</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">## 指定运行此服务的用户和用户组</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">User</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=myuser</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">Group</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=myuser</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">## 设置工作目录</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">WorkingDirectory</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=/home/myuser/projects/myapp</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">## 核心：定义如何启动服务的命令</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">ExecStart</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=/usr/bin/python3 /home/myuser/projects/myapp/app.py</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">## 定义失败后的行为：自动重启</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">Restart</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=on-failure</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">[Install]</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">## 定义此服务在哪个“运行级别”下被启用，multi-user.target 表示在多用户模式（无GUI）下即可启动</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">WantedBy</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=multi-user.target</span></span></code></pre></div><h4 id="cron-简单的定时任务" tabindex="-1"><code>cron</code>：简单的定时任务 <a class="header-anchor" href="#cron-简单的定时任务" aria-label="Permalink to &quot;`cron`：简单的定时任务&quot;">​</a></h4><p>如果你的需求只是“定期运行某个脚本”（例如每天凌晨备份数据库），那么使用 <code>cron</code> 是一个更轻量级的选择。<code>cron</code> 是一个专门用于执行定时任务的守护进程。</p><hr><h3 id="fuse-在用户空间中创造文件系统" tabindex="-1">FUSE：在用户空间中创造文件系统 <a class="header-anchor" href="#fuse-在用户空间中创造文件系统" aria-label="Permalink to &quot;FUSE：在用户空间中创造文件系统&quot;">​</a></h3><p>传统上，文件系统是操作系统内核的一部分，开发和调试都非常复杂。<strong>FUSE (Filesystem in Userspace)</strong> 打破了这一限制，它允许开发者在普通的用户程序中实现一套完整的文件系统逻辑。</p><h4 id="fuse-的应用场景" tabindex="-1">FUSE 的应用场景 <a class="header-anchor" href="#fuse-的应用场景" aria-label="Permalink to &quot;FUSE 的应用场景&quot;">​</a></h4><p>通过 FUSE，我们可以将各种数据源“伪装”成本地文件系统，让所有应用程序都能像操作本地文件一样与它们交互。</p><ul><li><strong><a href="https://github.com/libfuse/sshfs" target="_blank" rel="noreferrer">sshfs</a></strong>: 通过 SSH 连接，将远程服务器上的目录挂载到本地，像操作本地文件夹一样读写远程文件。</li><li><strong><a href="https://rclone.org/commands/rclone_mount/" target="_blank" rel="noreferrer">rclone mount</a></strong>: 将 Google Drive, Dropbox, S3 等云存储服务挂载为本地磁盘。</li><li><strong><a href="https://nuetzlich.net/gocryptfs/" target="_blank" rel="noreferrer">gocryptfs</a></strong>: 一个加密文件系统。文件在磁盘上是加密存储的，但挂载后你可以透明地读写未加密的内容。</li><li><strong><a href="https://borgbackup.readthedocs.io/en/stable/usage/mount.html" target="_blank" rel="noreferrer">borgbackup mount</a></strong>: 浏览你的 BorgBackup 备份仓库，像普通文件一样恢复单个文件。</li></ul><hr><h3 id="备份-数据安全的最后一道防线" tabindex="-1">备份：数据安全的最后一道防线 <a class="header-anchor" href="#备份-数据安全的最后一道防线" aria-label="Permalink to &quot;备份：数据安全的最后一道防线&quot;">​</a></h3><p><strong>没有备份的数据，就是随时准备消失的数据。</strong> 一个可靠的备份策略远比简单地复制文件要复杂。</p><h4 id="常见的备份误区" tabindex="-1">常见的备份误区 <a class="header-anchor" href="#常见的备份误区" aria-label="Permalink to &quot;常见的备份误区&quot;">​</a></h4><ul><li><strong>同盘复制不是备份</strong>: 硬盘是单点故障，一旦损坏，源数据和“备份”将一同丢失。</li><li><strong>同步不是备份</strong>: Dropbox/Google Drive 等同步工具会“忠实地”同步你的错误。如果你在本地误删或文件被病毒损坏，这些“更改”也会被同步到云端。</li><li><strong>RAID 不是备份</strong>: RAID 解决了硬盘物理故障的可用性问题，但无法防止文件误删、病毒感染或人为破坏。</li></ul><h4 id="有效备份策略的核心要素" tabindex="-1">有效备份策略的核心要素 <a class="header-anchor" href="#有效备份策略的核心要素" aria-label="Permalink to &quot;有效备份策略的核心要素&quot;">​</a></h4><ol><li><strong>版本控制 (Versioning)</strong>: 能够恢复到任意历史时间点的文件状态。</li><li><strong>异地存储 (Off-site)</strong>: 至少有一份备份存储在与源数据物理隔离的地方（例如云端或另一个城市的保险箱），以防范火灾、盗窃等灾害。</li><li><strong>自动化 (Automation)</strong>: 备份应该自动、定期执行，避免因人为疏忽而中断。</li><li><strong>加密 (Encryption)</strong>: 确保备份数据的安全，即使存储介质丢失，数据也不会泄露。</li><li><strong>定期验证 (Verification)</strong>: 定期尝试从备份中恢复数据，确保备份的完整性和可用性。</li></ol><hr><h3 id="api-与世界进行程序化交互" tabindex="-1">API：与世界进行程序化交互 <a class="header-anchor" href="#api-与世界进行程序化交互" aria-label="Permalink to &quot;API：与世界进行程序化交互&quot;">​</a></h3><p><strong>API (Application Programming Interface)</strong> 是线上服务提供的数据接口，允许你通过代码来访问和控制它们的功能，而无需通过浏览器。</p><h4 id="api-交互基础" tabindex="-1">API 交互基础 <a class="header-anchor" href="#api-交互基础" aria-label="Permalink to &quot;API 交互基础&quot;">​</a></h4><ul><li><strong>URL 结构</strong>: API 通常有结构化的 URL，如 <code>api.service.com/v1/users</code>。</li><li><strong>HTTP 请求</strong>: 使用 <code>curl</code> 或编程语言的 HTTP 库向 API 端点发送请求。</li><li><strong>数据格式</strong>: API 的返回结果最常用的是 <code>JSON</code> 格式，你可以使用 <code>jq</code> 等命令行工具来解析和提取所需信息。</li><li><strong>认证 (Authentication)</strong>: 多数 API 需要认证。常见的方式是 <strong>OAuth</strong>，它会给你一个私密的<strong>令牌 (Token)</strong>，你需要在每个请求中附上这个令牌，以证明你的身份。<strong>请务必像对待密码一样保管好你的 API 令牌！</strong></li></ul><h4 id="示例-获取天气信息" tabindex="-1">示例：获取天气信息 <a class="header-anchor" href="#示例-获取天气信息" aria-label="Permalink to &quot;示例：获取天气信息&quot;">​</a></h4><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">## 请求获取指定经纬度的天气信息</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">curl</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> https://api.weather.gov/points/42.3604,-71.094</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">## 使用 jq 解析返回的 JSON，提取小时预报的 URL</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">curl</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -s</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> https://api.weather.gov/points/42.3604,-71.094</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> |</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> jq</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -r</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;.properties.forecastHourly&#39;</span></span></code></pre></div><h4 id="自动化工作流" tabindex="-1">自动化工作流 <a class="header-anchor" href="#自动化工作流" aria-label="Permalink to &quot;自动化工作流&quot;">​</a></h4><p><a href="https://ifttt.com/" target="_blank" rel="noreferrer">IFTTT (If This Then That)</a> 这类服务可以让你轻松地连接不同的 API，创建自动化工作流。例如：“如果我在 Instagram 上发布了新照片，就自动将它备份到我的 Dropbox”。</p><hr><h3 id="markdown-轻量级文档标记语言" tabindex="-1">Markdown：轻量级文档标记语言 <a class="header-anchor" href="#markdown-轻量级文档标记语言" aria-label="Permalink to &quot;Markdown：轻量级文档标记语言&quot;">​</a></h3><p>Markdown 是一种简单易学的标记语言，让你可以在纯文本文档中添加格式。它的设计目标是“易读易写”，并且可以轻松转换为 HTML 等其他格式。</p><h4 id="核心语法" tabindex="-1">核心语法 <a class="header-anchor" href="#核心语法" aria-label="Permalink to &quot;核心语法&quot;">​</a></h4><ul><li><strong>标题</strong>: <code>## 一级标题</code>, <code>### 二级标题</code></li><li><strong>强调</strong>: <code>*斜体*</code>, <code>**粗体**</code>, <code>~~删除线~~</code></li><li><strong>列表</strong>: <ul><li>无序列表: <code>- 项目一</code>, <code>- 项目二</code></li><li>有序列表: <code>1. 项目一</code>, <code>2. 项目二</code></li></ul></li><li><strong>代码</strong>: <ul><li>行内代码: <code>`code`</code></li><li>代码块:<div class="language-python vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">python</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">def</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> hello</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">():</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    print</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Hello, World!&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div></li></ul></li><li><strong>链接</strong>: <code>[显示文本](https://example.com)</code></li><li><strong>图片</strong>: <code>![替代文本](image.jpg)</code></li><li><strong>引用</strong>: <code>&gt; 这是一段引用</code></li></ul><p>本教程本身就是使用 Markdown 编写的，它的应用范围极其广泛，从 GitHub 的 <code>README.md</code> 文件到各种笔记软件和论坛。</p><hr><h3 id="虚拟机与容器-创建隔离的计算环境" tabindex="-1">虚拟机与容器：创建隔离的计算环境 <a class="header-anchor" href="#虚拟机与容器-创建隔离的计算环境" aria-label="Permalink to &quot;虚拟机与容器：创建隔离的计算环境&quot;">​</a></h3><p><strong>虚拟机 (VMs)</strong> 和<strong>容器 (Containers)</strong> 是两种强大的技术，用于创建与主机系统隔离的、可复现的计算环境。</p><ul><li><strong>虚拟机 (Virtual Machines)</strong>: 模拟一整套硬件（CPU、内存、硬盘），并在其上运行一个完整的、独立的操作系统。它隔离性强，但资源开销较大。</li><li><strong>容器 (Containers)</strong>: 在主机操作系统内核之上，通过进程隔离技术创建一个轻量级的运行环境。它启动快、资源占用少，是现代云应用部署的主流方式。</li></ul><h4 id="常用工具" tabindex="-1">常用工具 <a class="header-anchor" href="#常用工具" aria-label="Permalink to &quot;常用工具&quot;">​</a></h4><ul><li><strong><a href="https://www.vagrantup.com/" target="_blank" rel="noreferrer">Vagrant</a></strong>: 一个用于自动化创建和配置虚拟开发环境的工具。你只需一个配置文件，就能一键启动一个配置好的虚拟机。</li><li><strong><a href="https://www.docker.com/" target="_blank" rel="noreferrer">Docker</a></strong>: 目前最流行的容器化平台。开发者可以将应用及其所有依赖打包到一个 Docker 镜像中，确保在任何地方都能以相同的方式运行。</li></ul><h4 id="云计算-cloud-computing" tabindex="-1">云计算 (Cloud Computing) <a class="header-anchor" href="#云计算-cloud-computing" aria-label="Permalink to &quot;云计算 (Cloud Computing)&quot;">​</a></h4><p>AWS, Google Cloud, Azure 等云服务商允许你按需租用虚拟机和容器资源。这为个人和企业提供了巨大的灵活性，可以根据需要快速获取强大的计算能力，而无需购买和维护物理硬件。</p><hr><h3 id="github-参与开源世界" tabindex="-1">GitHub：参与开源世界 <a class="header-anchor" href="#github-参与开源世界" aria-label="Permalink to &quot;GitHub：参与开源世界&quot;">​</a></h3><p><a href="https://github.com/" target="_blank" rel="noreferrer">GitHub</a> 是全球最大的代码托管和开源协作平台。为你每天都在使用的开源工具做贡献，比你想象的要简单。</p><h4 id="两种主要的贡献方式" tabindex="-1">两种主要的贡献方式 <a class="header-anchor" href="#两种主要的贡献方式" aria-label="Permalink to &quot;两种主要的贡献方式&quot;">​</a></h4><ol><li><p><strong>提议题 (Issues)</strong>:</p><ul><li><strong>作用</strong>: 报告你遇到的 Bug 或提出新功能建议。</li><li><strong>价值</strong>: 这是非常有价值的非代码贡献。一个清晰、可复现的 Bug 报告能为开发者节省大量时间。你也可以在现有的议题下参与讨论，提供更多信息。</li></ul></li><li><p><strong>提交拉取请求 (Pull Requests, PRs)</strong>:</p><ul><li><strong>作用</strong>: 提交你自己的代码更改，以修复问题或实现新功能。</li><li><strong>工作流程</strong>: <ol><li><strong>复刻 (Fork)</strong>: 在你的 GitHub 账号下创建一份项目的完整副本。</li><li><strong>克隆 (Clone)</strong>: 将你复刻的仓库下载到本地。</li><li><strong>创建分支 (Branch)</strong>: 为你的修改创建一个新的分支。</li><li><strong>修改与提交 (Commit)</strong>: 编写代码并提交你的更改。</li><li><strong>推送 (Push)</strong>: 将你的分支推送到你复刻的 GitHub 仓库。</li><li><strong>创建 PR</strong>: 在 GitHub 页面上，从你的分支向上游（原始）项目的主分支创建一个拉取请求。</li></ol></li></ul></li></ol><p>之后，项目维护者会审查你的代码，提出反馈，最终可能会将你的贡献合并到项目中。</p></div></div></main><footer class="VPDocFooter" data-v-0e85892c data-v-e497e503><!--[--><!--]--><div class="edit-info" data-v-e497e503><!----><div class="last-updated" data-v-e497e503><p class="VPLastUpdated" data-v-e497e503 data-v-864e4a08>最后更新于: <time datetime="2025-09-11T08:38:41.000Z" data-v-864e4a08></time></p></div></div><nav class="prev-next" aria-labelledby="doc-footer-aria-label" data-v-e497e503><span class="visually-hidden" id="doc-footer-aria-label" data-v-e497e503>Pager</span><div class="pager" data-v-e497e503><a class="VPLink link pager-link prev" href="/tutorial/cs-should-know" data-v-e497e503><!--[--><span class="desc" data-v-e497e503>上一页</span><span class="title" data-v-e497e503>每个计算机科学专业的学生应该知道什么？</span><!--]--></a></div><div class="pager" data-v-e497e503><a class="VPLink link pager-link next" href="/tutorial/python-tutorial" data-v-e497e503><!--[--><span class="desc" data-v-e497e503>下一页</span><span class="title" data-v-e497e503>Python入门</span><!--]--></a></div></nav></footer><!--[--><!--]--></div></div></div><!--[--><!--]--></div></div><!----><!--[--><!--]--></div></div>
    <script>window.__VP_HASH_MAP__=JSON.parse("{\"about.md\":\"CX0XiOn-\",\"guide_index.md\":\"CU5HW42C\",\"guide_wanderer-above-the-sea-of-fog.md\":\"DUFN0ymP\",\"guide_why-university.md\":\"mj-22JhJ\",\"index.md\":\"BCWpDx3C\",\"playground.md\":\"DobBL3I1\",\"schoolwork_index.md\":\"DfSU9jYI\",\"schoolwork_sizheng_essentials-of-chinese-modern-history.md\":\"6JHC-lsW\",\"schoolwork_sizheng_fundamentals-of-mao-zedong-thoughts-and-socialism-with-chinese-characteristics.md\":\"cq8kKWDQ\",\"schoolwork_sizheng_ideology-morality-and-rule-of-law.md\":\"CPnwDBoJ\",\"schoolwork_sizheng_introduction-to-xijinping-thought-on-socialism-with-chinese-characteristics-for-a-new-era.md\":\"B_KGSJ_I\",\"schoolwork_sizheng_labor-education.md\":\"BrYTUszR\",\"schoolwork_sizheng_marxism-general-principle.md\":\"CdJh3Jab\",\"schoolwork_sizheng_mental-health-education.md\":\"DRAhzKVx\",\"schoolwork_sizheng_military-theory.md\":\"MmAL5rX1\",\"schoolwork_sizheng_situation-and-policy.md\":\"DJ-EC42D\",\"tutorial_baoyan.md\":\"B9b6kSE_\",\"tutorial_cs-overview.md\":\"DJsdcrIE\",\"tutorial_cs-should-know.md\":\"CN_rUT9D\",\"tutorial_ee731-lecture-notes-translated.md\":\"Bs3XNfWH\",\"tutorial_ee731-lecture-notes.md\":\"B7XIk0lO\",\"tutorial_genai.md\":\"vCPB1hwn\",\"tutorial_getting-advice-from-senior.md\":\"C1P9zccH\",\"tutorial_growth.md\":\"BR23Pv0n\",\"tutorial_healthy-diet.md\":\"B6bKGhVw\",\"tutorial_index.md\":\"1N3DutTF\",\"tutorial_missing-cs-course.md\":\"DeqhNiae\",\"tutorial_numpy.md\":\"BLjiuJg4\",\"tutorial_python-tutorial.md\":\"CDk_252V\"}");window.__VP_SITE_DATA__=JSON.parse("{\"lang\":\"zh-CN\",\"dir\":\"ltr\",\"title\":\"Akademia\",\"description\":\"A VitePress Site\",\"base\":\"/\",\"head\":[],\"router\":{\"prefetchLinks\":true},\"appearance\":true,\"themeConfig\":{\"logo\":{\"light\":\"/logo-light.svg\",\"dark\":\"/logo-dark.svg\"},\"nav\":[{\"text\":\"首页\",\"link\":\"/\"},{\"text\":\"指引\",\"link\":\"/guide/\"},{\"text\":\"课业\",\"link\":\"/schoolwork/\"},{\"text\":\"教程\",\"link\":\"/tutorial/\"},{\"text\":\"关于\",\"link\":\"/about\"},{\"text\":\"更多\",\"items\":[{\"text\":\"功能实验室\",\"link\":\"/playground\"},{\"text\":\"VitePress 官网\",\"link\":\"https://vitepress.dev/\"}]}],\"sidebar\":{\"/guide/\":[{\"text\":\"指引篇：写在前面\",\"link\":\"/guide/\"},{\"text\":\"为什么是大学？\",\"link\":\"/guide/why-university\"},{\"text\":\"雾海漫游者\",\"link\":\"/guide/wanderer-above-the-sea-of-fog\"},{\"text\":\"展望未来\",\"link\":\"/guide/looking-forward\"}],\"/tutorial/\":[{\"text\":\"学习生活\",\"collapsed\":false,\"items\":[{\"text\":\"从成长到成才\",\"link\":\"/tutorial/growth\"},{\"text\":\"开始使用生成式人工智能\",\"link\":\"/tutorial/genai\"},{\"text\":\"向学长学姐请教\",\"link\":\"/tutorial/getting-advice-from-senior\"},{\"text\":\"保研那点儿事\",\"link\":\"/tutorial/baoyan\"}]},{\"text\":\"计算机进阶\",\"collapsed\":false,\"items\":[{\"text\":\"计算机科学概览\",\"link\":\"/tutorial/cs-overview\"},{\"text\":\"每个计算机科学专业的学生应该知道什么？\",\"link\":\"/tutorial/cs-should-know\"},{\"text\":\"缺失的计科课程\",\"link\":\"/tutorial/missing-cs-course\"},{\"text\":\"Python入门\",\"link\":\"/tutorial/python-tutorial\"},{\"text\":\"NumPy完全入门指南\",\"link\":\"/tutorial/numpy\"},{\"text\":\"Matrix Computations for Signal Processing翻译\",\"link\":\"/tutorial/ee731-lecture-notes\"}]}],\"/schoolwork/\":[{\"text\":\"课业篇：写在前面\",\"link\":\"/schoolwork/\"},{\"text\":\"专业课\",\"link\":\"/schoolwork/major-courses\"},{\"text\":\"大学英语\",\"collapsed\":false,\"items\":[{\"text\":\"大学英语（1）\",\"link\":\"/schoolwork/english/college-english-1\"},{\"text\":\"大学英语（2）\",\"link\":\"/schoolwork/english/college-english-2\"},{\"text\":\"大学英语（3）\",\"link\":\"/schoolwork/english/college-english-3\"},{\"text\":\"大学英语（4）\",\"link\":\"/schoolwork/english/college-english-4\"}]},{\"text\":\"大学数学\",\"collapsed\":false,\"items\":[{\"text\":\"高等数学（1）\",\"link\":\"/schoolwork/math/calculus-1\"},{\"text\":\"高等数学（2）\",\"link\":\"/schoolwork/math/calculus-2\"},{\"text\":\"线性代数\",\"link\":\"/schoolwork/math/linear-algebra\"},{\"text\":\"概率论与数理统计\",\"link\":\"/schoolwork/math/probability-and-statistics\"}]},{\"text\":\"思政课\",\"collapsed\":false,\"items\":[{\"text\":\"思想道德与法治\",\"link\":\"/schoolwork/sizheng/ideology-morality-and-rule-of-law\"},{\"text\":\"马克思主义基本原理\",\"link\":\"/schoolwork/sizheng/marxism-general-principle\"},{\"text\":\"中国近现代史纲要\",\"link\":\"/schoolwork/sizheng/essentials-of-chinese-modern-history\"},{\"text\":\"毛泽东思想和中国特色社会主义理论体系概论\",\"link\":\"/schoolwork/sizheng/fundamentals-of-mao-zedong-thoughts-and-socialism-with-chinese-characteristics\"},{\"text\":\"习近平新时代中国特色社会主义思想概论\",\"link\":\"/schoolwork/sizheng/introduction-to-xijinping-thought-on-socialism-with-chinese-characteristics-for-a-new-era\"},{\"text\":\"形势与政策\",\"link\":\"/schoolwork/sizheng/situation-and-policy\"},{\"text\":\"劳动教育\",\"link\":\"/schoolwork/sizheng/labor-education\"},{\"text\":\"军事理论\",\"link\":\"/schoolwork/sizheng/military-theory\"},{\"text\":\"心理健康教育\",\"link\":\"/schoolwork/sizheng/mental-health-education\"}]}]},\"socialLinks\":[{\"icon\":\"github\",\"link\":\"https://github.com/Wxh-1104/akademia\"},{\"icon\":{\"svg\":\"<svg role=\\\"img\\\" viewBox=\\\"0 0 24 24\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\"><title>QQ</title><path d=\\\"M21.395 15.035a40 40 0 0 0-.803-2.264l-1.079-2.695c.001-.032.014-.562.014-.836C19.526 4.632 17.351 0 12 0S4.474 4.632 4.474 9.241c0 .274.013.804.014.836l-1.08 2.695a39 39 0 0 0-.802 2.264c-1.021 3.283-.69 4.643-.438 4.673.54.065 2.103-2.472 2.103-2.472 0 1.469.756 3.387 2.394 4.771-.612.188-1.363.479-1.845.835-.434.32-.379.646-.301.778.343.578 5.883.369 7.482.189 1.6.18 7.14.389 7.483-.189.078-.132.132-.458-.301-.778-.483-.356-1.233-.646-1.846-.836 1.637-1.384 2.393-3.302 2.393-4.771 0 0 1.563 2.537 2.103 2.472.251-.03.581-1.39-.438-4.673\\\"/></svg>\"},\"link\":\"https://weixin.qq.com/\",\"ariaLabel\":\"QQ\"}],\"darkModeSwitchLabel\":\"深浅模式\",\"sidebarMenuLabel\":\"目录\",\"returnToTopLabel\":\"返回顶部\",\"outline\":{\"level\":[2,4],\"label\":\"当前页大纲\"},\"lastUpdated\":{\"text\":\"最后更新于\",\"formatOptions\":{\"dateStyle\":\"short\",\"timeStyle\":\"medium\"}},\"docFooter\":{\"prev\":\"上一页\",\"next\":\"下一页\"},\"search\":{\"provider\":\"local\"}},\"locales\":{},\"scrollOffset\":134,\"cleanUrls\":true}");</script>
    
  </body>
</html>